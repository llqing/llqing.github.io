<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>相关性强弱判定</title>
      <link href="/2019/09/02/%E7%9B%B8%E5%85%B3%E6%80%A7%E5%BC%BA%E5%BC%B1%E5%88%A4%E5%AE%9A/"/>
      <url>/2019/09/02/%E7%9B%B8%E5%85%B3%E6%80%A7%E5%BC%BA%E5%BC%B1%E5%88%A4%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<pre><code>我们知道，两个变量x和y正(负)相关时，它们就有相同(反)的变化趋势，即当x由小变大时，相应的y有由小(大)变大(小)的趋势，因此可以用回归直线来描述这种关系。与此相关的一个问题是:如何描述x和y之间的这种线性关系的强弱?例如，物理成绩与数学成绩正相关，但数学成绩能够在多大程度上决定物理成绩，这就是相关强弱的问题。类似的还有吸烟与健康的负相关强度、父母身高与子女身高的正相关强度、农作物的产量与施肥量的正相关强度等.统计中用相关系数r来衡量两个变量之间线性关系的强弱。若相应于变量x的取值，变量y的观测值为$y_i​$(1≤i≤n),则两个变量的相关系数的计算公式为</code></pre><p>$$<br>r=\frac{\sum_{i=1}^{n}\left(x_{i}-\overline{x}\right)\left(y_{i}-\overline{y}\right)}{\sqrt{\sum_{i=1}^{n}\left(x_{i}-\overline{x}\right)^{2} \sum_{j=1}^{n}\left(y_{j}-\overline{y}\right)^{2}}}<br>$$<br>不同的相关性可以从散点图上直观地反映出来。图1、图2反映了变量x和y之间很强的线性相关关系，而图4中的两个变量的线性相关程度很弱。对于相关系数r，首先值得注意的是它的符号，当r为正时，表明变量x和y正相关；当r为负时，表明变量x和y负相关，反映在散点图上，图1中的变量x和y正相关，这时的r为正，图2中的变量x和y负相关，这时的r为负.<br>    另一个值得注意的是r的大小。统计学认为，对于变量x, y,如果r∈[- 1,-0.75]，那么负相关很强；如果r∈[0.75, 1]，那么正相关很强;如果r∈(-0. 75,-0.30]或r∈[0.30, 0.75)，那么相关性一般;如果r∈[-0.25, 0.25],那么相关性较弱。反映在散点围上，图1的r=0.97,这些点有明显的从左下角到右上角沿直线分布趋势，这时用线性回归模型描述两个变量之间的关系效果很好；图2的r=-0.85，这些点也有明显的从左上角到右下角沿直线分布趋势，这时用线性回归模型描述两个变量之间的关系也有好的效果;图3的r=0.24,这些点的分布几乎没有什么规则，这时不能用线性<br>回归模型描述两个变量之间的关系；图4的r=-0.05，两个变量之间几乎没有什么关系，这时就更不能用线性回归模型描述两个变量之间的关系.<br><img src="https://img.vim-cn.com/98/1fa17ac4c3dd424bf4459a4289e1ee2a6fb34a.png" alt="1567414057818"></p>]]></content>
      
      
      <categories>
          
          <category> 概率统计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见数据结构的python实现</title>
      <link href="/2019/08/22/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/08/22/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>数据结构作为计算机基础的必修内容，也是很多大型互联网企业面试的必考题。可想而知，它在计算机领域的重要性。</p><p>然而很多计算机专业的同学，都仅仅是了解数据结构的相关理论，却无法用代码实现各种数据结构。</p><p>今日整理了一份常见数据结构的 Python 实现，希望大家能够参考代码，亲自动手通过代码实现各种数据结构，以巩固知识加深理解。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Stack(object):</span><br><span class="line">    def __init__(self, limit=10):</span><br><span class="line">        self.stack = [] #存放元素</span><br><span class="line">        self.limit = limit #栈容量极限</span><br><span class="line">    def push(self, data): #判断栈是否溢出</span><br><span class="line">        if len(self.stack) &gt;= self.limit:</span><br><span class="line">            print(&apos;StackOverflowError&apos;)</span><br><span class="line">            pass</span><br><span class="line">        self.stack.append(data)</span><br><span class="line">    def pop(self):</span><br><span class="line">        if self.stack:</span><br><span class="line">            return self.stack.pop()</span><br><span class="line">        else:</span><br><span class="line">            raise IndexError(&apos;pop from an empty stack&apos;) #空栈不能被弹出</span><br><span class="line">    def peek(self): #查看堆栈的最上面的元素</span><br><span class="line">        if self.stack:</span><br><span class="line">            return self.stack[-1]</span><br><span class="line">    def is_empty(self): #判断栈是否为空</span><br><span class="line">        return not bool(self.stack)</span><br><span class="line">    def size(self): #返回栈的大小</span><br><span class="line">        return len(self.stack)</span><br></pre></td></tr></table></figure><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class Node:  </span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data  </span><br><span class="line">        self.next = None  </span><br><span class="line">class Linked_List:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = None</span><br><span class="line">    def initlist(self,data_list):    #链表初始化函数</span><br><span class="line">        self.head=Node(data_list[0])   #创建头结点</span><br><span class="line">        temp=self.head</span><br><span class="line">        for i in data_list[1:]: #逐个为 data 内的数据创建结点, 建立链表</span><br><span class="line">            node=Node(i)</span><br><span class="line">            temp.next=node</span><br><span class="line">            temp=temp.next</span><br><span class="line">    def is_empty(self):  #判断链表是否为空</span><br><span class="line">        if self.head.next==None:</span><br><span class="line">            print(&quot;Linked_list is empty&quot;)</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    def get_length(self):  #获取链表的长度</span><br><span class="line">        temp=self.head #临时变量指向队列头部</span><br><span class="line">        length=0 #计算链表的长度变量</span><br><span class="line">        while temp!=None:</span><br><span class="line">            length=length+1</span><br><span class="line">            temp=temp.next</span><br><span class="line">        return length #返回链表的长度</span><br><span class="line">    def insert(self,key,value): #链表插入数据函数</span><br><span class="line">        if key&lt;0 or key&gt;self.get_length()-1:</span><br><span class="line">            print(&quot;insert error&quot;)</span><br><span class="line">        temp=self.head</span><br><span class="line">        i=0</span><br><span class="line">        while i&lt;=key: #遍历找到索引值为 key 的结点后, 在其后面插入结点</span><br><span class="line">            pre=temp</span><br><span class="line">            temp=temp.next</span><br><span class="line">            i=i+1</span><br><span class="line">        node=Node(value)</span><br><span class="line">        pre.next=node</span><br><span class="line">        node.next=temp</span><br><span class="line">    def print_list(self):   #遍历链表，并将元素依次打印出来</span><br><span class="line">        print(&quot;linked_list:&quot;)</span><br><span class="line">        temp=self.head</span><br><span class="line">        new_list=[]</span><br><span class="line">        while temp is not None:</span><br><span class="line">            new_list.append(temp.data)</span><br><span class="line">            temp=temp.next</span><br><span class="line">        print(new_list)</span><br><span class="line">    def remove(self,key):  #链表删除数据函数</span><br><span class="line">        if key&lt;0 or key&gt;self.get_length()-1:</span><br><span class="line">            print(&quot;insert error&quot;)</span><br><span class="line">        i=0</span><br><span class="line">        temp=self.head</span><br><span class="line">        while temp !=None:  #遍历找到索引值为 key 的结点</span><br><span class="line">            pre=temp</span><br><span class="line">            temp=temp.next</span><br><span class="line">            i=i+1</span><br><span class="line">            if i==key:</span><br><span class="line">                pre.next=temp.next</span><br><span class="line">                temp=None</span><br><span class="line">                return True</span><br><span class="line">        pre.next=None</span><br><span class="line">    def reverse(self): #将链表反转</span><br><span class="line">        prev = None</span><br><span class="line">        current = self.head</span><br><span class="line">        while current:</span><br><span class="line">            next_node = current.next</span><br><span class="line">            current.next = prev</span><br><span class="line">            prev = current</span><br><span class="line">            current = next_node</span><br><span class="line">        self.head = prev</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    # 双向链表节点</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = None</span><br><span class="line">        self.prev = None</span><br><span class="line">class DLinkList(object):</span><br><span class="line">    # 双向链表</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._head = None</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        # 判断链表是否为空</span><br><span class="line">        return self._head == None</span><br><span class="line">    def get_length(self):</span><br><span class="line">        # 返回链表的长度</span><br><span class="line">        cur = self._head</span><br><span class="line">        count = 0</span><br><span class="line">        while cur != None:</span><br><span class="line">            count=count+1</span><br><span class="line">            cur = cur.next</span><br><span class="line">        return count</span><br><span class="line">    def travel(self):</span><br><span class="line">        # 遍历链表</span><br><span class="line">        cur = self._head</span><br><span class="line">        while cur != None:</span><br><span class="line">            print(cur.item)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print(&quot;&quot;)</span><br><span class="line">    def add(self, item):</span><br><span class="line">        # 头部插入元素</span><br><span class="line">        node = Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            # 如果是空链表，将_head指向node</span><br><span class="line">            self._head = node</span><br><span class="line">        else:</span><br><span class="line">            # 将node的next指向_head的头节点</span><br><span class="line">            node.next = self._head</span><br><span class="line">            # 将_head的头节点的prev指向node</span><br><span class="line">            self._head.prev = node</span><br><span class="line">            # 将_head 指向node</span><br><span class="line">            self._head = node</span><br><span class="line">    def append(self, item):</span><br><span class="line">        # 尾部插入元素</span><br><span class="line">        node = Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            # 如果是空链表，将_head指向node</span><br><span class="line">            self._head = node</span><br><span class="line">        else:</span><br><span class="line">            # 移动到链表尾部</span><br><span class="line">            cur = self._head</span><br><span class="line">            while cur.next != None:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            # 将尾节点cur的next指向node</span><br><span class="line">            cur.next = node</span><br><span class="line">            # 将node的prev指向cur</span><br><span class="line">            node.prev = cur</span><br><span class="line">    def search(self, item):</span><br><span class="line">        # 查找元素是否存在</span><br><span class="line">        cur = self._head</span><br><span class="line">        while cur != None:</span><br><span class="line">            if cur.item == item:</span><br><span class="line">                return True</span><br><span class="line">            cur = cur.next</span><br><span class="line">        return False</span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        # 在指定位置添加节点</span><br><span class="line">        if pos &lt;= 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        elif pos &gt; (self.length()-1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        else:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = 0</span><br><span class="line">            # 移动到指定位置的前一个位置</span><br><span class="line">            while count &lt; (pos-1):</span><br><span class="line">                count += 1</span><br><span class="line">                cur = cur.next</span><br><span class="line">            # 将node的prev指向cur</span><br><span class="line">            node.prev = cur</span><br><span class="line">            # 将node的next指向cur的下一个节点</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            # 将cur的下一个节点的prev指向node</span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            # 将cur的next指向node</span><br><span class="line">            cur.next = node</span><br><span class="line">    def remove(self, item):</span><br><span class="line">        # 删除元素</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            cur = self._head</span><br><span class="line">            if cur.item == item:</span><br><span class="line">                # 如果首节点的元素即是要删除的元素</span><br><span class="line">                if cur.next == None:</span><br><span class="line">                    # 如果链表只有这一个节点</span><br><span class="line">                    self._head = None</span><br><span class="line">                else:</span><br><span class="line">                    # 将第二个节点的prev设置为None</span><br><span class="line">                    cur.next.prev = None</span><br><span class="line">                    # 将_head指向第二个节点</span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                return</span><br><span class="line">            while cur != None:</span><br><span class="line">                if cur.item == item:</span><br><span class="line">                    # 将cur的前一个节点的next指向cur的后一个节点</span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    # 将cur的后一个节点的prev指向cur的前一个节点</span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                    break</span><br><span class="line">                cur = cur.next</span><br></pre></td></tr></table></figure><h3 id="队列（链表形式实现）"><a href="#队列（链表形式实现）" class="headerlink" title="队列（链表形式实现）"></a>队列（链表形式实现）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    def __init__(self,elem,next=None):</span><br><span class="line">        self.elem = elem #表示对应的元素值</span><br><span class="line">        self.next=next #表示下一个链接的链点</span><br><span class="line">class Queue(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = None #头部链点为 None</span><br><span class="line">        self.rear = None #尾部链点为 None</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.head is None #判断队列是否为空</span><br><span class="line">    def enqueue(self, elem):</span><br><span class="line">        p = Node(elem) #初始化一个新的点</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self.head = p #队列头部为新的链点</span><br><span class="line">            self.rear = p #队列尾部为新的链点</span><br><span class="line">        else:</span><br><span class="line">            self.rear.next = p #队列尾部的后继是这个新的点</span><br><span class="line">            self.rear =p #然后让队列尾部指针指向这个新的点</span><br><span class="line">    def dequeue(self):</span><br><span class="line">        if self.is_empty(): #判断队列是否为空</span><br><span class="line">            print(&apos;Queue_is_empty&apos;) #若队列为空，则退出 dequeue 操作</span><br><span class="line">        else:</span><br><span class="line">            result = self.head.elem #result为队列头部元素</span><br><span class="line">            self.head = self.head.next #改变队列头部指针位置</span><br><span class="line">            return result #返回队列头部元素</span><br><span class="line">    def peek(self):</span><br><span class="line">        if self.is_empty(): #判断队列是否为空</span><br><span class="line">            print(&apos;NOT_FOUND&apos;) #为空则返回 NOT_FOUND</span><br><span class="line">        else:</span><br><span class="line">            return self.head.elem #返回队列头部元素</span><br><span class="line">    def print_queue(self):</span><br><span class="line">        print(&quot;queue:&quot;)</span><br><span class="line">        temp=self.head</span><br><span class="line">        myqueue=[] #暂时存放队列数据</span><br><span class="line">        while temp is not None:</span><br><span class="line">            myqueue.append(temp.elem)</span><br><span class="line">            temp=temp.next</span><br><span class="line">        print(myqueue)</span><br></pre></td></tr></table></figure><h3 id="队列（数组形式实现）"><a href="#队列（数组形式实现）" class="headerlink" title="队列（数组形式实现）"></a>队列（数组形式实现）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Queue():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.entries = [] #表示队列内的参数</span><br><span class="line">        self.length = 0 #表示队列的长度</span><br><span class="line">        self.front=0 #表示队列头部位置</span><br><span class="line">    def enqueue(self, item):</span><br><span class="line">        self.entries.append(item) #添加元素到队列里面</span><br><span class="line">        self.length = self.length + 1 #队列长度增加 1</span><br><span class="line">    def dequeue(self):</span><br><span class="line">        self.length = self.length - 1 #队列的长度减少 1</span><br><span class="line">        dequeued = self.entries[self.front] #队首元素为dequeued</span><br><span class="line">        self.front-=1 #队首的位置减少1</span><br><span class="line">        self.entries = self.entries[self.front:] #队列的元素更新为退队之后的队列</span><br><span class="line">        return dequeued</span><br><span class="line">    def peek(self):</span><br><span class="line">        return self.entries[0] #直接返回队列的队首元素</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    def __init__(self,item):</span><br><span class="line">        self.item=item #表示对应的元素</span><br><span class="line">        self.left=None #表示左节点</span><br><span class="line">        self.right=None #表示右节点</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return str(self.item)  #print 一个 Node 类时会打印 __str__ 的返回值</span><br><span class="line">class Tree(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.root=Node(&apos;root&apos;)  #根节点定义为 root 永不删除，作为哨兵使用。</span><br><span class="line">    def add(self,item):</span><br><span class="line">        node = Node(item)</span><br><span class="line">        if self.root is None:  #如果二叉树为空，那么生成的二叉树最终为新插入树的点</span><br><span class="line">            self.root = node</span><br><span class="line">        else:</span><br><span class="line">            q = [self.root] # 将q列表，添加二叉树的根节点</span><br><span class="line">            while True:</span><br><span class="line">                pop_node = q.pop(0)</span><br><span class="line">                if pop_node.left is None: #左子树为空则将点添加到左子树</span><br><span class="line">                    pop_node.left = node</span><br><span class="line">                    return</span><br><span class="line">                elif pop_node.right is None: #右子树为空则将点添加到右子树</span><br><span class="line">                    pop_node.right = node</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    q.append(pop_node.left)</span><br><span class="line">                    q.append(pop_node.right)</span><br><span class="line">    def get_parent(self, item):</span><br><span class="line">        if self.root.item == item:</span><br><span class="line">            return None  # 根节点没有父节点</span><br><span class="line">        tmp = [self.root] # 将tmp列表，添加二叉树的根节点</span><br><span class="line">        while tmp:</span><br><span class="line">            pop_node = tmp.pop(0)</span><br><span class="line">            if pop_node.left and pop_node.left.item == item: #某点的左子树为寻找的点</span><br><span class="line">                return pop_node #返回某点，即为寻找点的父节点</span><br><span class="line">            if pop_node.right and pop_node.right.item == item: #某点的右子树为寻找的点</span><br><span class="line">                return pop_node #返回某点，即为寻找点的父节点</span><br><span class="line">            if pop_node.left is not None: #添加tmp 元素</span><br><span class="line">                tmp.append(pop_node.left)</span><br><span class="line">            if pop_node.right is not None:</span><br><span class="line">                tmp.append(pop_node.right)</span><br><span class="line">        return None</span><br><span class="line">    def delete(self, item):</span><br><span class="line">        if self.root is None:  # 如果根为空，就什么也不做</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        parent = self.get_parent(item)</span><br><span class="line">        if parent:</span><br><span class="line">            del_node = parent.left if parent.left.item == item else parent.right  # 待删除节点</span><br><span class="line">            if del_node.left is None:</span><br><span class="line">                if parent.left.item == item:</span><br><span class="line">                    parent.left = del_node.right</span><br><span class="line">                else:</span><br><span class="line">                    parent.right = del_node.right</span><br><span class="line">                del del_node</span><br><span class="line">                return True</span><br><span class="line">            elif del_node.right is None:</span><br><span class="line">                if parent.left.item == item:</span><br><span class="line">                    parent.left = del_node.left</span><br><span class="line">                else:</span><br><span class="line">                    parent.right = del_node.left</span><br><span class="line">                del del_node</span><br><span class="line">                return True</span><br><span class="line">            else:  # 左右子树都不为空</span><br><span class="line">                tmp_pre = del_node</span><br><span class="line">                tmp_next = del_node.right</span><br><span class="line">                if tmp_next.left is None:</span><br><span class="line">                    # 替代</span><br><span class="line">                    tmp_pre.right = tmp_next.right</span><br><span class="line">                    tmp_next.left = del_node.left</span><br><span class="line">                    tmp_next.right = del_node.right</span><br><span class="line"></span><br><span class="line">                else:</span><br><span class="line">                    while tmp_next.left:  # 让tmp指向右子树的最后一个叶子</span><br><span class="line">                        tmp_pre = tmp_next</span><br><span class="line">                        tmp_next = tmp_next.left</span><br><span class="line">                    # 替代</span><br><span class="line">                    tmp_pre.left = tmp_next.right</span><br><span class="line">                    tmp_next.left = del_node.left</span><br><span class="line">                    tmp_next.right = del_node.right</span><br><span class="line">                if parent.left.item == item:</span><br><span class="line">                    parent.left = tmp_next</span><br><span class="line">                else:</span><br><span class="line">                    parent.right = tmp_next</span><br><span class="line">                del del_node</span><br><span class="line">                return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.nodes = dict()  # 构建字典</span><br><span class="line">        self.is_leaf = False</span><br><span class="line">    def insert(self, word: str):  </span><br><span class="line">        curr = self</span><br><span class="line">        for char in word:</span><br><span class="line">            if char not in curr.nodes:</span><br><span class="line">                curr.nodes[char] = TrieNode()</span><br><span class="line">            curr = curr.nodes[char]</span><br><span class="line">        curr.is_leaf = True</span><br><span class="line">    def insert_many(self, words: [str]):</span><br><span class="line">        for word in words:</span><br><span class="line">            self.insert(word)</span><br><span class="line">    def search(self, word: str):</span><br><span class="line">        curr = self</span><br><span class="line">        for char in word:</span><br><span class="line">            if char not in curr.nodes:</span><br><span class="line">                return False</span><br><span class="line">            curr = curr.nodes[char]</span><br><span class="line">        return curr.is_leaf</span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class heap(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #初始化一个空堆，使用数组来在存放堆元素，节省存储</span><br><span class="line">        self.data_list = []</span><br><span class="line">    def get_parent_index(self,index):</span><br><span class="line">        #返回父节点的下标</span><br><span class="line">        if index == 0 or index &gt; len(self.data_list) -1:</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            return (index -1) &gt;&gt; 1</span><br><span class="line">    def swap(self,index_a,index_b):</span><br><span class="line">        #交换数组中的两个元素</span><br><span class="line">        self.data_list[index_a],self.data_list[index_b] = self.data_list[index_b],self.data_list[index_a]</span><br><span class="line">    def insert(self,data):</span><br><span class="line">        #先把元素放在最后，然后从后往前依次堆化</span><br><span class="line">        #这里以大顶堆为例，如果插入元素比父节点大，则交换，直到最后</span><br><span class="line">        self.data_list.append(data)</span><br><span class="line">        index = len(self.data_list) -1 </span><br><span class="line">        parent = self.get_parent_index(index)</span><br><span class="line">        #循环，直到该元素成为堆顶，或小于父节点（对于大顶堆) </span><br><span class="line">        while parent is not None and self.data_list[parent] &lt; self.data_list[index]:</span><br><span class="line">            #交换操作</span><br><span class="line">            self.swap(parent,index)</span><br><span class="line">            index = parent</span><br><span class="line">            parent = self.get_parent_index(parent)</span><br><span class="line">    def removeMax(self):</span><br><span class="line">        #删除堆顶元素，然后将最后一个元素放在堆顶，再从上往下依次堆化</span><br><span class="line">        remove_data = self.data_list[0]</span><br><span class="line">        self.data_list[0] = self.data_list[-1]</span><br><span class="line">        del self.data_list[-1]</span><br><span class="line"></span><br><span class="line">        #堆化</span><br><span class="line">        self.heapify(0)</span><br><span class="line">        return remove_data</span><br><span class="line">    def heapify(self,index):</span><br><span class="line">        #从上往下堆化，从index 开始堆化操作 (大顶堆)</span><br><span class="line">        total_index = len(self.data_list) -1</span><br><span class="line">        while True:</span><br><span class="line">            maxvalue_index = index</span><br><span class="line">            if 2*index +1 &lt;=  total_index and self.data_list[2*index +1] &gt; self.data_list[maxvalue_index]:</span><br><span class="line">                maxvalue_index = 2*index +1</span><br><span class="line">            if 2*index +2 &lt;=  total_index and self.data_list[2*index +2] &gt; self.data_list[maxvalue_index]:</span><br><span class="line">                maxvalue_index = 2*index +2</span><br><span class="line">            if maxvalue_index == index:</span><br><span class="line">                break</span><br><span class="line">            self.swap(index,maxvalue_index)</span><br><span class="line">            index = maxvalue_index</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用docker命令</title>
      <link href="/2019/08/20/%C2%96%E5%B8%B8%E7%94%A8docker%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/20/%C2%96%E5%B8%B8%E7%94%A8docker%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Docker是一个不断发展的系统，开发人员积极改进使用和性能。所以命令总是在变化。docker一些老的命令经常被弃用，并被新的或更有效的命令取代。您可以使用帮助选项检查Docker安装上的最新可用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker --help</span><br></pre></td></tr></table></figure><p>要使用特定命令的选项，可以使用该命令的help选项。例如，要使用docker run命令选项，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --help</span><br></pre></td></tr></table></figure><p>目前，有13个管理命令和41个通用命令。下面是我们的docker命令：</p><ul><li><strong>docker attach-将本地输入/输出/错误流附加到正在运行的容器。</strong></li><li><strong>docker commit-从容器的当前更改状态创建一个新镜像。</strong></li><li><strong>docker exec-在正在运行的容器中运行命令。</strong></li><li><strong>docker history-显示镜像的历史记录。</strong></li><li><strong>docker info-显示系统信息，包括镜像和容器数。</strong></li><li><strong>docker inspect-查找有关Docker容器和镜像的系统级信息。</strong></li><li><strong>docker login-登录到本地注册表或Docker Hub。</strong></li><li><strong>docker pull-从本地注册表或Docker Hub中提取镜像或存储库。</strong></li><li><strong>docker ps-列出容器的各种属性。</strong></li><li><strong>docker restart-停止并启动容器。</strong></li><li><strong>docker rm-移除容器。</strong></li><li><strong>docker rmi-删除镜像。</strong></li><li><strong>docker run-在一个独立的容器中运行一个命令。</strong></li><li><strong>docker search-在Docker Hub中搜索镜像。</strong></li><li><strong>docker start-启动已经停止的容器。</strong></li><li><strong>docker stop-停止运行容器。</strong></li><li><strong>docker version -提供Docker版本信息。</strong></li></ul><p>让我们深入研究一下使用这些docker命令可以执行的各种操作。</p><p>注意：对于部分信息转储，我们使用了三个点（…）。</p><p><strong>显示Docker版本和系统信息</strong></p><p>当您在工作时，您通常都需要检查Docker版本和Docker系统信息。您可以使用以下命令查找Docker版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line">Version: 18.03.0-ce</span><br><span class="line">API version: 1.37</span><br><span class="line">Go version: go1.9.4</span><br><span class="line">Git commit: 0520e24</span><br><span class="line">Built: Wed Mar 21 23:06:22 2018</span><br><span class="line">OS/Arch: darwin/amd64</span><br><span class="line">Experimental: false</span><br><span class="line">Orchestrator: swarm</span><br><span class="line">Server:</span><br><span class="line">Engine:</span><br><span class="line">Version: 18.03.0-ce</span><br><span class="line">API version: 1.37 (minimum version 1.12)</span><br><span class="line">Go version: go1.9.4</span><br><span class="line">Git commit: 0520e24</span><br><span class="line">Built: Wed Mar 21 23:14:32 2018</span><br><span class="line">OS/Arch: linux/amd64</span><br><span class="line">Experimental: true</span><br></pre></td></tr></table></figure><p>另一个重要的命令是<strong>docker info</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line"></span><br><span class="line">Containers: 0</span><br><span class="line">Running: 0</span><br><span class="line">Paused: 0</span><br><span class="line">Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.03.0-ce</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line">Backing Filesystem: extfs</span><br><span class="line">Supports d_type: true</span><br><span class="line">Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line">Volume: local</span><br><span class="line">Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog</span><br><span class="line"></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>它将向您显示各种重要信息，如服务器版本、存储驱动程序、内核版本、操作系统、总内存等等。当您试图为当前的Docker安装增加新的资源或试图解决系统级资源分配问题时，这些信息可能很有用。这也是一种快速检查正在运行、暂停和停止的容器数量以及下载到系统的镜像数量的方法。</p><p><strong>搜索和下载Docker镜像</strong></p><p>您可以使用docker search命令在docker hub上搜索已经可用的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker search ubuntu</span><br><span class="line"></span><br><span class="line">NAME DESCRIPTION STARS OFFICIAL AUTOMATED</span><br><span class="line">ubuntu Ubuntu is a Debian-based Linux operating sys… 7861 [OK]</span><br><span class="line">dorowu/ubuntu-desktop-lxde-vnc Ubuntu with openssh-server and NoVNC 190 [OK]</span><br><span class="line">rastasheep/ubuntu-sshd Dockerized SSH service, built on top of offi… 156 [OK]</span><br><span class="line">ansible/ubuntu14.04-ansible Ubuntu 14.04 LTS with ansible 93 [OK]</span><br><span class="line">ubuntu-upstart Upstart is an event-based replacement for th… 87 [OK]</span><br><span class="line">neurodebian NeuroDebian provides neuroscience research s… 50 [OK]</span><br><span class="line"></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>上面的搜索显示了对Ubuntu可用的镜像及其描述。</p><p>让我们下载最著名的Ubuntu镜像。您可以使用docker pull命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu</span><br><span class="line"></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">6b98dfc16071: Pull complete</span><br><span class="line">4001a1209541: Pull complete</span><br><span class="line">6319fc68c576: Pull complete</span><br><span class="line">b24603670dc3: Pull complete</span><br><span class="line">97f170c87c6f: Pull complete</span><br><span class="line">Digest: sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p><strong>玩转Docker镜像</strong></p><p>您可以使用docker info命令查找您拥有的镜像数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line"></span><br><span class="line">Containers: 0</span><br><span class="line">Running: 0</span><br><span class="line">Paused: 0</span><br><span class="line">Stopped: 0</span><br><span class="line">Images: 1</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>该 docker images命令将详细列出您拥有的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">ubuntu latest 113a43faa138 2 weeks ago 81.2MB</span><br></pre></td></tr></table></figure><p>假设您决定下载nginx图像。你可以运行另一个docker pull  命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure><p>现在，如果您查看Docker镜像，您会看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">ubuntu latest 113a43faa138 2 weeks ago 81.2MB</span><br><span class="line">nginx latest cd5239a0906a 2 weeks ago</span><br></pre></td></tr></table></figure><p> 您可以使用这些页面查找镜像的特定版本。在Ubuntu页面上，您会注意到Ubuntu的最新版本是18.04。如果要查找16.04版本的Ubuntu，可以使用16.04标记下载该特定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><p>然后你将会有两个Ubuntu镜像版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">ubuntu 16.04 5e8b97a2a082 2 weeks ago 114MB</span><br><span class="line">ubuntu latest 113a43faa138 2 weeks ago 81.2MB</span><br><span class="line">nginx latest cd5239a0906a 2 weeks ago 109MB</span><br></pre></td></tr></table></figure><p>注意：您不需要注册Docker Hub即可拉取镜像。但是，如果要将图像推送到Docker Hub，则需要注册，然后使用Docker login命令登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login --username = yourhubusername --email = youremail@company.com</span><br></pre></td></tr></table></figure><p><strong>运行镜像的Docker容器</strong></p><p>假设您想在docker上运行nginx服务器。运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 8080:80 nginx</span><br></pre></td></tr></table></figure><p>docker run命令从先前从Docker Hub中提取的nginx镜像创建了一个nginx容器。“-p 8080:80”告诉Docker将本地主机端口8080映射到Docker容器的端口80。您应该能够从<a href="http://localhost:8080访问nginx服务器。" target="_blank" rel="noopener">http://localhost:8080访问nginx服务器。</a></p><p>nginx容器附加到命令行。因此，如果退出命令行，容器将不再运行。您可以使用detach（“-d”）选项启动nginx容器，这样即使您退出命令行，它也可以继续运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><p>上面的命令将以分离模式启动容器并返回命令行。</p><p><strong>列出Docker容器</strong></p><p>该  docker ps 命令允许您查找正在运行的所有容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 7 minutes ago Up 7 minutes 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>它显示了容器的各种属性。您可以看到它是从nginx镜像创建的，并且还显示了端口转发信息。容器ID和名称属性需要特别说明。您可以使用这些属性来唯一地标识容器。这两个属性都是自动生成的。但您也可以在容器创建过程中为容器命名。让我们创建一个名为“my_nginx”的nginx容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my_nginx -p 8888:80 -d nginx</span><br></pre></td></tr></table></figure><p>让我们再次列出Docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">e7b19b6ad778 nginx &quot;nginx -g &apos;daemon of…&quot; About a minute ago Up About a minute 0.0.0.0:8888-&gt;80/tcp my_nginx</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 15 minutes ago Up 16 minutes 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p><strong>注意，新容器的名称是“my_nginx”。当您处理大量容器时，可以使用命名规则。这将帮助您更好地组织容器。</strong></p><p>docker ps命令只显示正在运行的容器。如果对上述情况使用docker info命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line"></span><br><span class="line">Containers: 2</span><br><span class="line">Running: 2</span><br><span class="line">Paused: 0</span><br><span class="line">Stopped: 0</span><br><span class="line">Images: 3</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>您可以看到有两个容器正在运行。如果您有一个暂停或停止的容器，您必须使用a ll（“-a”）选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure><p><strong>启动，停止，重新启动和杀掉容器</strong></p><p>假设您要停止’my_nginx’容器。您可以使用CONTAINER ID或NAME。在这种情况下，让我们使用名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop my_nginx</span><br><span class="line"></span><br><span class="line">my_nginx</span><br></pre></td></tr></table></figure><p>我们列出Docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 27 minutes ago Up 27 minutes 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">e7b19b6ad778 nginx &quot;nginx -g &apos;daemon of…&quot; 12 minutes ago Exited (0) About a minute ago my_nginx</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 27 minutes ago Up 27 minutes 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>如果docker ps 没有-a选项运行，它只显示正在运行的容器。在第二种情况下，您可以看到’my_nginx’容器处于退出状态。</p><p>让我们docker start容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker start my_nginx</span><br><span class="line"></span><br><span class="line">my_nginx</span><br></pre></td></tr></table></figure><p>如果您查看Docker容器列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">e7b19b6ad778 nginx &quot;nginx -g &apos;daemon of…&quot; 16 minutes ago Up 29 seconds 0.0.0.0:8888-&gt;80/tcp my_nginx</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 30 minutes ago Up 30 minutes 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>您可以看到STATUS显示容器’my_nginx’再次启动。</p><p>如果由于某些问题而想要停止并启动容器，可以使用restart命令。它比单独停止和启动容器更快：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker restart my_nginx</span><br></pre></td></tr></table></figure><p>您可以像进程一样终止docker容器。让我们杀掉’my_nginx’容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker kill my_nginx</span><br></pre></td></tr></table></figure><p>再次列出Docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">e7b19b6ad778 nginx &quot;nginx -g &apos;daemon of…&quot; 22 minutes ago Exited (137) 7 seconds ago my_nginx</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 36 minutes ago Up 36 minutes 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>容器my_nginx未运行。此外，您可以在信息中看到您有一个正在运行的容器和一个已停止的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line"></span><br><span class="line">Containers: 2</span><br><span class="line">Running: 1</span><br><span class="line">Paused: 0</span><br><span class="line">Stopped: 1</span><br><span class="line">Images: 3</span><br><span class="line"></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>使用启动或重新启动Docker命令来启动被杀掉的容器。</p><p><strong>Docker exec bash 和Docker SSH 进入容器</strong></p><p>您通常需要与容器的shell进行交互，以创建服务或解决问题。可以使用docker exec命令创建交互式shell。让我们用bash shell从Ubuntu镜像启动一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my_ubuntu -it ubuntu:latest bash</span><br><span class="line"></span><br><span class="line">root@a19c770b8621:/#</span><br></pre></td></tr></table></figure><p>这  root@hash# 意味着您位于Docker容器的bash shell中。您可以运行shell命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@a19c770b8621:/# ls</span><br><span class="line"></span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br><span class="line">root@a19c770b8621:/# pwd</span><br><span class="line"></span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>您可以列出Docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">a19c770b8621 ubuntu:latest &quot;bash&quot; About a minute ago Up About a minute my_ubuntu</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; About an hour ago Up About an hour 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>你可以看到’my_ubuntu’正在运行。假设你想将Docker ssh放入容器’my_ubuntu’中。你可以使用  docker exec   bash方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it my_ubuntu bash</span><br><span class="line"></span><br><span class="line">root@a19c770b8621:/#</span><br></pre></td></tr></table></figure><p><strong>注意，命令提示符的容器ID和bash匹配。因此，您将ssh放入容器“my-ubuntu”的结果是成功的。</strong></p><p>使用docker exec向容器中发出命令。例如，您可以直接从命令提示符在“my_buntu”docker容器上运行ls命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it my_ubuntu ls</span><br><span class="line"></span><br><span class="line">bin dev home lib64 mnt proc run srv tmp var</span><br><span class="line">boot etc lib media opt root sbin sys usr</span><br></pre></td></tr></table></figure><p><strong>连接到正在运行中的容器</strong></p><p>在上面的示例中，您以附加模式启动了Ubuntu容器。相反，您可以在分离模式下启动它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -d --name my_ubuntu_2 ubuntu:latest bash</span><br><span class="line"></span><br><span class="line">75b28b7208359137b3e1dc2843387918e28b4c6c4860ef0cdeac79c205f5cbc4</span><br></pre></td></tr></table></figure><p>验证容器是否正在运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">75b28b720835 ubuntu:latest &quot;bash&quot; 3 minutes ago Up 3 minutes my_ubuntu_2</span><br><span class="line">a19c770b8621 ubuntu:latest &quot;bash&quot; 15 minutes ago Up 15 minutes my_ubuntu</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 2 hours ago Up 2 hours 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>使用该  docker attach 命令获得  docker exec 类似的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach my_ubuntu_2</span><br><span class="line"></span><br><span class="line">root@75b28b720835:/#</span><br></pre></td></tr></table></figure><p><strong>查看镜像的创建历史</strong></p><p>Docker社区构建了docker镜像。这些镜像是分层创建的。您可以使用Docker history命令查看镜像的创建方式。我们先来看看你有什么镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">ubuntu 16.04 5e8b97a2a082 2 weeks ago 114MB</span><br><span class="line">ubuntu latest 113a43faa138 2 weeks ago 81.2MB</span><br><span class="line">nginx latest cd5239a0906a 2 weeks ago 109MB</span><br></pre></td></tr></table></figure><p>让我们来看看’nginx’镜像的历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker history nginx</span><br><span class="line"></span><br><span class="line">IMAGE CREATED CREATED BY SIZE COMMENT</span><br><span class="line">cd5239a0906a 2 weeks ago /bin/sh -c #(nop) CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon… 0B </span><br><span class="line">&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) STOPSIGNAL [SIGTERM] 0B </span><br><span class="line">&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) EXPOSE 80/tcp 0B </span><br><span class="line">&lt;missing&gt; 2 weeks ago /bin/sh -c ln -sf /dev/stdout /var/log/nginx… 22B </span><br><span class="line">&lt;missing&gt; 2 weeks ago /bin/sh -c set -x &amp;&amp; apt-get update &amp;&amp; apt… 53.7MB </span><br><span class="line">&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) ENV NJS_VERSION=1.15.0.0.… 0B </span><br><span class="line">&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.15.0-… 0B </span><br><span class="line">&lt;missing&gt; 7 weeks ago /bin/sh -c #(nop) LABEL maintainer=NGINX Do… 0B </span><br><span class="line">&lt;missing&gt; 8 weeks ago /bin/sh -c #(nop) CMD [&quot;bash&quot;] 0B </span><br><span class="line">&lt;missing&gt; 8 weeks ago /bin/sh -c #(nop) ADD file:ec5be7eec56a74975… 55.3MB</span><br></pre></td></tr></table></figure><p>您可以使用镜像的history命令来了解最近发生了什么变化。如果在从已经使用的新版本镜像启动容器后发现问题，此命令可以帮助您找到原因。或者，也可以使用以下版本的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image history nginx</span><br></pre></td></tr></table></figure><p><strong>获取容器/镜像的元数据</strong></p><p>您可以使用docker inspect命令查找关于您的系统的低级信息。运行docker ps命令列出docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 2 hours ago Up 2 hours 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>让我们使用CONTAINER ID来检查容器（您也可以使用容器名称）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect 6162daed25da</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;Id&quot;: &quot;6162daed25da50b98afca5f7ed8caca2289bf309b2547d87ae8674b899d604a4&quot;,</span><br><span class="line">&quot;Created&quot;: &quot;2018-06-25T05:46:37.902211302Z&quot;,</span><br><span class="line">&quot;Path&quot;: &quot;nginx&quot;,</span><br><span class="line">&quot;Args&quot;: [</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">&quot;DriverOpts&quot;: null</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>该命令将以JSON格式提供大量信息。以下是查找容器IP地址的技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect 6162daed25da | grep &quot;IPAddress&quot;</span><br><span class="line"></span><br><span class="line">&quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">&quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">&quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br></pre></td></tr></table></figure><p><strong>容器与主机之间的数据拷贝</strong></p><p>我们列出Docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 3 hours ago Up 3 hours 0.0.0.0:8080-&gt;80/tcp hardcore_torvalds</span><br></pre></td></tr></table></figure><p>nginx容器在端口8080上运行。所以，如果你访问<a href="http://localhost:8080，你会看到以下内容：" target="_blank" rel="noopener">http://localhost:8080，你会看到以下内容：</a></p><p>“Welcome to nginx！”</p><p>如果您看到此页面，则nginx Web服务器已成功安装并正常运行。需要进一步配置。</p><p>让我们在你的本地目录中创建这个index.html：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;Header&gt;&lt;title&gt;My Website&lt;/title&gt;&lt;/header&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello world</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>让我们使用docker exec -ls命令和查看nginx容器中包含index.html文件的文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it hardcore_torvalds ls /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line">50x.html index.html</span><br></pre></td></tr></table></figure><p>使用您创建的本地文件覆盖容器的index.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp index.html hardcore_torvalds:usr/share/nginx/html/</span><br></pre></td></tr></table></figure><p>现在，如果您再次访问<a href="http://localhost:8080，您应该看到“hello" target="_blank" rel="noopener">http://localhost:8080，您应该看到“hello</a> world”。</p><p>可以使用docker cp命令在主机和创建的容器之间移动文件。</p><p><strong>创建镜像</strong></p><p>假设您要从您创建的“Hello World”容器创建将来的容器。为了制作更多“Hello World”容器，您必须将当前“Hello World”容器保存为镜像。</p><p>首先，停止容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop hardcore_torvalds</span><br></pre></td></tr></table></figure><p>现在列出所有Docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">75b28b720835 ubuntu:latest &quot;bash&quot; About an hour ago Exited (0) About an hour ago my_ubuntu_2</span><br><span class="line">a19c770b8621 ubuntu:latest &quot;bash&quot; 2 hours ago Exited (0) About an hour ago my_ubuntu</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 3 hours ago Exited (0) 27 seconds ago hardcore_torvalds</span><br></pre></td></tr></table></figure><p>从STATUS中，您可以看到’hardcore_torvalds ‘容器已停止。使用该  docker commit命令创建新镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit 6162daed25da nginx_hello_world_template</span><br><span class="line"></span><br><span class="line">sha256:117d060587a316035ed5a776e613d9cfbeee9fbfe202c6edc9203820c7da987b</span><br></pre></td></tr></table></figure><p>现在，如果您查看镜像，您将看到新镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">nginx_hello_world_template latest 117d060587a3 40 seconds ago 109MB</span><br><span class="line">ubuntu 16.04 5e8b97a2a082 2 weeks ago 114MB</span><br><span class="line">ubuntu latest 113a43faa138 2 weeks ago 81.2MB</span><br><span class="line">nginx latest cd5239a0906a 2 weeks ago 109MB</span><br></pre></td></tr></table></figure><p>您可以像使用其他镜像一样使用此镜像并启动新的Docker容器。新创建的容器将具有“Hello world”页面，而不是“Welcome nginx ”页面。使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -d -p 8886:80 nginx_hello_world_template</span><br><span class="line"></span><br><span class="line">4e042d76c39125471951626ba42cd609a65c73f041943298f74f4fc43dc5596a</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p><strong>删除容器与镜像</strong></p><p>Docker容器和镜像会占用硬盘空间，因此需要定期清理。让我们首先停止所有Docker容器，然后列出所有容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">4e042d76c391 nginx_hello_world_template &quot;nginx -g &apos;daemon of…&quot; 2 minutes ago Exited (0) 8 seconds ago boring_keldysh</span><br><span class="line">75b28b720835 ubuntu:latest &quot;bash&quot; 2 hours ago Exited (0) About an hour ago my_ubuntu_2</span><br><span class="line">a19c770b8621 ubuntu:latest &quot;bash&quot; 2 hours ago Exited (0) About an hour ago my_ubuntu</span><br><span class="line">6162daed25da nginx &quot;nginx -g &apos;daemon of…&quot; 3 hours ago Exited (0) 11 minutes ago hardcore_torvalds</span><br></pre></td></tr></table></figure><p>有4个处于停止状态的容器。您可以使用该  docker rm 命令删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm 4e042d76c391 75b28b720835 a19c770b8621 6162daed25da</span><br><span class="line"></span><br><span class="line">4e042d76c391</span><br><span class="line">75b28b720835</span><br><span class="line">a19c770b8621</span><br><span class="line">6162daed25da</span><br></pre></td></tr></table></figure><p>除了容器ID之外，还可以使用名称。现在列出容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br></pre></td></tr></table></figure><p>我们列出Docker镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">nginx_hello_world_template latest 117d060587a3 11 minutes ago 109MB</span><br><span class="line">ubuntu 16.04 5e8b97a2a082 2 weeks ago 114MB</span><br><span class="line">ubuntu latest 113a43faa138 2 weeks ago 81.2MB</span><br><span class="line">nginx latest cd5239a0906a 2 weeks ago 109MB</span><br></pre></td></tr></table></figure><p>您可以用docker rmi 命令和image ID 删除docker镜像 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 117d060587a3 5e8b97a2a082 113a43faa138 cd5239a0906a</span><br></pre></td></tr></table></figure><p>现在查看docker镜像列表，应该是空的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br></pre></td></tr></table></figure><p>希望这个文章能让您熟练掌握Docker命令，并在工作中能够对您有所帮助！只要你我都用心去奋斗，去努力，美好的未来在等着我们！</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极简机器学习概念入门指南</title>
      <link href="/2019/08/18/%E6%9E%81%E7%AE%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/08/18/%E6%9E%81%E7%AE%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="极简机器学习基础概念入门指南"><a href="#极简机器学习基础概念入门指南" class="headerlink" title="极简机器学习基础概念入门指南"></a>极简机器学习基础概念入门指南</h1><h2 id="机器学习背后的术语可能听起来很复杂，但概念非常直观"><a href="#机器学习背后的术语可能听起来很复杂，但概念非常直观" class="headerlink" title="机器学习背后的术语可能听起来很复杂，但概念非常直观"></a>机器学习背后的术语可能听起来很复杂，但概念非常直观</h2><p>近几年，像“机器学习( Machine Learning )”，“深度学习( Deep Learning )”，“神经网络( Neural Network )”，“人工智能( Artificial Intelligence )”或“人工智能( A.I )”，“数据科学( Data Science )”等词语在科技界已成为流行术语。由于计算能力提高和可用数据量增加，现在可以将已知数十年的科学技术应用到实践中来。</p><p>但是这些术语究竟是什么意思？</p><p>一张图来说明</p><p> <img src="https://img.vim-cn.com/25/579326711bb7e805b26a1a2935ca8479d8dee4.jpg" alt="机器学习关系"></p><p><strong>数学公式让机器拥有像人类一样基本的理解能力</strong></p><p>我们大多数人都可以意识到 1 万多行的解释说明“全部是为了教电脑去帮助我们解决问题” ，但许多人可能不知道实际发生了什么。机器学习的基础知识非常简单，足够直观，而且更重要的是，足够有趣，让每个人在相对较短的时间内理解它。</p><p>下面我们将简单介绍如何使用机器学习来教电脑解决问题，是为了针对那些不了解机器学习的人或那些想要从头开始的人。</p><h2 id="最佳拟合线-The-Line-of-Best-Fit"><a href="#最佳拟合线-The-Line-of-Best-Fit" class="headerlink" title="最佳拟合线 (The Line of Best Fit)"></a>最佳拟合线 (The Line of Best Fit)</h2><p>我们中的许多人可能会记得来自学校的一些东西，称为“<strong>最佳拟合线</strong>”，参考绘制在图表上的数据点。最佳拟合线是一条通过这些点的线，它用来表示数据表达的内容。它可能看起来像这样：</p><p><img src="https://img.vim-cn.com/61/e3c66e557fd5aeabd0001b92404ae64d2802fc.png" alt="img"></p><p>这个概念实际上是最基本的机器学习。我们可以将数据提供给计算机，而不是自己绘制这些点并尝试绘制出最佳拟合线。</p><p>例如，可以想象上图中显示的数据是一些人的鞋子尺寸和身高。左下角的点表示这个人的身高比其他人矮并且鞋子尺寸比其他人小，右上角的点表示这个人较高且脚较大。因为鞋子的尺寸和高度并不是完全相关，所以不是所有的点都符合“较高的人有较大的脚”的说法，但最适合的线条表明它在一般情况下是正确的。</p><p>通过最佳拟合线，我们可以对新数据做出有根据的猜测。假设你找到了一双鞋子。您可以确定它的大小，然后参考相关图表，对鞋子主人的身高做出有相关的猜测：</p><p><img src="https://img.vim-cn.com/02/8444d4d63cf9b18a5abaf0b84bbe7d94c3d12d.png" alt="img"></p><p>简单吧？在机器学习中，这被称为“<strong>线性回归</strong>”，不要让名字吓到你。如果你了解上述所有内容，那么就会理解线性回归。这是一种简单的机器学习技术，用于帮助对具有线性关系的数据进行预测。</p><p>机器学习的线性回归过程如下：</p><ol><li>收集数据；</li><li>将数据导入进程序，用线性回归分析这些数据并画出最佳拟合线；</li><li>使用最佳拟合线来预测新数据。</li></ol><p>这些被称为“机器学习”，因为计算机（或机器）已经学习了（或创建了一个数学公式，在这种情况下，是一条线）怎样联系鞋子的尺寸和身高的关系。数学方程使机器基本理解了我们作为人类学到的东西：一般来说，较高的人有较大的脚。</p><p>在其他情况下，你可以根据房子的房间数并用线性回归来猜测房屋的成本，或根据他们在圣诞树下有多少礼物来猜测孩子有多少阿姨和叔叔。</p><h2 id="线性回归问题"><a href="#线性回归问题" class="headerlink" title="线性回归问题"></a>线性回归问题</h2><p>当数据成线性关系时，线性回归效果显著，如以上例子。但它处理看起来不成线性关系的数据效果会怎么样？也许数据看起来像这样：</p><p><img src="https://img.vim-cn.com/99/261e5aa8d90be3a880ad9ac3ee563ea2c48cdf.png" alt="img"></p><p>添加最佳拟合线，效果图如下：</p><p><img src="https://img.vim-cn.com/a0/452a7ef415d694f4e136411ca5da4dae2d728c.png" alt="img"></p><p>最佳拟合线匹配数据效果还可以接受，但似乎它可以做得更好。因为数据的形状不是一条直线，因此绘制的最佳拟合线不适合数据。这是机器学习中的一个问题，称为“<strong>欠拟合</strong>”：最佳拟合线并不能很好地拟合数据。但是如果我们弯曲最佳拟合线，它可能会做得更好。</p><p><img src="https://img.vim-cn.com/3d/60ed23118a748cc8d072c9d56a9acb6cf09058.png" alt="img"></p><p>我们可以轻松利用曲线使数据拟合更准确，上图方法就像我们用直线的最佳拟合一样。这是一个简单的线性回归扩展，称为“<strong>多项式回归”</strong>。再次，不要让名字吓到你。如果你理解为什么曲线拟图时比直线更有准确，那么你就能理解多项式回归是如何有用。</p><p>现在我们可以创建一个模型，即：对于具有直线或曲线形状的数据，找到一组数据的最佳拟合线或曲线。这些内容上面已经介绍了，对吧？但并未结束，我们可以在这些概念之上进行拓展。</p><h2 id="选择模型的准确度"><a href="#选择模型的准确度" class="headerlink" title="选择模型的准确度"></a>选择模型的准确度</h2><p>多项式回归的问题是我们必须在使用它之前决定给它的次数（幂的次数），这可能很棘手。让我们回到我们的第一组数据：</p><p><img src="https://img.vim-cn.com/32/b07642e929e1fdbea64175afbcbd1c6978ae2a.png" alt="img"></p><p>我们以前使用线性回归在这些数据点之间画一条直线。但相反，我们可以使用多项式回归将最佳拟合曲线放在数据点之间，效果有可能比线性回归显著。它可能看起来像这样：</p><p><img src="https://img.vim-cn.com/03/6b4bd5cbea2461c25561ad426c0a2cc2489940.png" alt="img"><br>关于多项式回归，我们可以设定最佳拟合曲线的准确度。次数越高，它在描述数据集时就越灵活。上面最合适的曲线非常简单，但可以进一步拟合数据，如下所示：</p><p><img src="https://img.vim-cn.com/4d/aa0108a653f1fc46dea91a1f5df21aeb4a94a4.png" alt="img"></p><p>或者如下图拟合数据：</p><p><img src="https://img.vim-cn.com/55/43b53b272cb2e1bb5396d5164f054ab93c6c84.png" alt="img"></p><p>上面的最合适曲线似乎越来越准确地描述数据，但有些东西有点感觉不对，特别是在最后一个例子中。最佳拟合曲线的灵活度越高，它就很难把一些数据点连接起来。结果是一条曲线对于预测而言似乎不如最佳拟合直线。</p><p>我们再次回到鞋子尺寸和高度例子中，我们可以看到两个不同鞋尺寸的人在最佳拟合曲线中有着相同的身高：</p><p><img src="https://img.vim-cn.com/75/e2db242349311858278e7220c5e5a9c4b9c4c4.png" alt="img"></p><p>机器学习中的这个问题被称为“<strong>过度拟合</strong>”，与欠拟合相反。这意味着我们创建的最合适的曲线并不能很好的代表整个数据概况。它在连接数据点上面做的不错，但它无法于对任何新数据做出准确的预测。机器学习的主要问题之一是找到最合适的线条或曲线，其曲率足以模仿数据的一般规律形状，但不是那么弯曲，以至于无法对新数据进行良好预测。</p><p>这是多项式回归容易出现的问题。在拟合数据之前我们必须明确多项式回归使拟合曲线的弯曲程度，这不是一件容易的事情，尤其是当数据更复杂时。</p><p>在到目前为止的示例中，我们的数据只有两个维度 - 例如鞋子尺寸和身高 - 这意味着我们已经能够在二维图上表达我们的数据。二维图很容易看到数据的一般形状。但是，在具有两个以上维度的机器学习问题中通常不会出现这种情况。如果我们不知道数据的形状是什么，我们就不能准确的确认多项式回归曲线的次数去制作最合适的线条。</p><p><strong>进一步挖掘，神经网络也可用于回答关于数据的是与否问题而不是返回数字。</strong></p><p>一种选择是多次尝试多项式回归不同的幂次数据，并观察哪个次数效果最好。但我们真正需要的是机器学习既可以满足线性拟合的灵活性，同时也限制它的曲率，以便能够更好地应用于新数据。</p><p>研究人员通常通过从线性和多项式回归转向使用神经网络来解决曲线灵活性问题 。就其本身而言，神经网络非常类似于多项式回归，因为它能够学习具有非常弯曲形状的数据。它们并没有解决自身产生的过度拟合的问题，但当与一种称为正则化的技术相结合时，一切都趋于成功。</p><p>神经网络和正则化使用细节对于理解机器学习的基础知识并不是非常重要。需要记住的关键事项是，神经网络非常擅长学习复杂数据集的形状 - 比线性或多项式回归更有效 - 和正则化有助于防止神经网络过度拟合数据。</p><h2 id="让电脑回答问题"><a href="#让电脑回答问题" class="headerlink" title="让电脑回答问题"></a>让电脑回答问题</h2><p>对于迄今为止所涉及的技术 - 线性回归，多项式回归和神经网络 - 我们只研究了如何根据我们提供的数据训练计算机给我们一个数字。鞋子尺寸和身高模型可以告诉我们相应的身高数据根据我们输入的鞋子尺寸。类似地，根据房间数量的房价模型，我们可以知道房子价格当我们给出了房间数。</p><p>但是数字输出并不总是我们想要的。有时我们想要机器学习模型来回答问题。例如，如果你想卖房子，你可能不会只关心机器学习计算出你房子的价值，但你可能还想知道房子是否会在六周内售出。</p><p>好消息是许多机器学习技术可以解决回答特定问题而不是给出数字的问题 ，类似于我们已经介绍的技术 。当我们提供一些基本输入数据（如房间数量，成本和平方英尺）时，可以设置机器学习模型以给出六周内销售问题的是/否答案。显然，它永远不会是一个完美的模型，因为住房市场不遵循确切的规则，但机器学习模型可以给出这些类型问题很精确的答案（取决于数据的质量）。</p><p>对于线性回归，所涉及的是线性形式的逻回归。（同样，不要让术语使你害怕。基本方法实际上非常直观。）它可以回答诸如“这封垃圾邮件是垃圾吗？”或“明天会下雨吗？”。两种方法 - 线性和逻辑回归 - 会计算一条最佳拟合线，但它们在使用该线时的方式不同。提醒一下，这里我们使用线性回归模型是为了预测其它的数据：</p><p><img src="https://img.vim-cn.com/02/8444d4d63cf9b18a5abaf0b84bbe7d94c3d12d.png" alt="img"></p><p>逻辑回归与之前的方法有些类似，不同的是找到了一条最佳拟合线的同时也将数据分成两组。然后，该线可用于预测新数据点是位于这个组还是另一个组中，具体取决于它所在线的哪一侧。</p><p><img src="https://img.vim-cn.com/60/e3037c53a0cffba0aacbb60c8cc50fa1d8ac0f.png" alt="img"></p><p>像线性回归一样，逻辑回归可以扩展为使用弯曲的多项式模型，该模型在拟合数据形状方面具有更大的灵活性。通过一点额外的扩展，神经网络也可用于回答关于数据的是/否问题而不是返回数字。</p><p>如果我们想要回答比寻找是/否更复杂的问题，我们可以使用多项逻辑回归，或者我们也可以调整神经网络以便能够处理这些情况。以这种方式创建的模型将能够回答诸如“明天会下雨，晴天还是下雪？”这样的问题。“多项”部分只是意味着答案可以是众多选项之一。在该示例中，三个可能的答案将是下雨，晴天或下雪。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多距离空间聚类分析（Ripley&#39;s K 函数）的工作原理</title>
      <link href="/2019/07/26/%C2%96%E5%A4%9A%E8%B7%9D%E7%A6%BB%E7%A9%BA%E9%97%B4%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%EF%BC%88Ripley-s-K-%E5%87%BD%E6%95%B0%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2019/07/26/%C2%96%E5%A4%9A%E8%B7%9D%E7%A6%BB%E7%A9%BA%E9%97%B4%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%EF%BC%88Ripley-s-K-%E5%87%BD%E6%95%B0%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>基于 Ripley’s K 函数的<a href="https://pro.arcgis.com/zh-cn/pro-app/tool-reference/spatial-statistics/multi-distance-spatial-cluster-analysis.htm" target="_blank" rel="noopener">多距离空间聚类分析</a>工具是另外一种分析事件点数据的空间模式的方法。该方法不同于此工具集中其他方法（<a href="https://pro.arcgis.com/zh-cn/pro-app/tool-reference/spatial-statistics/spatial-autocorrelation.htm" target="_blank" rel="noopener">空间自相关</a>和<a href="https://pro.arcgis.com/zh-cn/pro-app/tool-reference/spatial-statistics/hot-spot-analysis.htm" target="_blank" rel="noopener">热点分析</a>）的特征是可对一定距离范围内的空间相关性（要素聚类或要素扩散）进行汇总。在许多要素模式分析研究中，都需要选择适当的分析比例。例如，该分析通常需要<strong>距离范围或距离阈值</strong>。在多个距离和空间比例下研究空间模式时，模式会发生变化，而这通常可反映对运行中的特定空间过程的控制。Ripley’s K 函数可表明要素质心的空间聚集或空间扩散在邻域大小发生变化时是如何变化的。</p><p>使用此工具时，需要指定要计算的距离个数，同时也可选择指定起始距离和/或距离增量。该工具可利用此信息计算与每个要素关联的相邻要素的平均数量；相邻要素是指小于计算距离的要素。随着计算距离的增大，各要素所具有的相邻要素数通常会越多。如果某个特定计算距离的平均相邻要素数高于/大于整个研究区域内要素的平均密度，该距离的分布方式将被视为聚类分布。</p><p>如果有兴趣研究要素的聚类/扩散如何相对于不同距离（不同的分析规模）进行变化，您可以使用此工具。</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>推荐使用 Ripley’s 原始 K 函数的多种变体。下面执行的是 K 函数的一种常见变换，通常称为 L(d)：</p><p><img src="https://pro.arcgis.com/zh-cn/pro-app/tool-reference/spatial-statistics/GUID-80D47D05-03E2-4130-B0F7-4C3A87DFAC42-web.png" alt="K 函数变换方程">在 L(d) 变换下，“预期值”K 等于“距离”</p><p><strong>开始距离</strong>和<strong>距离增量</strong>默认值的计算方法如下：</p><ul><li>我们始终知道<strong>距离范围数量</strong>（默认值是 10）。我们将使用此迭代值来计算默认的<strong>距离增量</strong>（如未提供）。</li><li>我们最初将最大距离值计算为输入要素周围最小外接矩形的最大范围长度的 25％。如果<strong>边界校正方法</strong>为<strong>缩小分析区域</strong>，则系统会将最大距离设置为最小外接矩形的最大范围长度的 25％ 或最小范围长度的 50％ 这两者中较大的一个。</li><li>如果提供了<strong>开始距离</strong>，则<strong>距离增量</strong>为（最大距离 - 开始距离）/ 迭代。</li><li>如果未提供<strong>开始距离</strong>，则<strong>距离增量</strong>为最大距离 / 迭代，且<strong>开始距离</strong>将设置为距离增量值。</li></ul><h2 id="解释未加权-K-函数结果"><a href="#解释未加权-K-函数结果" class="headerlink" title="解释未加权 K 函数结果"></a>解释未加权 K 函数结果</h2><p>如果特定距离的 K 观测值大于 K 预期值，则与该距离（分析尺度）的随机分布相比，该分布的聚类程度更高。如果 K 观测值小于 K 预期值，则与该距离的随机分布相比，该分布的离散程度更高。如果 K 观测值大于置信区间上限 (HiConfEnv) 值，则该距离的空间聚类具有统计显著性。如果 K 观测值小于置信区间下限 (LwConfEnv) 值，则该距离的空间离散具有统计显著性。</p><p>如果未指定<strong>权重字段</strong>，可通过在研究区域中随机分布点并计算该分布的 k 值来构建置信区间。点的每个随机分布称为一个“排列”。例如，如果选择了 <strong>99 次排列</strong>，则在每次迭代时，该工具均会将一组点随机分布 99 次。 将这些点分布 99 次之后，该工具会对每个距离选择相对“预期”k 值向上和向下偏离最大的 k 值；这些值将成为置信区间。置信区间往往会遵循（具有相同形状和位置）未加权 K 的蓝色“预期”K 线。</p><p><img src="https://pro.arcgis.com/zh-cn/pro-app/tool-reference/spatial-statistics/GUID-110520A9-402D-4C17-8486-A7EC0F827D83-web.png" alt="解释 K 函数结果"></p><h2 id="解释加权-K-函数结果"><a href="#解释加权-K-函数结果" class="headerlink" title="解释加权 K 函数结果"></a>解释加权 K 函数结果</h2><p>即使提供了<strong>权重字段</strong>，K 函数也始终会计算与完全空间随机性 (CSR) 相关的要素空间分布。可将权重考虑为表示每个要素位置处的重叠要素数量。例如，可将权重为 3 的要素视为具有 3 个重叠要素。然而存在一个不同点：一个要素不能成为其自身的相邻要素。因此，与由具有权重为 3 的单个点（要素不作为其自身的相邻要素）的数据集所获得的结果相比，由具有 3 个权重为 1 的单个重合点（所有点均可互为相邻点）的数据集所获得的结果不同。与没有权重字段的结果相比，加权 K 函数结果将始终具有较高的聚类程度。要获得单独指示聚类与要素位置关联程度的基线，对不具有权重的点执行 K 函数会非常有用。然后您便可以将基线与加权结果进行比较，以了解考虑权重时会增加多少额外的聚类或扩散。加权 K 函数显示了超过和高于（少于和低于）可以从未加权模式所获的聚类（扩散）。实际上，除了 CSR 外，还可以使用未加权 K 函数的结果来表示预期模式（使用其自身的置信区间）。这种情况下有两种可能的零假设：</p><ol><li>在聚类（扩散）程度上，加权要素的模式并不会明显高于这些要素的基础模式。如果观测到的加权结果位于未加权结果置信区间之外，则拒绝零假设。</li><li>在聚类（扩散）程度上，加权点的模式比随机获得的模式更高。如果观测到的未加权结果位于加权 K 函数结果的置信区间之内，则拒绝零假设。</li></ol><p>指定了<strong>权重字段</strong>时，仅会对权重值进行随机重新分配来计算置信区间；点位置则保持固定。其实，指定<strong>权重字段</strong>时，位置会保持固定，并且该工具会评估空间中要素值的聚类。由于结果由要素的固定位置稳固构建，因此对于加权 K 分析来说，置信区间往往会遵循/镜像红色观测 K 线。</p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>Bailey, T. C., and A. C. Gatrell. <em>Interactive Spatial Data Analysis</em>. Longman Scientific &amp; Technical, Harlow, U.K. 395 pp. 1995.</p><p>Boots, B., and A. Getis. <em>Point Pattern Analysis</em>. Sage University Paper Series on Quantitative Applications in the Social Sciences, series no. 07–001. Sage Publications. 1988.</p><p>Getis, A. Interactive Modeling Using Second-Order Analysis. <em>Environment and Planning A</em>, 16: 173–183. 1984.</p><p>Mitchell, Andy. <em>The ESRI Guide to GIS Analysis,</em> Volume 2. ESRI Press, 2005.</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多距离空间聚类分析 </tag>
            
            <tag> 雷普利的K函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数-行列式</title>
      <link href="/2019/07/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
      <url>/2019/07/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一、行列式的概念"><a href="#一、行列式的概念" class="headerlink" title="一、行列式的概念"></a>一、行列式的概念</h3><pre><code>行列式是一个数，它是不同行不同列元素乘积的代数和例如，大家所熟悉的三阶行列式</code></pre><p>$$<br>\left|\begin{array}{lll}{a_{1}} &amp; {a_{2}} &amp; {a_{3}} \ {b_{1}} &amp; {b_{2}} &amp; {b_{3}} \ {c_{1}} &amp; {c_{2}} &amp; {c_{3}}\end{array}\right|=a_{1} b_{2} c_{3}+a_{2} b_{3} c_{1}+a_{3} b_{1} c_{2}-a_{3} b_{2} c_{1}-a_{2} b_{1} c_{3}-a_{1} b_{3} c_{2}<br>$$</p><p>​    <strong>n阶行列式</strong><br>$$<br>\left|\begin{array}{cccc}{a_{11}} &amp; {a_{12}} &amp; {\cdots} &amp; {a_{1 n}} \ {a_{21}} &amp; {a_{22}} &amp; {\cdots} &amp; {a_{2 n}} \ {\vdots} &amp; {\vdots} &amp; {} &amp; {\vdots} \ {a_{n 1}} &amp; {a_{n 2}} &amp; {\cdots} &amp; {a_{m}}\end{array}\right|<br>$$<br>     是所有取自不同行不同列的n个元素的乘积<br>$$<br>a_{1 j_{1}} a_{2 j_{2}} \cdots a_{n j_{n}}<br>$$<br>     的代数和，这里 $$<br>j_{1} j_{2} \cdots j_{n}<br>​$$ 是 $$<br>1,2, \cdots, n<br>​$$ 的一个排列.当 $$<br>j_{1} j_{2} \cdots j_{n}<br>​$$ 是偶排列时，该项的前面带正<br>     号;当 $$<br>j_{1} j_{2} \cdots j_{n}<br>​$$ 是奇排列时，该项的前面带负号，即<br>$$<br>\left|\begin{array}{cccc}{a_{11}} &amp; {a_{12}} &amp; {\cdots} &amp; {a_{1 n}} \ {a_{21}} &amp; {a_{22}} &amp; {\cdots} &amp; {a_{2 n}} \ {\vdots} &amp; {\vdots} &amp; {} &amp; {\vdots} \ {a_{n 1}} &amp; {a_{n 2}} &amp; {\cdots} &amp; {a_{m}}\end{array}\right|=\sum_{j_{1} j_{2} \cdots j_{n}}(-1)^{r\left(j_{1} j_{2} \cdots j_{n}\right)} a_{1 j_{1}} a_{2 j_{2}} \cdots a_{n j_{n}}<br>$$<br>     这里 $$<br>\sum_{i_{1} j_{2} \cdots j_{n}}<br>$$表示对所有n阶排列求和. 上式称为n阶行列式的完全展开式.</p><h3 id="二、行列式的性质"><a href="#二、行列式的性质" class="headerlink" title="二、行列式的性质"></a>二、行列式的性质</h3><pre><code>记 $$</code></pre><p>|\boldsymbol{A}|=\left|\begin{array}{cccc}{a_{11}} &amp; {a_{12}} &amp; {\cdots} &amp; {a_{1 n}} \ {a_{21}} &amp; {a_{22}} &amp; {\cdots} &amp; {a_{2 n}} \ {\vdots} &amp; {\vdots} &amp; {} &amp; {\vdots} \ {a_{n 1}} &amp; {a_{n 2}} &amp; {\cdots} &amp; {a_{m}}\end{array}\right|,\left|\boldsymbol{A}^{\mathrm{T}}\right|=\left|\begin{array}{cccc}{a_{11}} &amp; {a_{21}} &amp; {\cdots} &amp; {a_{n 1}} \ {a_{12}} &amp; {a_{22}} &amp; {\cdots} &amp; {a_{n 2}} \ {\vdots} &amp; {\vdots} &amp; {} &amp; {\vdots} \ {a_{1 n}} &amp; {a_{2 n}} &amp; {\cdots} &amp; {a_{m}}\end{array}\right|<br>$$ </p><pre><code>行列式 $$</code></pre><p>\left|A^{\mathrm{T}}\right|<br>$$ 称为 $$<br>|A|<br>$$ 的转置行列式</p>]]></content>
      
      
      <categories>
          
          <category> 线代 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见地图投影</title>
      <link href="/2019/07/06/%E5%B8%B8%E8%A7%81%E5%9C%B0%E5%9B%BE%E6%8A%95%E5%BD%B1/"/>
      <url>/2019/07/06/%E5%B8%B8%E8%A7%81%E5%9C%B0%E5%9B%BE%E6%8A%95%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="按投影变形性质分类"><a href="#按投影变形性质分类" class="headerlink" title="按投影变形性质分类"></a>按投影变形性质分类</h3><p><strong>等角投影(Conformality，Conformal Projection)</strong><br>    投影面上某点的任意两方向线夹角与地球椭球体面 上相应的夹角相等的投影,也称为正形投影     (Orthomorphic)。<br>    投影时，调整经线上的长度变形比m与纬线上的长度 变形比n相等，即m=n。</p><pre><code>等角投影:投影后圆形保持形状不变，但在不同位置上面积差异很大。</code></pre><p><strong>等积投影 ( Equivalence, Equal-area Projection, Equivalent Projection )</strong><br>        投影面上任意图形面积与地球椭球体面上相应的图形面积相等的投影。<br>        投影时，调整经线长度，使得m x n = 1，从而保持 面积不变。</p><pre><code>等积投影:不同位置的变 形椭圆形状差异很大，但面积大小近似相等。</code></pre><p><strong>任意投影</strong><br>    除等角、等积投影外的所有投影，它同时存在角度、面积、以及长度变形。<br>    较常见的是等距投影(Equidistance, Equidistant Projection), 等距投影并不是不存在长度变    形，只是保持变形椭圆一个主方向长度比为1(a=1或b=1)。</p><pre><code>任意投影: 椭圆的形状 与大小都有 着不同的变 化，但可以 保持纵轴长 度不变</code></pre><h3 id="投影方法选择"><a href="#投影方法选择" class="headerlink" title="投影方法选择"></a>投影方法选择</h3><p>一般原则<br>     传统方法:<br>         极地地区，用方位投影<br>         中纬度地区，用锥面投影<br>         近赤道处，用柱面投影<br>     兼顾考虑实际应用的需求:<br>         成图的代表性<br>         各类数据的通用性<br>         定量数据的精度要求</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用Python做地图投影</title>
      <link href="/2019/06/30/%E7%94%A8Python%E5%81%9A%E5%9C%B0%E5%9B%BE%E6%8A%95%E5%BD%B1/"/>
      <url>/2019/06/30/%E7%94%A8Python%E5%81%9A%E5%9C%B0%E5%9B%BE%E6%8A%95%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是地图投影"><a href="#什么是地图投影" class="headerlink" title="什么是地图投影"></a>什么是地图投影</h3><p>地图投影是利用一定数学法则把地球表面的经、纬线转换到平面上的理论和方法。</p><p>由于地球是一个赤道略宽两极略扁的不规则的梨形球体，故其表面是一个不可展平的曲面，所以运用任何<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/1747958" target="_blank" rel="noopener">数学方法</a>进行这种转换都会产生误差和变形，为按照不同的需求缩小误差，就产生了各种投影方式。</p><p>比如这篇很有意思的文章<a href="http://blog.csdn.net/kikitamoon/article/details/50634331" target="_blank" rel="noopener">你所不知的有趣投影方法</a>。</p><h3 id="为什么要进行地图投影"><a href="#为什么要进行地图投影" class="headerlink" title="为什么要进行地图投影"></a>为什么要进行地图投影</h3><ol><li>地理坐标为球面坐标, 不方便进行距离, 方位, 面积等参数的量算.</li><li>地球椭球体为不可展曲面.</li><li>地图为平面, 符合视觉心理,并进行距离, 方位, 面积等量算和各种空间分析.</li></ol><p><img src="https://img.vim-cn.com/e1/4408a6608880aa9a6a83d5ba46fa96c8e3c842.jpg" alt="youtube - Adventures with GIS: an introduction to IPython and the joy of play"></p><h3 id="常用的投影方法"><a href="#常用的投影方法" class="headerlink" title="常用的投影方法"></a>常用的投影方法</h3><p>​    <strong>1、几何透视法：</strong>几何透视法是利用透视的关系，将地球体面上的点投影到投影面上的一种投影方法。如假设地球按比例缩小成一个透明的地球仪般的球体，在其球心或球面、球外安置一个光源，将球面上的经纬线投影到球外的一个投影平面上，即将球面经纬线转换成了平面上的经纬线。</p><p>​    <strong>2、数学解析法：</strong>数学解析法是在球面与投影面之间建立点与点的函数关系，通过数学的方法确定经纬线交点位置的一种投影方法。</p><p>几何透视法是一种比较原始的投影方法，有很大的局限性，难于纠正投影变形，精度较低，当前绝大多数地图投影都采用数学解析法。大多数的数学解析法往往是在透视投影的基础上，发展建立球面与投影面之间点与点的函数关系的，因此两种投影方法有一定联系。</p><h3 id="地图投影主要分为3个过程"><a href="#地图投影主要分为3个过程" class="headerlink" title="地图投影主要分为3个过程"></a>地图投影主要分为3个过程</h3><p>​    <strong>1.</strong> 确定地球椭球体（Spheroid/Ellipsoid），需要长半轴、短半轴、曲率三个参数。（模拟地球的<strong>形状</strong>）</p><p>​    <strong>2.</strong> 若要逼近某特定地区，则需要大地基准（Geodetic Datum）。（椭球体的<strong>原点</strong>the position of the origin<strong>、方向</strong> the orientation<strong>、缩放比例</strong> the scale等）我国现在采取西安1980坐标系基准点，同时也有国家1985高程基准。</p><p>​    <strong>3.</strong> 关于如何投影，这就涉及高斯-克吕格投影等诸多投影方式的存在，等角等积等距离，方位圆柱圆锥等分类。</p><p>由于世界各地区投影类型的不同，因此在叠加、复合不同来源空间数据时，必需首先进行投影转换、配准等设置。</p><h3 id="EPSG-Code"><a href="#EPSG-Code" class="headerlink" title="EPSG Code"></a>EPSG Code</h3><p>如果经常跟地图打交道，你一定会被各种<em>花式</em>投影变换弄的眼花缭乱。<a href="http://www.epsg.org/" target="_blank" rel="noopener">EPSG</a>：<a href="http://en.wikipedia.org/wiki/EPSG" target="_blank" rel="noopener">European Petroleum Survey Group (EPSG)</a>成立于1986年，并在2005年重组为OGP(Internation Association of Oil &amp; Gas Producers)，它负责维护并发布坐标参照系统的数据集参数，以及坐标转换描述，该数据集被广泛接受并使用，通过一个Web发布平台进行分发，同时提供了微软Acess数据库的存储文件，通过SQL 脚本文件，MySQL, Oracle 和PostgreSQL等数据库也可使用。目前已有的椭球体，投影坐标系等不同组合都对应着不同的ID号，这个号在EPSG中被称为EPSG code，它代表特定的椭球体、单位、地理坐标系或投影坐标系等信息。</p><p>开源的QGIS软件中就直接采用了EPSG。</p><blockquote><p>The CRSs available in QGIS are based on those defined by the European Petroleum Search Group (EPSG) and the Institut Geographique National de France (IGNF) and are largely abstracted from the spatial reference tables used in GDAL. EPSG identifiers are present in the database and can be used to specify a CRS in QGIS.</p></blockquote><p>一个查询EPSG code的网站 <a href="https://epsg.io/" target="_blank" rel="noopener">epsg.io</a></p><h3 id="pyproj小试牛刀"><a href="#pyproj小试牛刀" class="headerlink" title="pyproj小试牛刀"></a>pyproj小试牛刀</h3><p>pyproj是PROJ4的python接口封装，直接看一个官网的例子吧。直接利用epsg code来定义投影参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pyproj import Proj,transform</span><br><span class="line"></span><br><span class="line"># The Proj class can convert from geographic (longitude,latitude)</span><br><span class="line"># to native map projection (x,y) coordinates and vice versa, </span><br><span class="line"># or from one map projection coordinate system directly to another.</span><br><span class="line"></span><br><span class="line">p1 = Proj(init=&apos;epsg:26915&apos;)</span><br><span class="line">p2 = Proj(init=&apos;epsg:26715&apos;)</span><br><span class="line">x1, y1 = p1(-92.199881,38.56694)</span><br><span class="line">x2, y2 = transform(p1,p2,x1,y1)</span><br><span class="line">print &apos;%9.3f %11.3f&apos; % (x1,y1)</span><br><span class="line">print &apos;%9.3f %11.3f&apos; % (x2,y2)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">569704.566 4269024.671</span><br><span class="line">569722.342 4268814.027</span><br></pre></td></tr></table></figure><h3 id="基于geopandas的矢量地图投影"><a href="#基于geopandas的矢量地图投影" class="headerlink" title="基于geopandas的矢量地图投影"></a>基于geopandas的矢量地图投影</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import shapely, geopandas, fiona</span><br><span class="line">import seaborn as sns</span><br><span class="line">from fiona.crs import from_epsg,from_string</span><br><span class="line"></span><br><span class="line"># Data</span><br><span class="line">shp = &apos;E:\NationalGISdata\Province.shp&apos;</span><br><span class="line"></span><br><span class="line">shp_df = geopandas.GeoDataFrame.from_file(shp)</span><br><span class="line"># #IndexError报错的话，用arcgis将shapefile文件重新导出一遍试试</span><br><span class="line">shp_df.head()</span><br></pre></td></tr></table></figure><p><img src="https://img.vim-cn.com/82/e74d03f558ef92eb5a1657f484b213bb4bfb62.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据当前的兰伯特投影绘制</span><br><span class="line">shp_df.plot(column=&quot;GDP_1994&quot;,colormap=&apos;Set1&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://img.vim-cn.com/83/dffa24b070f4943b818fccee376ed16276c59e.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 转换到经纬度坐标</span><br><span class="line">shp_df_wgs84 = shp_df.to_crs(from_epsg(4326))</span><br><span class="line">shp_df_wgs84.plot(column=&quot;GDP_1994&quot;,colormap=&apos;Set1&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://img.vim-cn.com/aa/ca292494ce4e977645913d7a501bab782e69af.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 国家2000坐标系</span><br><span class="line"># EPSG:4508  CGCS2000 / Gauss-Kruger CM 111E</span><br><span class="line">shp_df_4508 = shp_df.to_crs(from_epsg(4508))</span><br><span class="line">shp_df_4508.plot(column=&quot;GDP_1994&quot;,colormap=&apos;Set1&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://img.vim-cn.com/d5/f4c5f433d57ded4cca99b721333b8e5437fce1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 除了直接用ESPG code，也可以自己定义投影参数</span><br><span class="line"></span><br><span class="line">ESRI_54024 = &quot;&quot;&quot;</span><br><span class="line">+proj=bonne +lon_0=0 +lat_1=60 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs </span><br><span class="line"></span><br><span class="line">shp_df_3408 = shp_df.to_crs(from_string(ESRI_54024))</span><br><span class="line">shp_df_3408.plot(column=&quot;GDP_1994&quot;,colormap=&apos;Set1&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://img.vim-cn.com/13/8c62e9da0ce8d7852be2ccb876873ee3b5b91a.jpg" alt="img"></p><p>更多图示:</p><p><img src="https://img.vim-cn.com/74/3a0ac1988906c99aa2d4db06c91366a03848c5.jpg" alt></p><p>(文章参考资料:微信公众号<strong>stdrei</strong>)</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图投影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章:绪论</title>
      <link href="/2019/06/30/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
      <url>/2019/06/30/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="重要概念和术语"><a href="#重要概念和术语" class="headerlink" title="重要概念和术语"></a><center>重要概念和术语</center></h3><p><strong>数据探查</strong>(Data eporatin): 以数据为中心的查询和分析。</p><p><strong>动态分段</strong>(Dynamic segmentation): 一种数据模型， 可在坐标系统上使用线段量测的数据。</p><p><strong>地理信息系统</strong>(GIS): 用于采集、存储、查询、分析和显示地理空间数据的计算机系统。 </p><p><strong>地理相关数据模型</strong>(Georelational data mode): 一种矢量数据模型，用分离的系统分别存储空间数据和属性数据。</p><p><strong>地理空间数据</strong>(Gespatial data):  描述地球表面空间要素的位置和特征的数据。</p><p><strong>基于对象的数据模型</strong>(Oject-based data mode): 一种用对象 来组织空间数据的数据模型，它将空间数据和属性数据储存在同一个系统内。</p><p><strong>栅格数据模型</strong>(Raster data model): 一种用格网 和像元来表示要素空间变化的空间数据模型。</p><p><strong>关系数据库</strong>( Relational database): 一系列表的集合，可通过关键字段与其他表格连接。</p><p><strong>拓扑</strong>(Topology):  数学的一个分支， 应用在GIS中，确保要素之间的空间关系能明晰表达。</p><p><strong>不规则三角网</strong>(TIN): 一种复合矢量数据模型， 它采用一套互不重叠的三角形 来近似表示地形。</p><p><strong>矢量数据模型</strong>(Vector data model): 一种空间数据模型，采用点及其x、y坐标来构建点、线和面空间要素。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
          <category> 地理信息系统导论-陈建飞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地理信息系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门级的web前端教程网站</title>
      <link href="/2019/06/24/%E5%85%A5%E9%97%A8%E7%BA%A7%E7%9A%84web%E5%89%8D%E7%AB%AF%E6%95%99%E7%A8%8B%E7%BD%91%E7%AB%99/"/>
      <url>/2019/06/24/%E5%85%A5%E9%97%A8%E7%BA%A7%E7%9A%84web%E5%89%8D%E7%AB%AF%E6%95%99%E7%A8%8B%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener"><strong>1.w3school在线教程</strong></a></p><p><img src="http://xiaobaigis.com/net/upload/image/20170818/6363869669817514897192376.png" alt="index-logo.png"></p><p>  W3Cschool是一个入门级的程序应用学习网站，W3CSchool 一直在升级和更新，对于学习web开发的入门级学员是相当不错的一个教程网站，也可以资源下载中心下载w3school离线教程</p><p><a href="http://www.runoob.com/http/http-tutorial.html" target="_blank" rel="noopener"><strong>2.菜鸟教程</strong></a></p><p><img src="http://xiaobaigis.com/net/upload/image/20170818/6363869689980787801457382.png" alt="runoob-logo.png"></p><p>  菜鸟教程提供了最全的的web技术基础教程,介绍了HTML教程、CSS教程、Javascript教程、Python基础教程，PHP教程等各种建站基础，值得学习收藏。</p><p><a href="http://www.51zxw.net/" target="_blank" rel="noopener"><strong>3.我要自学网</strong></a></p><p><img src="http://xiaobaigis.com/net/upload/image/20170818/6363869737158097255964346.png" alt="logo.png"></p><p>  我要自学网提供了的视频教程均由经验丰富的在职老师原创录制，同时提供各类贴心服务，让大家享受一站式的学习体验。</p><p><a href="http://www.php.cn/" target="_blank" rel="noopener"><strong>4.PHP中文网</strong></a></p><p><img src="http://xiaobaigis.com/net/upload/image/20170819/6363875352995879252904644.png" alt="DL4D`72}0P}F$~W2S0C)Y{M.png"></p><p>  php中文网是极为全面的web前端知识体系，适合初学者学习前端的扎实基础知识。</p><p><a href><strong>5.绿叶学习网</strong></a></p><p><img src="http://xiaobaigis.com/net/upload/image/20170819/6363875382573907882943178.png" alt="JG$D){IPH4YQ9DJ8PK@E}9N.png"></p><p>  绿叶学习网是一个非常富有活力的Web技术学习网站。在这里，我们只提供互联网最好的Web技术教程和最佳的学习体验</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>何为数据,信息</title>
      <link href="/2019/06/24/%E4%BD%95%E4%B8%BA%E6%95%B0%E6%8D%AE-%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/06/24/%E4%BD%95%E4%B8%BA%E6%95%B0%E6%8D%AE-%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>最近在学习GIS中,注意到名词中反复出现的两个词 “数据” 和 “信息”, 观察到有的句子中使用数据一词,而有的则使用信息一词, 博主以前并未仔细探讨过两者的异同, 总是隐约的区分, 现在感觉不能再这样了, 是时候仔细区分一下两者了, 主要也是方便学习中的名词记忆, 哈哈!</p><p><strong>通俗的说</strong>:<br>    <a href>数据</a>:  是能存储到计算机里的内容,包括数字,文字,图片等<br>    <a href>信息</a>:  数据里所涵盖的内容<br>    <strong><em>数据经过加工可以提炼出信息</em></strong></p><p>以下为更为详细严谨的解释:</p><h3 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h3><p>有一句话是这么说的“数据是爆炸了，信息却很贫乏”，那么<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370" target="_blank" rel="noopener">数据</a>与<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163" target="_blank" rel="noopener">信息</a>之间到底有什么关系呢？</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>数据和信息之间是相互联系的。数据是反映客观事物属性的记录，是信息的具体表现形式。数据经过加工处理之后，就成为信息；而信息需要经过数字化转变成数据才能存储和传输。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>那么，数据是否就是指可以存储和传输的信息呢？未必！数据和信息是有区别的。从信息论的观点来看，描述信源的数据是信息和数据冗余之和，即：数据=信息+数据冗余。数据是数据采集时提供的，信息是从采集的数据中获取的有用信息。</p><p><a href="https://baike.baidu.com/pic/%E6%95%B0%E6%8D%AE%E4%B8%8E%E4%BF%A1%E6%81%AF/16439942/0/bba1cd11728b471069863c82c0cec3fdfd0323d7?fr=lemma&amp;ct=single" target="_blank" rel="noopener"><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D250/sign=208bce572ef5e0feea188e046c6134e5/bba1cd11728b471069863c82c0cec3fdfd0323d7.jpg" alt="图1 数据与信息的关系"></a></p><p>​           图1 数据与信息的关系</p><p>由此可见，信息可以简单地理解为数据中包含的有用的内容。不严格的说，“不知道的东西，你知道了，就获得了一个信息”。</p><h3 id="定量分析"><a href="#定量分析" class="headerlink" title="定量分析"></a>定量分析</h3><p>上面定性分析了数据和信息之间的区别和联系，下面对数据和信息进行定量分析。数据量和信息量之间会有什么联系呢？是不是数据量越大，其中包含的信息量就越多呢？不一定。比如，有人说“人的嘴巴上方有鼻子，鼻子上方有眼睛”，因为这是预料中的事，所以你从这个消息中得到的信息量很少。但如果有人说“人的鼻子上方有嘴巴，嘴巴上方有眼睛”，就会让人很震惊，因为这是预料之外的，这样的信息量就很大。这说明了：一个消息越不可预测，它所含的信息量就越大。</p><p>事实上，信息的基本作用就是消除人们对事物了解的不确定性。信息量是指从N个相等的可能事件中选出一个事件所需要的信息度量和含量。从这个定义看，信息量跟概率是密切相关的。在概率论中，用P(x)表示在N个相等的可能事件出现某一个事件的概率，即P(x)=1/N。信息量I(x)定义为：</p><p>​                                                 I(x)=log2N = -log2(1/N )= -log2P(x)</p><p>结合概率论知识，推而广之，可以用下面的公式——称之为熵H（x）公式来表示一大堆数据带来的平均信息量。</p><p><strong>注意：</strong>这个平均信息量不是算术平均，是概率论的统计平均——数学期望值。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据 </tag>
            
            <tag> 信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch模型训练实用PDF教程【中文】（附下载链接）</title>
      <link href="/2019/06/21/Pytorch%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%AE%9E%E7%94%A8PDF%E6%95%99%E7%A8%8B%E3%80%90%E4%B8%AD%E6%96%87%E3%80%91%EF%BC%88%E9%99%84%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%EF%BC%89/"/>
      <url>/2019/06/21/Pytorch%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%AE%9E%E7%94%A8PDF%E6%95%99%E7%A8%8B%E3%80%90%E4%B8%AD%E6%96%87%E3%80%91%EF%BC%88%E9%99%84%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>本教程以实际应用、工程开发为目的，着重介绍模型训练过程中遇到的实际问题和方法。</strong> 在机器学习模型开发中，主要涉及三大部分，分别是数据、模型和损失函数及优化器。 <strong>本文也按顺序的依次介绍数据、模型和损失函数及优化器，从而给大家带来清晰的机器学习结构。</strong></p><p><strong>通过本教程，希望能够给大家带来一个清晰的模型训练结构。</strong> 当模型训练遇到问题时，需要通过可视化工具对数据、模型、损失等内容进行观察，分析并定位问题出在数据部分？模型部分？还是优化器？只有这样不断的通过可视化诊断你的模型，不断的对症下药，才能训练出一个较满意的模型。</p><p><strong>本教程内容及结构：</strong></p><p>本教程内容主要为在 PyTorch 中训练一个模型所可能涉及到的方法及函数，并且对 PyTorch 提供的数据增强方法（22 个）、权值初始化方法（10 个）、损失函数（17 个）、优化器（6 个）及 tensorboardX 的方法（13 个）进行了详细介绍。</p><p>本教程分为四章，结构与机器学习三大部分一致：</p><ul><li>第一章，介绍数据的划分，预处理，数据增强；</li><li>第二章，介绍模型的定义，权值初始化，模型 Finetune；</li><li>第三章，介绍各种损失函数及优化器；</li><li>第四章，介绍可视化工具，用于监控数据、模型权及损失函数的变化。</li></ul><p><strong>本教程适用读者：</strong></p><ol><li><p>想熟悉 PyTorch 使用的朋友；</p></li><li><p>想采用 PyTorch 进行模型训练的朋友；</p></li><li><p>正采用 PyTorch，但无有效机制去诊断模型的朋友；</p></li></ol><p><img src="https://cdn.bigquant.com/community/uploads/default/optimized/3X/f/9/f909b8cacb52520d18e2bd71317ebc2731ea2ff6_1_383x500.jpeg" alt></p><p><img src="https://cdn.bigquant.com/community/uploads/default/optimized/3X/6/9/695dc8bad88f1f3a072468d44037550fce3ea177_1_382x500.jpeg" alt></p><p><img src="https://cdn.bigquant.com/community/uploads/default/optimized/3X/1/d/1da45808224db16ba9542438e478fb32eb32ead6_1_382x500.png" alt></p><p><img src="https://cdn.bigquant.com/community/uploads/default/optimized/3X/4/0/4032772dbb3666c99eb044e205a04aef796a518e_1_382x500.png" alt></p><h3 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h3><ul><li><strong>登陆下载：</strong> <a href="https://pan.baidu.com/s/1MGyCvnosI57IEf3s6UswGw（提取码：2hps）" target="_blank" rel="noopener">https://pan.baidu.com/s/1MGyCvnosI57IEf3s6UswGw（提取码：2hps）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图示学习机器学习《图解机器学习》（附下载链接）</title>
      <link href="/2019/06/21/%E5%9B%BE%E7%A4%BA%E5%AD%A6%E4%B9%A0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8A%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B(%E9%99%84%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5)/"/>
      <url>/2019/06/21/%E5%9B%BE%E7%A4%BA%E5%AD%A6%E4%B9%A0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8A%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B(%E9%99%84%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5)/</url>
      
        <content type="html"><![CDATA[<p><strong>《图解机器学习》</strong> ，人民邮电出版社出版，外文书名: イラストで学ぶ 機械学習，作者：[日]杉山将 (作者),‎ 许永伟 (译者)。《图解机器学习》用丰富的图示，从最小二乘法出发，对基于最小二乘法实现的各种机器学习算法进行了详细的介绍。第Ⅰ部分介绍了机器学习领域的概况；第Ⅱ部分和第Ⅲ部分分别介绍了各种有监督的回归算法和分类算法；第Ⅳ部分介绍了各种无监督学习算法；第Ⅴ部分介绍了机器学习领域中的新兴算法。书中大部分算法都有相应的MATLAB程序源代码，可以用来进行简单的测试。</p><p>专业实用：东京大学教授、机器学习权威专家执笔，浓缩机器学习的关键知识点;图文并茂：187张图示帮助理解，详略得当，为读懂大部头开路。;角度新颖：基于最小二乘法讲解各种有监督学习的回归和分类算法，以及无监督学习算法。;实战导向：配有可执行的MATLAB程序代码，边学习边实践。</p><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/3/6/36f17564eeb905f95fbc6c1a138d7b6b7340ac32.jpeg" alt="image"></p><h3 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h3><ul><li><strong>登陆下载：</strong> <a href="https://pan.baidu.com/share/init?surl=uQo-2EBA6xWntKA0z31QTQ（提取码：u96r）" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=uQo-2EBA6xWntKA0z31QTQ（提取码：u96r）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图解机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21个GIF图助你理解各种数学概念</title>
      <link href="/2019/06/21/21%E4%B8%AAGIF%E5%9B%BE%E5%8A%A9%E4%BD%A0%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/06/21/21%E4%B8%AAGIF%E5%9B%BE%E5%8A%A9%E4%BD%A0%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1、椭圆的画法"><a href="#1、椭圆的画法" class="headerlink" title="1、椭圆的画法"></a>1、椭圆的画法</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/f/0/f036bb6de01988b4ef5138ace1eef596ed35694b.gif" alt="1"></p><h2 id="2、杨辉三角问题-Pascal-triangles-解法"><a href="#2、杨辉三角问题-Pascal-triangles-解法" class="headerlink" title="2、杨辉三角问题(Pascal triangles)解法"></a>2、杨辉三角问题(Pascal triangles)解法</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/8/5/854e91975cf2961f783907b9ced63a9585207474.gif" alt="2"></p><h2 id="3、使用“FOIL”轻松的解决二项式乘法"><a href="#3、使用“FOIL”轻松的解决二项式乘法" class="headerlink" title="3、使用“FOIL”轻松的解决二项式乘法"></a>3、使用“FOIL”轻松的解决二项式乘法</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/1/7/177a28a6707ec07015fefc149ca0a9cf0c993c9b.gif" alt="3"></p><h2 id="4、对数解法技巧"><a href="#4、对数解法技巧" class="headerlink" title="4、对数解法技巧"></a>4、对数解法技巧</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/9/0/908bf4ed43819f0c79a7f810b3bcab0b8beccf47.gif" alt="4"></p><h2 id="5、矩阵转置的技巧"><a href="#5、矩阵转置的技巧" class="headerlink" title="5、矩阵转置的技巧"></a>5、矩阵转置的技巧</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/1/e/1edad98e3f9c1bf9a1f735310fd95e74ce288f6d.gif" alt="5"></p><h2 id="6、勾股定理"><a href="#6、勾股定理" class="headerlink" title="6、勾股定理"></a>6、勾股定理</h2><p>## </p><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/e/5/e5ab043994ce2864034d31673fdd9993a8435044.gif" alt="6"></p><h2 id="7、多边形的外角之和总是等于360度"><a href="#7、多边形的外角之和总是等于360度" class="headerlink" title="7、多边形的外角之和总是等于360度"></a>7、多边形的外角之和总是等于360度</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/9/8/984d679a49d87ccd6b77344573da65948dc87905.gif" alt="7"></p><h2 id="8、圆周率π"><a href="#8、圆周率π" class="headerlink" title="8、圆周率π"></a>8、圆周率π</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/3/e/3eac934064474463bc5237303ddcd1ce127e7b4d.gif" alt="8"></p><h2 id="9、一弧度就是长度刚好等于半径的一段圆弧所对的圆心角"><a href="#9、一弧度就是长度刚好等于半径的一段圆弧所对的圆心角" class="headerlink" title="9、一弧度就是长度刚好等于半径的一段圆弧所对的圆心角"></a>9、一弧度就是长度刚好等于半径的一段圆弧所对的圆心角</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/b/6/b6cb206c0a128dd16e70909d40317bd0c89d4a88.gif" alt="9"></p><h2 id="10、在Y轴上使用正弦-红色-，在X轴上使用余弦-蓝色-，则在XY轴平面上画出的环形如下图-黑色"><a href="#10、在Y轴上使用正弦-红色-，在X轴上使用余弦-蓝色-，则在XY轴平面上画出的环形如下图-黑色" class="headerlink" title="10、在Y轴上使用正弦(红色)，在X轴上使用余弦(蓝色)，则在XY轴平面上画出的环形如下图(黑色)"></a>10、在Y轴上使用正弦(红色)，在X轴上使用余弦(蓝色)，则在XY轴平面上画出的环形如下图(黑色)</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/3/f/3fc160c968cda4bbd4023a9ba52fc3cc759ab298.gif" alt="10"></p><h2 id="11、同前一原理，但更简单"><a href="#11、同前一原理，但更简单" class="headerlink" title="11、同前一原理，但更简单"></a>11、同前一原理，但更简单</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/4/4/447fdc4836f93faf809ebc32ac187eb46d56ce5b.gif" alt="11"></p><h2 id="12、这是将sin和cos运用到三角形上"><a href="#12、这是将sin和cos运用到三角形上" class="headerlink" title="12、这是将sin和cos运用到三角形上"></a>12、这是将sin和cos运用到三角形上</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/c/2/c26340a0279bfc5bf1b209c7206cc73e019225da.gif" alt="12"></p><h2 id="13、余弦是正弦的衍生物"><a href="#13、余弦是正弦的衍生物" class="headerlink" title="13、余弦是正弦的衍生物"></a>13、余弦是正弦的衍生物</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/2/f/2fc23e11ac90d1ed756e48f3670986839c7ce1d2.gif" alt="13"></p><h2 id="14、正切线"><a href="#14、正切线" class="headerlink" title="14、正切线"></a>14、正切线</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/7/c/7c0a215f7f560ed6c7f603e8dab2c6788e7e2223.gif" alt="14"></p><h2 id="15、同上，但翻个面看，更容易理解"><a href="#15、同上，但翻个面看，更容易理解" class="headerlink" title="15、同上，但翻个面看，更容易理解"></a>15、同上，但翻个面看，更容易理解</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/7/5/754c9be63b573130db601730cedb0d067da5992d.gif" alt="15"></p><h2 id="16、将一个公式从笛卡尔坐标转换成轴坐标"><a href="#16、将一个公式从笛卡尔坐标转换成轴坐标" class="headerlink" title="16、将一个公式从笛卡尔坐标转换成轴坐标"></a>16、将一个公式从笛卡尔坐标转换成轴坐标</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/d/8/d86e9776aeefb319c91cd42658492bc3c0ac4ef2.gif" alt="16"></p><h2 id="17、画抛物线"><a href="#17、画抛物线" class="headerlink" title="17、画抛物线"></a>17、画抛物线</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/c/f/cf079080b723d4cc84b4c796376dc8b5ecfb0cd2.gif" alt="17"></p><h2 id="18、黎曼和-Riemann-sum-约等于其曲线下的面积"><a href="#18、黎曼和-Riemann-sum-约等于其曲线下的面积" class="headerlink" title="18、黎曼和(Riemann sum)约等于其曲线下的面积"></a>18、黎曼和(Riemann sum)约等于其曲线下的面积</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/e/e/eecb612ba48fa12273effb374ce9ce5e7e0267b0.gif" alt="18"></p><h2 id="19、双曲线"><a href="#19、双曲线" class="headerlink" title="19、双曲线"></a>19、双曲线</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/7/0/707b1395f50ccc5546a00318620ace72ca2488c3.gif" alt="19"></p><h2 id="20、将双曲线表现成3D形式，也许你不相信，它完全是用直线画成的"><a href="#20、将双曲线表现成3D形式，也许你不相信，它完全是用直线画成的" class="headerlink" title="20、将双曲线表现成3D形式，也许你不相信，它完全是用直线画成的"></a>20、将双曲线表现成3D形式，也许你不相信，它完全是用直线画成的</h2><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/c/e/ce60678352de57fc23d197f79e77597526e75154.gif" alt="20"></p><p>你甚至可以做成这样的效果：</p><p><img src="https://cdn.bigquant.com/community/uploads/default/original/3X/6/3/63a09cecfc0f214ac4bacf33fce185244f03fa7d.gif" alt="21"></p>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
          <category> 有趣的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一元及多元函数的泰勒展开式</title>
      <link href="/2019/06/20/%E4%B8%80%E5%85%83%E5%8F%8A%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F/"/>
      <url>/2019/06/20/%E4%B8%80%E5%85%83%E5%8F%8A%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一-函数极限"><a href="#一-函数极限" class="headerlink" title="一. 函数极限"></a>一. 函数极限</h3><ol><li>方法: 等价代换, 洛必达法则, 泰勒公式, 导数定义, 拉格朗日中值定理<br><a href>注:</a> </li></ol><p>$$<br>x \rightarrow 0时, x-\sin x \sim \frac{1}{6} x^{3}, x-\arcsin x \sim-\frac{1}{6} x^{3}, x-\tan x \sim-\frac{1}{3} x^{3}<br>$$</p><p>$$<br>x-\arctan x \sim \frac{1}{3} x^{3}, x-\ln (1+x) \sim \frac{1}{2} x^{2}, \tan x-\sin x \sim \frac{1}{2} x^{3}, \quad e^{x}-1-x \sim \frac{1}{2} x^{2}<br>$$</p><p>$$<br>\sqrt{1+x}-1-\frac{1}{2} x \sim-\frac{1}{8} x^{2}, 1-\cos ^{\alpha} x \sim \frac{\alpha}{2} x^{2}, f(x) \rightarrow 1 \mathrm{H}^{+}, \ln f(x) \sim f(x)-1<br>$$</p><ol start="2"><li><p>技巧: 加减中把极限存在 (不管是否为0) 的部分拆项先算出来, 乘除中把极限存在 (必须不为0)的部分分离先算出来, 对 $$ x \rightarrow  0 (或 +\infty,-\infty ) 且带 \frac{1}{x} $$ 的极限采用倒带换, 猪大头, 有理化</p></li><li><p>误区: 乱等价, 乱计算出来一部分的极限, 不作必要化简</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex 免费神器！再也不怕复杂的公式了</title>
      <link href="/2019/05/31/LaTex-%E5%85%8D%E8%B4%B9%E7%A5%9E%E5%99%A8%EF%BC%81%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%AC%E5%BC%8F%E4%BA%86/"/>
      <url>/2019/05/31/LaTex-%E5%85%8D%E8%B4%B9%E7%A5%9E%E5%99%A8%EF%BC%81%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%AC%E5%BC%8F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>推荐一个免费神器 Snip，能把各种公式转成 LaTeX。</p><p><strong>下载链接：</strong></p><p><a href="https://mathpix.com/" target="_blank" rel="noopener">https://mathpix.com/</a></p><p><strong>简单易用</strong></p><p><strong>1、快捷方式启动</strong></p><p><img src="https://img.vim-cn.com/c8/fa40733889fb2023e5a155138470f1b85587a8.jpg" alt="img"></p><p><strong>2、鼠标划取要识别的公式</strong></p><p><img src="https://img.vim-cn.com/64/1bc98bad9307847e14d95474fbfba4377630af.gif" alt="img"></p><p><strong>3、可编辑转换后的 LaTeX</strong></p><p><img src="https://img.vim-cn.com/82/5fcd4fe0c66cd42bf1e2092bcdc7a38d270872.gif" alt="img"></p><p><strong>4、在编辑器中粘贴 LaTeX</strong></p><p><img src="https://img.vim-cn.com/b8/82a921420809368c6c85b1659821d90dd93ae1.jpg" alt="img"></p><p>除了印刷的公式，手写的公式也能识别转换。（当然要字迹工整，别鬼画符那种）</p><p>除了公式，化学方程式和矩阵等也能识别。</p><p><img src="https://img.vim-cn.com/ee/ddf68a9292b88c0d8b08f95d2fc1f7eb903606.jpg" alt="img"></p><p>支持 Mac、Windows 和 Ubuntu；</p><p>下载链接：<a href="https://mathpix.com/" target="_blank" rel="noopener">https://mathpix.com/</a>  需要的童鞋自取咯~</p>]]></content>
      
      
      <categories>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快来摆脱平淡的地图</title>
      <link href="/2019/05/31/%E5%BF%AB%E6%9D%A5%E6%91%86%E8%84%B1%E5%B9%B3%E6%B7%A1%E7%9A%84%E5%9C%B0%E5%9B%BE/"/>
      <url>/2019/05/31/%E5%BF%AB%E6%9D%A5%E6%91%86%E8%84%B1%E5%B9%B3%E6%B7%A1%E7%9A%84%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/bXDCzf4pp0cOkGBExNWuMuEZUmHtjo0Kiav1nj1O6aVfziclf36MssIDyBagqq1mxYibZLcxWibWFYbI2k8AH92CVA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/bXDCzf4pp0cOkGBExNWuMuEZUmHtjo0KWxA78oZU36m5JQn2e1RyhoOQLzTTm7LE4iasR52Rcskw4Ze16V3gOLw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img">「字不如表，表不如图」想必大家都有过这样的经历，制作 PPT 、Excel 或者写文章时，遇到关于地理位置方面的内容需要描述，想配一张像文章开头那样的酷炫地图，可是吧，要么找不到合适的地图、找到了地图，可能地图本身不够高大上，终于地图问题解决了，又不知如何把自己的数据内容，添加上去，用专业的 GIS 软件吧，自己一时半会好像又玩不转；曲线救国，用 PhotoShop 吧， 操作繁杂费劲~~~</p><p><img src="https://img.vim-cn.com/fa/105a091eef5cb6752c582c16c07a6c44554ed1.jpg" alt="img"></p><p>下面介绍几种地图数据可视化的方法，可以满足绝大部分需求，总有一款适合你，以下方法从易到难：</p><p><strong>01 地图慧</strong></p><p>地图慧，打造不一样的互联网地图，是一款面向个人用户和企业用户的在线制图与地理信息服务平台。地图慧·大众制图为用户提供交互式制图工具，用户无需专业知识与编程经验，即可一键快速将Excel表格数据生成为地图。</p><p><img src="https://img.vim-cn.com/37/37dafc984a82df5a8b34ba465f7a9f421bf9c2.png" alt="image.png"></p><p>*Pixel Map**</p><p>地址<em>：<a href="http://pixelmap.amcharts.com/" target="_blank" rel="noopener">http://pixelmap.amcharts.com/</a></em></p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/bXDCzf4pp0cOkGBExNWuMuEZUmHtjo0K8bC1LymjpWhj8amrAzMQ5XNRCd2yr0pE57ZMv6TJictsx1Ej1zOcn2g/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p><p>Pixel Map 提供世界范围内的矢量地图，但数据精度国内只到省级。你可以在地图上做一些简单文字、图标、图形标记，然后保存成图片或者Html</p><p><img src="https://img.vim-cn.com/ba/3d9f0ae44d4f8c179750ab28ec190a429b6d0f.png" alt="img"></p><p>Pixel Map 还可以生成满满科技感的像素图：</p><p><img src="https://img.vim-cn.com/6c/3d3c1672b7d4fb2fafaa6458891894d30f093b.png" alt="img"></p><p>总结：Pixel Map 操作简单，打开即用，适合一些简单的地图标识场景。</p><p><strong>BDP</strong></p><p>地址<em>：<a href="https://me.bdp.cn/home.html" target="_blank" rel="noopener">https://me.bdp.cn/home.html</a></em></p><p>如果你想在地图上展示一些统计数据，Pixel Map虽然也能勉强胜任，但这里有更好的选择，就是 BDP。BDP 对多数据源提供支持，excel ，数据库（Oracle、MySQL、SQLServer）通通可以，常规饼状、柱状、折线图统计功能自然不在话下，地图展示也是游刃有余，它还提供  PPT 和 Excel 插件，让你可以在 Office 中就快速上传数据，在本地展示分析结果，最重要的是它提供个人免费版。</p><p>如果你手里有一张 excel 表格可以上传到 BDP 中，体验一下：比如下图这张「销售业绩报表」</p><p><img src="https://img.vim-cn.com/9c/c8d809f7237fe2cc4e9820eb34982cab8e950d.png" alt="img"></p><p>BDP 可以根据这张表制作</p><p><img src="https://img.vim-cn.com/df/e67306552011fed175a0e9e9ba76508a7afc54.png" alt="img"></p><p>还可以通过简单的拖拽，选择想要分析的字段，和图表类型：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/bXDCzf4pp0cOkGBExNWuMuEZUmHtjo0KV0rysw3B94T8Smws6icib1qYAhQpZBJRicsBDkHv1x6HWKa5N8BQ0s4LQ/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p><p><strong>总结：</strong>BDP 适合对数据有精确要求的用户，特别是那些有多数据源的分析内容。个人版免费这个很吸引人。</p><p><strong>DataMap</strong></p><p>最后祭出一个大杀器，这是一个 MicroSoft Office Excel 插件，功能极为强大，几乎可以满足你所有地图表达的需求。插件安装完成后，Excel 菜单栏上会多出一个选项卡，这里集合了你可能会用到的关于地图方面的功能。</p><p><img src="https://img.vim-cn.com/5a/f7540ca090af5bf5f46e9efa1407359c83977f.png" alt="image.png"></p><p>插件支持多个地图（高德、百度、ECharts）,每种地图支持的功能也不尽相同。想要让插件能正确的识别你提供数据，需要使用插件提供的数据模板，这里每个功能对应一个数据模板，当你想使用某个功能时请选择对应模板，在模板中填充数据即可。</p><p><img src="https://img.vim-cn.com/99/9699b144cb39ac2cd8e802a89127c32a076548.png" alt="image.png"></p><p>下面简单介绍几个：</p><p><strong>1. 地址解析 </strong></p><p>它可以将你输入的文字地址所在的经纬度坐标查询出来，并在表格中显示。在模板中输入地址，点击开始执行：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/bXDCzf4pp0cOkGBExNWuMuEZUmHtjo0K0MiaDCbgj8X57IzYPlOxnFvWjfpum4ibDqZ7W84dVHm5ibFBb63TP4maA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p><p><strong>2. 逆地址解析</strong></p><p>顾名思义，它可以将经纬度坐标对应的详细地址查询出来，并在表格中显示。在模板中输入经度、维度，点击开始执行：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/bXDCzf4pp0cOkGBExNWuMuEZUmHtjo0KGAvk5OeXANHh5jdaa7HYvNqoRdYmJWbPLxyIOl2vIxDj1rh3bfA0JA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p><p><strong>3. 热力图</strong></p><p>以后再也不用羡慕别人做的酷炫的热力图，只要你有数据，热力图分分钟搞定。选择热力图数据模板，在模板中输入经纬度，如果你只知道位置名称，又不想去一个个去查这些位置的坐标，这里你就可以使用「地址解析」功能，秒得坐标，然后在表格中输入对应参数值即可，只需要三列数据（x, y, value）就可以制作热力图。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/bXDCzf4pp0cOkGBExNWuMuEZUmHtjo0KMgsbnIHicMeh2xnrLkOrwRc5aVwVVYfiaPD5eTPiaTVYclqrFIur5Q1Ag/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p><p>其他功能还有包括「迁徙图」、「散点图」等，总有一个适合你，这里不一一示范了。</p><p><strong>总结：</strong>DataMap 需要安装插件，第一次使用可能没有前两个工具方便，但它功能更强大，与 Excel 深度集成，本地操作也更加便利， 支持 30天免费试用。</p><p><strong>其它</strong></p><p><strong>1. Power Map</strong></p><p>Office 自己其实也有个插件叫 Power Map，用的是自家的 Bing 地图。</p><p><img src="https://img.vim-cn.com/de/5d7f22290d192ac1038baee358e2c17cdd5416.png" alt="img"></p><p><strong>2. ArcGIS Maps for Office</strong></p><p>说到地图怎么可能缺了ArcGIS，这个也是一个 Office 插件，毕竟专业的，功能也极为强大，大家可以体验一下。</p><p><img src="https://img.vim-cn.com/81/b990d321f91a32514b7bf3a5154ea4487268ac.png" alt="img"></p><p><strong>3. 高德地图 Map Lab</strong></p><p>地址：<em><a href="https://maplab.amap.com/" target="_blank" rel="noopener">https://maplab.amap.com/</a></em></p><p>对就是我们手机上常用的高德地图，它提供的功能，大家感受一下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/FdsAjuJHm4jBkAozDEiaYZC8efCfMnlWDmtPH3icbNFFDrU2cfBRwwbQ6bukQt6aYDziad7iad0XMmGlpsv6bqicYNQ/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p><p>下面的章节将为大家着重介绍工具的使用技巧</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArcGIS-API-for-JavaScript入门教程-4-代码的骨架</title>
      <link href="/2019/05/17/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-4-%E4%BB%A3%E7%A0%81%E7%9A%84%E9%AA%A8%E6%9E%B6/"/>
      <url>/2019/05/17/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-4-%E4%BB%A3%E7%A0%81%E7%9A%84%E9%AA%A8%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【回顾与本篇预览】</p><p>上篇简单介绍了JsAPI中的数据与视图，并告诉大家这两部分有什么用、如何有机连接在一起。</p><p>这一篇快速介绍一下前端代码的骨架。当然，假定你已经熟悉HTML5、CSS3和JavaScript（最好了解一下ES6）</p></blockquote><h1 id="1-代码"><a href="#1-代码" class="headerlink" title="1. 代码"></a>1. 代码</h1><p>为了方便演示，我将js代码和css代码全都写在一个html文件里，当然，更合适的做法是三者分离，不过要注意引用的顺序哦。</p><p>使用上篇三维视图的代码↓</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Intro to SceneView - Create a 3D map - 4.7<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    html,</span></span><br><span class="line"><span class="undefined">    body,</span></span><br><span class="line"><span class="undefined">    #viewDiv &#123;</span></span><br><span class="line"><span class="undefined">      padding: 0;</span></span><br><span class="line"><span class="undefined">      margin: 0;</span></span><br><span class="line"><span class="undefined">      height: 100%;</span></span><br><span class="line"><span class="undefined">      width: 100%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://js.arcgis.com/4.7/esri/css/main.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://js.arcgis.com/4.7/"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    require([</span></span><br><span class="line"><span class="undefined">      "esri/Map",</span></span><br><span class="line"><span class="undefined">      "esri/views/SceneView",</span></span><br><span class="line"><span class="undefined">      "dojo/domReady!"</span></span><br><span class="line"><span class="undefined">    ], function(Map, SceneView) &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      var map = new Map(&#123;</span></span><br><span class="line"><span class="undefined">        basemap: "streets",</span></span><br><span class="line"><span class="undefined">        ground: "world-elevation"</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      var view = new SceneView(&#123;</span></span><br><span class="line"><span class="undefined">        container: "viewDiv",</span></span><br><span class="line"><span class="undefined">        map: map,</span></span><br><span class="line"><span class="undefined">        scale: 50000000,</span></span><br><span class="line"><span class="undefined">        center: [-101.17, 21.78]</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"viewDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-HTML组成-CSS简单解释"><a href="#2-HTML组成-CSS简单解释" class="headerlink" title="2. HTML组成/CSS简单解释"></a>2. HTML组成/CSS简单解释</h1><p>先把标签都折叠，过一下HTML的组成。</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180525220731933-2105263696.png" alt="img"></p><p>什么？你说你不喜欢看代码？那怎么行，得培养梳理代码的能力。我在这继续用图解法，剖析页面结构：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180525221649483-1335837134.png" alt="img"></p><p>其中，第二个script标签是我们自己的代码。</p><p>link标签用于引用官方预设css，没有它页面不能工作。</p><p>第一个script标签用于引用JsAPI的核心文件。</p><p>注意到，body是整个页面的组织，在这里只有一个id为viewDiv的div，用于承载视图。</p><p>在link标签上还有这么一个style样式标签，是对页面样式的预设，其实很简单，仅仅是对html的一些元素做无边框处理而已。</p><h1 id="3-script标签的内容"><a href="#3-script标签的内容" class="headerlink" title="3. script标签的内容"></a>3. script标签的内容</h1><p>把js代码折叠后，是这样的：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180525222330191-196862742.png" alt="img"></p><p>收缩起的代码上篇已经解释过了，map是数据，view是视图，view通过SceneView类的构造函数中的传参中的map属性进行连通，这里就不再复述。</p><p>结构图是这样的：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180525223730648-505318353.png" alt="img"></p><p>require()是JsAPI的基础——Dojo框架规定的一个全局入口，与初学C语言时接触的main()函数类似。</p><h2 id="3-1-类引用列表"><a href="#3-1-类引用列表" class="headerlink" title="3.1 类引用列表"></a>3.1 类引用列表</h2><p>第一个参数，是一个字符串数组。它规定了接下来的代码需要用哪些类（官方说法叫模块），用字符串描述了所需类（模块）所在的包路径。与C#中using 命名空间;类似。</p><p>如”esri/views/SceneView”就代表引用esri这个包下的views这个包里的SceneView这个类。不妨在浏览器调试窗口中看看资源：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180525225530587-1734468849.png" alt="img"></p><p>因为第一个script标签引用的地址是“<a href="https://js.arcgis.com/4.7/”，所以esri这个包就是基于此目录下的相对路径了。" target="_blank" rel="noopener">https://js.arcgis.com/4.7/”，所以esri这个包就是基于此目录下的相对路径了。</a></p><p>同理，”esri/Map”也是这样引用的一个类。</p><p>至于”dojo/domReady!”这个，则是dojo框架的一个特殊类（模块），所以会在”domReady”后加一个叹号，这是dojo的一个插件，代表DOM加载完成后再执行后面的代码。</p><h2 id="3-2-回调函数"><a href="#3-2-回调函数" class="headerlink" title="3.2 回调函数"></a>3.2 回调函数</h2><p>回调函数的形参列表除了”dojo/domReady!”这个特殊的之外，均要与类引用列表中的类顺序上一一对应，但是名字可以自由，一般与官方的类名一致。</p><p>至于本例中回调函数的内容，上篇讲过啦。</p><p>既可以用Lambda表达式，也可以在外部定义函数，传函数名进require()中。</p><p><strong>对了</strong>，上篇没讲如何将SceneView与HTML元素绑定的，其实只是SceneView构造函数中的一个属性而已：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180525231611915-253591136.png" alt="img"></p><p>container属性利用id选择器（不用写#）选择div。</p><p>scale是比例尺，center是中央经纬度。</p><h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p>由于AMD规范的要求，require()就是这么一个异步操作。你要告诉后台，你要用哪些功能（参数1，类引用列表），你要拿这些功能做什么（参数2，回调函数）。</p><p>回调函数就代表，等相关的资源准备好后，再根据此回调函数做事情。回调函数中仍存在很多异步操作，这就是ES6中Promise的用法了，when()异步链使得异步操作写起来更方便，如果对异步和回调有什么不懂的，请到网上查资料学习，在此不展开了——<strong>但是，异步操作仍然是JsAPI中极为重要的一个技术。</strong></p><h1 id="4-骨架整理图-amp-总结"><a href="#4-骨架整理图-amp-总结" class="headerlink" title="4. 骨架整理图&amp;总结"></a>4. 骨架整理图&amp;总结</h1><p>总结就是，require()这个唯一入口，带了一个引用列表（字符串数组），带了一个回调函数。</p><p>回调函数里写你需要做的事情，当然，回调的形参要与引用列表一一对应。</p><p>以下是骨架图。</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180525231441839-1709998106.png" alt="img"></p><p>本篇到此结束，有了这个骨架，后面只是在script标签里加自己的内容而已。</p><p>待工程茁壮到一定规模的时候，dojo的模块化技术才能用得上，那并不是本入门教程的内容了。</p><p>背景也交代完了，下篇进入约定好的几个部分的API的讲解。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcGIS </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Next下busuanzi无效</title>
      <link href="/2019/04/30/%E8%A7%A3%E5%86%B3Next%E4%B8%8Bbusuanzi%E6%97%A0%E6%95%88/"/>
      <url>/2019/04/30/%E8%A7%A3%E5%86%B3Next%E4%B8%8Bbusuanzi%E6%97%A0%E6%95%88/</url>
      
        <content type="html"><![CDATA[<p>可以看看我的 <a href="https://llqing.github.io">https://llqing.github.io</a> 已经有效了</p><p>我的 next 是 6.x.x</p><p>找到 next 主题目录下的 busuanzi-counter.swig，修改 <code>&lt;script&gt;...&lt;/script&gt;</code> 如下语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>修改后如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.busuanzi_count.enable %&#125;</span><br><span class="line">&lt;div class=&quot;busuanzi-count&quot;&gt;</span><br><span class="line">  &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">    &lt;span class=&quot;site-uv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_visitors&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span class=&quot;site-pv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_views&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ArcScene三维制作</title>
      <link href="/2019/04/28/ArcScene%E4%B8%89%E7%BB%B4%E5%88%B6%E4%BD%9C/"/>
      <url>/2019/04/28/ArcScene%E4%B8%89%E7%BB%B4%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h5 id="1-添加地图数据"><a href="#1-添加地图数据" class="headerlink" title="1.添加地图数据"></a>1.添加地图数据</h5><p><img src="https://img.vim-cn.com/bb/4c5d3067b662afcea69cc168e7be020dded3a9.jpg" alt></p><h5 id="数据显示效果"><a href="#数据显示效果" class="headerlink" title="数据显示效果:"></a>数据显示效果:</h5><p><img src="https://img.vim-cn.com/ae/831ff75d7786c09abb0c6dd285da83fa5f47e6.jpg" alt></p><h5 id="1-1设置图层的显示顺序"><a href="#1-1设置图层的显示顺序" class="headerlink" title="1.1设置图层的显示顺序"></a>1.1设置图层的显示顺序</h5><p><img src="https://img.vim-cn.com/fe/92a3b09d4cb54e3f843d6e8c4d79a9a6abb10c.jpg" alt> </p><h5 id="数据显示效果-遥感影像在矢量图层上显示"><a href="#数据显示效果-遥感影像在矢量图层上显示" class="headerlink" title="数据显示效果: (遥感影像在矢量图层上显示)"></a>数据显示效果: (遥感影像在矢量图层上显示)</h5><p><img src="https://img.vim-cn.com/1d/2e8bd2f071bf46178012d06444e42c64e5ef0f.jpg" alt></p><h5 id="1-2设置影像图层的高程和高程分辨率-目的是遥感影像三维显示"><a href="#1-2设置影像图层的高程和高程分辨率-目的是遥感影像三维显示" class="headerlink" title="1.2设置影像图层的高程和高程分辨率(目的是遥感影像三维显示)"></a>1.2设置影像图层的高程和高程分辨率(目的是遥感影像三维显示)</h5><p><img src="https://img.vim-cn.com/70/107bf0274d20367a553b96611f69fac8d8accb.jpg" alt></p><h5 id="数据显示效果-遥感影像已经含有高程-突出显示"><a href="#数据显示效果-遥感影像已经含有高程-突出显示" class="headerlink" title="数据显示效果:(遥感影像已经含有高程,突出显示)"></a>数据显示效果:(遥感影像已经含有高程,突出显示)</h5><p><img src="https://img.vim-cn.com/8b/223faacdfdc0de2e41440be0cb2aab9c948aae.jpg" alt></p><h5 id="1-3设置矢量图层-县界线-的高程-1-3和1-4的目的是做3D场景的外围墙"><a href="#1-3设置矢量图层-县界线-的高程-1-3和1-4的目的是做3D场景的外围墙" class="headerlink" title="1.3设置矢量图层 (县界线) 的高程(1.3和1.4的目的是做3D场景的外围墙)"></a>1.3设置矢量图层 (县界线) 的高程(1.3和1.4的目的是做3D场景的外围墙)</h5><p><img src="https://img.vim-cn.com/01/a68497e0e3771ef971ea75fd3d2b15e0726074.jpg" alt></p><h5 id="数据显示效果-“县界线”图层设置了高程-注意和上图比较不同之处"><a href="#数据显示效果-“县界线”图层设置了高程-注意和上图比较不同之处" class="headerlink" title="数据显示效果: “县界线”图层设置了高程(注意和上图比较不同之处)"></a>数据显示效果: “县界线”图层设置了高程(注意和上图比较不同之处)</h5><p><img src="https://img.vim-cn.com/93/d49e2a4321be61025c3400eba6061c81181611.jpg" alt></p><h5 id="1-4矢量图层-县界线-的拉伸-步骤1-3和1-4的目的是做3D场景的外围墙"><a href="#1-4矢量图层-县界线-的拉伸-步骤1-3和1-4的目的是做3D场景的外围墙" class="headerlink" title="1.4矢量图层(县界线)的拉伸 (步骤1.3和1.4的目的是做3D场景的外围墙)"></a>1.4矢量图层(县界线)的拉伸 (步骤1.3和1.4的目的是做3D场景的外围墙)</h5><p><img src="https://img.vim-cn.com/fe/293ba3d040993390156d5dcd0f3c6966cb3428.jpg" alt></p><h5 id="矢量图层-县界层-拉伸后显示效果"><a href="#矢量图层-县界层-拉伸后显示效果" class="headerlink" title="矢量图层(县界层)拉伸后显示效果"></a>矢量图层(县界层)拉伸后显示效果</h5><p><img src="https://img.vim-cn.com/36/be8d6df92d60c354aa96db456e5732b986759d.jpg" alt></p><h5 id="1-5-使用面图层（县界）设置3D场景的底面（此步骤的目的是做3D场景的“盒底”）"><a href="#1-5-使用面图层（县界）设置3D场景的底面（此步骤的目的是做3D场景的“盒底”）" class="headerlink" title="1.5 使用面图层（县界）设置3D场景的底面（此步骤的目的是做3D场景的“盒底”）"></a>1.5 使用面图层（县界）设置3D场景的底面（此步骤的目的是做3D场景的“盒底”）</h5><p><img src="https://img.vim-cn.com/a9/a7abab13291c5e076d0ccb3e3003546f6f8588.jpg" alt></p><h5 id="1-6-设置遥感影像图的显示（绘制）精度"><a href="#1-6-设置遥感影像图的显示（绘制）精度" class="headerlink" title="1.6 设置遥感影像图的显示（绘制）精度"></a>1.6 设置遥感影像图的显示（绘制）精度</h5><p><img src="https://img.vim-cn.com/2f/a9f2eb85c437e292f4053437409c6cabe27d58.jpg" alt></p><h5 id="具体设置如下："><a href="#具体设置如下：" class="headerlink" title="具体设置如下："></a>具体设置如下：</h5><p><img src="https://img.vim-cn.com/98/26511418b1cf046cd6902d62c0aa495e3ccbf5.jpg" alt></p><h5 id="显示效果：（注意和上图比较精细程度）"><a href="#显示效果：（注意和上图比较精细程度）" class="headerlink" title="显示效果：（注意和上图比较精细程度）"></a>显示效果：（注意和上图比较精细程度）</h5><p><img src="https://img.vim-cn.com/f0/b93e7aa08dad6816163bfc6ebbf8e14e42b66e.jpg" alt></p><h5 id="1-7-将3D场景导出为2D场景"><a href="#1-7-将3D场景导出为2D场景" class="headerlink" title="1.7 将3D场景导出为2D场景"></a>1.7 将3D场景导出为2D场景</h5><p><img src="https://img.vim-cn.com/f2/be5dc7fa0d92a1fbfd807e2072b3c4f2b8b0d4.jpg" alt></p><p><img src="https://img.vim-cn.com/77/be723101980a81493d0b7a0ec2793e74e23aa2.jpg" alt></p><h5 id="1-8-设置场景的背景色（如加入天空等）"><a href="#1-8-设置场景的背景色（如加入天空等）" class="headerlink" title="1.8 设置场景的背景色（如加入天空等）"></a>1.8 设置场景的背景色（如加入天空等）</h5><p><img src="https://img.vim-cn.com/c8/b96db9abb4efdb4a7c6749b50fdfb7a08ff853.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcScene </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib中文不显示问题</title>
      <link href="/2019/04/23/Matplotlib%E4%B8%AD%E6%96%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/23/Matplotlib%E4%B8%AD%E6%96%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Matplotlib中中文不显示问题"><a href="#Matplotlib中中文不显示问题" class="headerlink" title="Matplotlib中中文不显示问题"></a>Matplotlib中中文不显示问题</h2><p>我们在使用jupter进行数据分析的时候，会接触到Matplotlib这个库，它是用来进行可视化数据分析的，在一个图中，我们常常会加入一些中文来进行说明。当我们加入中文的时候会出现下图所示的样子：</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126171304928-1982592030.png" alt="img"></p><p>可以看到，中文变成了这种乱码的形式。网上有很多的例子，有很多是错误的，这里我把我测试成功的方法说明一下。</p><p>我使用的电脑系统是Window10，后面的方法也是针对它的，其他的系统应该也差距不大，可以借鉴一下。</p><a id="more"></a><h3 id="1-找一个喜欢的字体"><a href="#1-找一个喜欢的字体" class="headerlink" title="1.找一个喜欢的字体"></a>1.找一个喜欢的字体</h3><p>字体的话，我们可以去网上下载，也可以用系统自带的。我们可以进入到目录：C:\Windows\Fonts中，里面有很多字体，这里我选择了微软雅黑，这里将它复制。</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126172644334-542625206.png" alt="img"></p><h3 id="2-将字体放到默认Matplotlib默认字体目录"><a href="#2-将字体放到默认Matplotlib默认字体目录" class="headerlink" title="2.将字体放到默认Matplotlib默认字体目录"></a>2.将字体放到默认Matplotlib默认字体目录</h3><p>在我电脑中Matplotlib默认字体目录是：D:\Anaconda3\Lib\site-packages\matplotlib\mpl-data\fonts\ttf。我们将复制的微软雅黑字体粘贴到这个目录下，然后双击安装。</p><p>（因为安装的时候我修改了路径，将Anaconda安装到了D盘，如果你安装到C盘或者使用默认目录的话会有一些出入。）</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126172748235-1568497793.png" alt="img"></p><h3 id="3-用下面代码找到Matplotlib的配置文件"><a href="#3-用下面代码找到Matplotlib的配置文件" class="headerlink" title="3.用下面代码找到Matplotlib的配置文件"></a>3.用下面代码找到Matplotlib的配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">print(matplotlib.matplotlib_fname())</span><br></pre></td></tr></table></figure><p> 效果如下图：</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126172004091-1576679331.png" alt="img"></p><h3 id="4-打开步骤3中得到的文件，然后修改"><a href="#4-打开步骤3中得到的文件，然后修改" class="headerlink" title="4.打开步骤3中得到的文件，然后修改"></a>4.打开步骤3中得到的文件，然后修改</h3><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126173224483-1641500168.png" alt="img"></p><p>这里我们顺便解决一下Matplotlib中负号不显示的问题，还是修改这个文件。</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126173832737-772380232.png" alt="img"></p><h3 id="5-将Matplotlib中的缓存文件删除"><a href="#5-将Matplotlib中的缓存文件删除" class="headerlink" title="5.将Matplotlib中的缓存文件删除"></a>5.将Matplotlib中的缓存文件删除</h3><p>目录：C:\Users\用户.matplotlib中存放的是Matplotlib的缓存目录，我们只要将这个.matplotlib文件删除即可。</p><h3 id="6-重启jupyter-notebook"><a href="#6-重启jupyter-notebook" class="headerlink" title="6.重启jupyter notebook"></a>6.重启jupyter notebook</h3><p>经过上面的6步，我们的乱码问题解决了。</p><p> <img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126174308128-811831411.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
            <tag> 中文显示乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora的简单入门(Markdown基本语法)</title>
      <link href="/2019/04/19/typora/"/>
      <url>/2019/04/19/typora/</url>
      
        <content type="html"><![CDATA[<p>Typora可以根据当前文档的标题层级，自动生成并显示大纲，窗口的右下角并有字数显示。</p><h2 id="标题的使用"><a href="#标题的使用" class="headerlink" title="标题的使用"></a>标题的使用</h2><h3 id="标题的使用格式"><a href="#标题的使用格式" class="headerlink" title="标题的使用格式"></a>标题的使用格式</h3><p># 一阶标题 或者快捷键Ctrl+1</p><p>##二阶标题 或者快捷键Ctrl+2</p><p>###三阶标题 或者快捷键Ctrl+3</p><p>####四阶标题 或者快捷键Ctrl+4</p><p>#####五阶标题 或者快捷键Ctrl+5</p><p>######六阶标题 或者快捷键Ctrl+6</p><h3 id="标题Typora显示形式是"><a href="#标题Typora显示形式是" class="headerlink" title="标题Typora显示形式是"></a>标题Typora显示形式是</h3><p><img src="https://img-blog.csdn.net/20180108112546034?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h2><h3 id="文本居中使用格式"><a href="#文本居中使用格式" class="headerlink" title="文本居中使用格式"></a>文本居中使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&lt;center\&gt;这是要居中的文本内容\&lt;/center\&gt;1</span><br></pre></td></tr></table></figure><h3 id="文本居中在Typora中显示形式是"><a href="#文本居中在Typora中显示形式是" class="headerlink" title="文本居中在Typora中显示形式是"></a>文本居中在Typora中显示形式是</h3><p>这是要居中的文本</p><p>注：Typora目前并不会直接预览居中效果——相应的效果只有输出文本的时候才会显现。</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><h3 id="下划线使用格式"><a href="#下划线使用格式" class="headerlink" title="下划线使用格式"></a>下划线使用格式</h3><p>\下划线的内容\&lt;\u&gt; 或者快捷键Ctrl+U</p><h3 id="下划线在Typora显示形式是"><a href="#下划线在Typora显示形式是" class="headerlink" title="下划线在Typora显示形式是"></a>下划线在Typora显示形式是</h3><p>这就是我亲测的下划线</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><h3 id="删除线使用格式"><a href="#删除线使用格式" class="headerlink" title="删除线使用格式"></a>删除线使用格式</h3><p>~~删除线的内容~~</p><h3 id="删除线在Typora显示形式是"><a href="#删除线在Typora显示形式是" class="headerlink" title="删除线在Typora显示形式是"></a>删除线在Typora显示形式是</h3><p><del>这是删除线的内容</del></p><h2 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h2><h3 id="字体加粗使用格式"><a href="#字体加粗使用格式" class="headerlink" title="字体加粗使用格式"></a>字体加粗使用格式</h3><p><strong>加粗字体</strong> 或者快捷键Ctrl+B</p><h3 id="字体加粗在Typora显示形式是"><a href="#字体加粗在Typora显示形式是" class="headerlink" title="字体加粗在Typora显示形式是"></a>字体加粗在Typora显示形式是</h3><p><strong>加粗字体 This is a bold font</strong></p><h2 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h2><h3 id="字体倾斜使用格式"><a href="#字体倾斜使用格式" class="headerlink" title="字体倾斜使用格式"></a>字体倾斜使用格式</h3><p><em>字体倾斜了</em> 或者快捷键Ctrl+I</p><h3 id="字体倾斜在Typora的显示形式"><a href="#字体倾斜在Typora的显示形式" class="headerlink" title="字体倾斜在Typora的显示形式"></a>字体倾斜在Typora的显示形式</h3><p><em>字体倾斜了 This is a alanted font</em></p><h2 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h2><p>最简单粗暴的图片插入方式如图：</p><p><img src="https://img-blog.csdn.net/20180108113042939?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>图片来源<a href="http://support.typora.io/Images" target="_blank" rel="noopener">http://support.typora.io/Images</a></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><h3 id="超链接使用格式"><a href="#超链接使用格式" class="headerlink" title="超链接使用格式"></a>超链接使用格式</h3><p>第一种：[<a href="http://www.simba.com\](http://www.simba.com/)" target="_blank" rel="noopener">http://www.simba.com\](http://www.simba.com/)</a></p><p>第二种：快捷键Ctrl+K</p><p><a href="超链接地址">自定义内容</a> 例如：<a href="www.baidu.com">百度一下</a></p><h3 id="超链接在Typora显示形式是：（必须以http开头）"><a href="#超链接在Typora显示形式是：（必须以http开头）" class="headerlink" title="超链接在Typora显示形式是：（必须以http开头）"></a>超链接在Typora显示形式是：（必须以http开头）</h3><p>第一种：<a href="http://www.simba.com/" target="_blank" rel="noopener">http://www.simba.com</a></p><p>第二种：<a href="https://blog.csdn.net/SIMBA1949/article/details/www.baidu.com" target="_blank" rel="noopener">百度一下</a></p><p>按住Ctrl键+点击上面链接就可以直接访问该链接</p><h2 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h2><p>Typora支持对多种语言的代码区域进行<strong>语法高亮</strong>。这些语言可以说是<strong>涵盖了绝大部分经常使用的编程语言</strong>，包括C++，Python，MATLAB，甚至包含spreadsheet（也就是Excel电子表格）。用Typora记编程笔记，看起来一清二楚。如果设置代码语言为flow，那么可以直接画出一个流程图；还可以使用相应的方法画出时序图等图表。</p><h3 id="代码区域的使用格式"><a href="#代码区域的使用格式" class="headerlink" title="代码区域的使用格式"></a>代码区域的使用格式</h3><p><code></code> <code>+编程语言：例如java代码：</code> <code></code>java</p><h3 id="代码区域在typora中显示形式"><a href="#代码区域在typora中显示形式" class="headerlink" title="代码区域在typora中显示形式"></a>代码区域在typora中显示形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">simba</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我爱你，中国"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="表格的使用"><a href="#表格的使用" class="headerlink" title="表格的使用"></a>表格的使用</h2><h3 id="表格的二种使用格式"><a href="#表格的二种使用格式" class="headerlink" title="表格的二种使用格式"></a>表格的二种使用格式</h3><p>第一种：快捷键<strong>Ctrl+T</strong>，会自动跳出设置行和列的设置框，如下图</p><p><img src="https://img-blog.csdn.net/20180108113324218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>第二种：</p><p>|国籍|省份|市区|</p><h3 id="表格在typora中显示形式"><a href="#表格在typora中显示形式" class="headerlink" title="表格在typora中显示形式"></a>表格在typora中显示形式</h3><p>第一种：</p><table><thead><tr><th>国籍</th><th>省份</th><th>市区</th></tr></thead><tbody><tr><td>中国</td><td>北京</td><td>东城区</td></tr></tbody></table><p>第二种：</p><table><thead><tr><th>国籍</th><th>省份</th><th>市区</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><h3 id="任务列表使用格式"><a href="#任务列表使用格式" class="headerlink" title="任务列表使用格式"></a>任务列表使用格式</h3><p>- [ ] 文字 （注：注意用空格隔开）</p><h3 id="任务列表在typora中的显示形式"><a href="#任务列表在typora中的显示形式" class="headerlink" title="任务列表在typora中的显示形式"></a>任务列表在typora中的显示形式</h3><ul><li style="list-style: none"><input type="checkbox" checked> JAVA</li><li style="list-style: none"><input type="checkbox"> C</li><li style="list-style: none"><input type="checkbox"> C++</li><li style="list-style: none"><input type="checkbox"> Python</li></ul><p>（注意：在CSDN博客上未显示，但是在Typora上显示如下图：<br><img src="https://img-blog.csdn.net/20180108114342465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="列表的使用格式"><a href="#列表的使用格式" class="headerlink" title="列表的使用格式"></a>列表的使用格式</h3><p>+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表</p><h3 id="列表在typora中的显示形式"><a href="#列表在typora中的显示形式" class="headerlink" title="列表在typora中的显示形式"></a>列表在typora中的显示形式</h3><ul><li>java</li><li>C</li><li>C++</li><li>Python</li></ul><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>Typora支持加入用LaTeX写成的数学公式，并且在软件界面下用MathJax直接渲染。</p><p>数学公式分为两种：</p><p>一种是行内公式(inline math，可以在偏好设置中单独打开，由一个美元符号$将公式围起来；</p><p>一种是行外公式，直接 按<strong>Ctrl+Shift+M</strong>；</p><p>注：上标和下标可以使用数学表达式来获取</p><h2 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h2><h3 id="水平分割线的使用格式"><a href="#水平分割线的使用格式" class="headerlink" title="水平分割线的使用格式"></a>水平分割线的使用格式</h3><p>***或者- - -</p><h3 id="水平分割线在typora中显示形式"><a href="#水平分割线在typora中显示形式" class="headerlink" title="水平分割线在typora中显示形式"></a>水平分割线在typora中显示形式</h3><hr><hr><p>（注意：在CSDN博客上未显示，但是在Typora上显示如下图：<br><img src="https://img-blog.csdn.net/20180108114442472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>）</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的使用格式"><a href="#引用的使用格式" class="headerlink" title="引用的使用格式"></a>引用的使用格式</h3><p>>+空格</p><h3 id="引用在typora中的显示形式"><a href="#引用在typora中的显示形式" class="headerlink" title="引用在typora中的显示形式"></a>引用在typora中的显示形式</h3><blockquote><p>与天奋斗，其乐无穷！与地奋斗，其乐无穷！与人奋斗，其乐无穷！</p><p> ———— 《毛泽东选集》之《奋斗自勉》（毛泽东1917年）</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="注释的使用格式"><a href="#注释的使用格式" class="headerlink" title="注释的使用格式"></a>注释的使用格式</h3><p>要添加注释的文字[1](<a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fn:" target="_blank" rel="noopener">https://blog.csdn.net/SIMBA1949/article/details/79001226#fn:</a>)</p><h3 id="注释在typora中显示形式"><a href="#注释在typora中显示形式" class="headerlink" title="注释在typora中显示形式"></a>注释在typora中显示形式</h3><p>中国<a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fn:" target="_blank" rel="noopener">2</a></p><h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><h3 id="表情的使用格式"><a href="#表情的使用格式" class="headerlink" title="表情的使用格式"></a>表情的使用格式</h3><p>:单词</p><h3 id="表情在typora中的显示形式"><a href="#表情在typora中的显示形式" class="headerlink" title="表情在typora中的显示形式"></a>表情在typora中的显示形式</h3><p>:smiley:<br>（注意：在CSDN博客上未显示，但是在Typora上显示如下图：<br><img src="https://img-blog.csdn.net/20180108114531939?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>）</p><h2 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+1</td><td>一阶标题</td><td>Ctrl+B</td><td>字体加粗</td></tr><tr><td>Ctrl+2</td><td>二阶标题</td><td>Ctrl+I</td><td>字体倾斜</td></tr><tr><td>Ctrl+3</td><td>三阶标题</td><td>Ctrl+U</td><td>下划线</td></tr><tr><td>Ctrl+4</td><td>四阶标题</td><td>Ctrl+Home</td><td>返回Typora顶部</td></tr><tr><td>Ctrl+5</td><td>五阶标题</td><td>Ctrl+End</td><td>返回Typora底部</td></tr><tr><td>Ctrl+6</td><td>六阶标题</td><td>Ctrl+T</td><td>创建表格</td></tr><tr><td>Ctrl+L</td><td>选中某句话</td><td>Ctrl+K</td><td>创建超链接</td></tr><tr><td>Ctrl+D</td><td>选中某个单词</td><td>Ctrl+F</td><td>搜索</td></tr><tr><td>Ctrl+E</td><td>选中相同格式的文字</td><td>Ctrl+H</td><td>搜索并替换</td></tr><tr><td>Alt+Shift+5</td><td>删除线</td><td>Ctrl+Shift+I</td><td>插入图片</td></tr></tbody></table><p>注：一些实体符号需要在实体符号之前加”\”才能够显示</p><hr><ol><li>伟大的中华人民共和国万岁 <a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fnref:" target="_blank" rel="noopener">↩</a></li><li>伟大的中华人民共和国万岁 <a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fnref:" target="_blank" rel="noopener">↩</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python来撩妹吧-实时掌控她的小情绪</title>
      <link href="/2019/04/19/%E7%94%A8Python%E6%9D%A5%E6%92%A9%E5%A6%B9%E5%90%A7(1)-%E5%AE%9E%E6%97%B6%E6%8E%8C%E6%8E%A7%E5%A5%B9%E7%9A%84%E5%B0%8F%E6%83%85%E7%BB%AA/"/>
      <url>/2019/04/19/%E7%94%A8Python%E6%9D%A5%E6%92%A9%E5%A6%B9%E5%90%A7(1)-%E5%AE%9E%E6%97%B6%E6%8E%8C%E6%8E%A7%E5%A5%B9%E7%9A%84%E5%B0%8F%E6%83%85%E7%BB%AA/</url>
      
        <content type="html"><![CDATA[<p>好不容易有了女朋友，可相处起来总是磕磕碰碰。</p><p>有时候，你很想关心她，但是你太忙了，以至于她一直抱怨，觉得你不够关心她。你暗自下决心，下次一定要准时发消息给她，哪怕是几句话，可是你又忘记了。你觉得自己很委屈😭，但是她又觉得你不负责。</p><p>现在，再不用担心了，用python就可以给女友定时发提示消息了，而且不会漏过每一个关键时刻，每天早上起床、中午吃饭、晚上吃饭、晚上睡觉，都会准时发消息给她了，而且还可以让她学习英语单词哦！</p><p>在生日来临之时，自动发祝福语。在节日来临之时，比如三八妇女节、女神节、情人节、春节、圣诞节，自动发问候语哦，再也不用担心他说你没有仪式感了😀</p><p>最重要的是，可以实时知道女友的情感情绪指数，再也不用担心女友莫名其妙生气了。</p><h2 id="编写思路"><a href="#编写思路" class="headerlink" title="编写思路"></a>编写思路</h2><p>为了方便快速开发，我们使用python中的wxpy模块完成微信的基本操作。</p><p>首先，我们设置一个config.ini配置文件，并从这个配置文件开始读取信息。这些参数一看就懂，所以无需多言。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cf</span> = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">cf.read("./config.ini",encoding='UTF-8')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友的微信名称，记住，不是微信ID也不是微信备注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你女友的微信名称，记住，不是微信ID也不是微信备注</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my_lady_wechat_name</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"my_lady_wechat_name"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_morning</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_morning"</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_lunch</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_lunch"</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dinner</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_dinner"</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dream</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_dream"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友生日信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几月，注意补全数字，为两位数，比如6月必须写成06</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_month</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"birthday_month"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 几号，注意补全数字，为两位数，比如6号必须写成08</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_day</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"birthday_day"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间的随机提示语</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般这里的代码不要改动，需要增加提示语可以自己打开对应的文件修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#早上起床问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_morning</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_morning.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_morning = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_morning)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#中午吃饭问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_lunch</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_lunch.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_lunch = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_lunch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#晚上吃饭问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_dinner</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_dinner.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_dinner = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_dinner)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#晚上睡觉问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_dream</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_dream.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_dream = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_dream)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置晚上睡觉问候语是否在原来的基础上再加上每日学英语精句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># False表示否 True表示是</span></span><br><span class="line"></span><br><span class="line">if((cf.get("configuration", "flag_learn_english")) == '1'):</span><br><span class="line"></span><br><span class="line">    flag_learn_english = True</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line"></span><br><span class="line">    flag_learn_english = False</span><br><span class="line"></span><br><span class="line">print(flag_learn_english)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置所有问候语结束是否加上表情符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># False表示否 True表示是</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_emoj</span> = <span class="string">"(•‾̑⌣‾̑•)✧˖°----(๑´ڡ`๑)----(๑¯ิε ¯ิ๑)----(๑•́ ₃ •̀๑)----( ∙̆ .̯ ∙̆ )----(๑˘ ˘๑)----(●′ω`●)----(●･̆⍛･̆●)----ಥ_ಥ----_(:qゝ∠)----(´；ω；`)----( `)3')----Σ((( つ•̀ω•́)つ----╰(*´︶`*)╯----( ´´ิ∀´ิ` )----(´∩｀。)----( ื▿ ื)----(｡ŏ_ŏ)----( •ิ _ •ิ )----ヽ(*΄◞ิ౪◟ิ‵ *)----( ˘ ³˘)----(; ´_ゝ`)----(*ˉ﹃ˉ)----(◍'౪`◍)ﾉﾞ----(｡◝‿◜｡)----(ಠ .̫.̫ ಠ)----(´◞⊖◟`)----(。≖ˇェˇ≖｡)----(◕ܫ◕)----(｀◕‸◕´+)----(▼ _ ▼)----( ◉ืൠ◉ื)----ㄟ(◑‿◐ )ㄏ----(●'◡'●)ﾉ♥----(｡◕ˇ∀ˇ◕）----( ◔ ڼ ◔ )----( ´◔ ‸◔`)----(☍﹏⁰)----(♥◠‿◠)----ლ(╹◡╹ლ )----(๑꒪◞౪◟꒪๑)"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_emoj</span> = str_emoj.split(<span class="string">'----'</span>)</span><br><span class="line"></span><br><span class="line">if ((cf.get("configuration", "flag_wx_emoj")) == '1'):</span><br><span class="line"></span><br><span class="line">    flag_wx_emoj = True</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line"></span><br><span class="line">    flag_wx_emoj = False</span><br><span class="line"></span><br><span class="line">print(str_list_emoj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置节日祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情人节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Valentine</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Valentine"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Valentine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三八妇女节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Women</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Women"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Women)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平安夜祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas_Eve</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Christmas_Eve"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Christmas_Eve)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圣诞节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Christmas"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Christmas)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 她生日的时候的祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_birthday</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_birthday"</span>)</span><br><span class="line"></span><br><span class="line">print(str_birthday)</span><br></pre></td></tr></table></figure><p>如果你愿意，可以在上面对时间的判断中，加入一些其他你想要的，这样你女友就更开心啦！后期如果有时间，我将会加上以上节日问候功能。😀</p><p>接着，开启微信机器人，为了程序的健壮性，自动判断一下操作系统，根据不同操作系统执行不同指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动微信机器人，自动根据操作系统执行不同的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows系统或macOS Sierra系统使用bot = Bot()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linux系统或macOS Terminal系统使用bot = Bot(console_qr=2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'Windows'</span> <span class="keyword">in</span> platform.system()):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Windows</span></span><br><span class="line"></span><br><span class="line">    bot = Bot()</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>(<span class="string">'Darwin'</span> <span class="keyword">in</span> platform.system()):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># MacOSX</span></span><br><span class="line"></span><br><span class="line">    bot = Bot()</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>(<span class="string">'Linux'</span> <span class="keyword">in</span> platform.system()):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Linux</span></span><br><span class="line"></span><br><span class="line">    bot = Bot(console_qr=<span class="number">2</span>,cache_path=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自行确定</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"无法识别你的操作系统类型，请自己设置"</span>)</span><br></pre></td></tr></table></figure><p>设置完相关参数以后，我们再来学习一下，如何每天教女友学英语：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取每日励志精句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_message</span><span class="params">()</span>:</span></span><br><span class="line">    r = requests.get(<span class="string">"http://open.iciba.com/dsapi/"</span>)</span><br><span class="line">    note = r.json()[<span class="string">'note'</span>]</span><br><span class="line">    content = r.json()[<span class="string">'content'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> note, content</span><br></pre></td></tr></table></figure><p>只有每天的问候和节日问候是仅仅不够的，我们必须时刻知道她的情绪指数，这里可以使用snowNlp或者jieba来做分析，但是为了能够在打包成exe可执行文件时使得程序尽可能小，我们采取直接调用接口的方式来做。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收女友消息监听器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 女友微信名</span></span><br><span class="line"></span><br><span class="line">my_girl_friend = bot.friends().search(my_lady_wechat_name)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># chats=my_girl_friend 表示接收消息的对象，也就是女友</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># except_self=False 表示同时也接收自己发的消息，不需要接收自己消息的可以去掉</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@bot.register(chats=my_girl_friend, except_self=False)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_others</span><span class="params">(msg)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出聊天内容</span></span><br><span class="line"></span><br><span class="line">    print(msg.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 做极其简单的情感分析</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果仅供参考，请勿完全相信</span></span><br><span class="line"></span><br><span class="line">    postData = &#123;<span class="string">'data'</span>:msg.text&#125;</span><br><span class="line"></span><br><span class="line">    response = post(<span class="string">'https://bosonnlp.com/analysis/sentiment?analysisType='</span>,data=postData)</span><br><span class="line"></span><br><span class="line">    data = response.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 情感评分指数(越接近1表示心情越好，越接近0表示心情越差)</span></span><br><span class="line"></span><br><span class="line">    now_mod_rank = (data.split(<span class="string">','</span>)[<span class="number">0</span>]).replace(<span class="string">'[['</span>,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">   print(<span class="string">"来自女友的消息:%s\n当前情感得分:%s\n越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！\n\n"</span> % (msg.text, now_mod_rank))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送信息到文件传输助手</span></span><br><span class="line"></span><br><span class="line">   mood_message = <span class="string">u"来自女友的消息:"</span> + msg.text + <span class="string">"\n当前情感得分:"</span> + now_mod_rank + <span class="string">"\n越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！\n\n"</span></span><br><span class="line"></span><br><span class="line">    bot.file_helper.send(mood_message)</span><br></pre></td></tr></table></figure><p>教完女友学英语后，开始把我们的关心语发给她。这里涉及到wxpy模块的相关操作，很简单，看我的例子就会了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送消息给她</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(your_message)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对方的微信名称</span></span><br><span class="line"></span><br><span class="line">        my_friend = bot.friends().search(my_lady_wechat_name)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送消息给对方</span></span><br><span class="line"></span><br><span class="line">        my_friend.send(your_message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 出问题时，发送信息到文件传输助手</span></span><br><span class="line"></span><br><span class="line">        bot.file_helper.send(<span class="string">u"守护女友出问题了，赶紧去看看咋回事~"</span>)</span><br></pre></td></tr></table></figure><p>最后，就是如何每天定时发关心语给女友的问题了。首先来个while循环，365天无限关心😀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来个死循环，24小时关心她</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 提示</span></span><br><span class="line"></span><br><span class="line">       print(<span class="string">"守护中，时间:%s"</span>% time.ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 每天定时问候，早上起床，中午吃饭，晚上吃饭，晚上睡觉</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 获取时间，只获取时和分，对应的位置为倒数第13位到倒数第8位</span></span><br><span class="line"></span><br><span class="line">       now_time = time.ctime()[<span class="number">-13</span>:<span class="number">-8</span>]</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (now_time == say_good_morning):</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 随机取一句问候语</span></span><br><span class="line"></span><br><span class="line">           message = choice(str_list_good_morning)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment"># 是否加上随机表情</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(flag_wx_emoj):</span><br><span class="line"></span><br><span class="line">               message = message + choice(str_list_emoj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           send_message(message)</span><br><span class="line"></span><br><span class="line">           print(<span class="string">"提醒女友早上起床:%s"</span> % time.ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># …………这下面还有很多代码，我就不列出来了…………</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 延时60秒</span></span><br><span class="line"></span><br><span class="line">       time.sleep(<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>最后，输入以下代码开始守护女友模式吧~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始守护女友</span></span><br><span class="line"></span><br><span class="line">   t = Thread(target=start_care, name=<span class="string">'start_care'</span>)</span><br><span class="line"></span><br><span class="line">   t.start()</span><br></pre></td></tr></table></figure><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p><strong>pip安装下列包：</strong></p><ul><li style="list-style: none"><input type="checkbox" checked> pip install wxpy</li><li style="list-style: none"><input type="checkbox" checked> pip install requests</li></ul><p><strong>设置以下内容：</strong></p><p>config.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[configuration]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友的微信名称，记住，不是微信ID也不是微信备注</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my_lady_wechat_name</span> = 小强子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友生日信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若某一项月份或者日期不想设置，请输入99，不能留空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几月，注意补全数字，为两位数，比如6月必须写成06</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_month</span> = <span class="number">03</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几号，注意补全数字，为两位数，比如6号必须写成08</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_day</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若某一项时间不想设置，请输入99:00，不能留空</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_morning</span> = <span class="number">03</span>:<span class="number">09</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_lunch</span> = <span class="number">03</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dinner</span> = <span class="number">03</span>:<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dream</span> = <span class="number">03</span>:<span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置晚上睡觉问候语是否在原来的基础上再加上每日学英语精句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1表示是，0表示否</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flag_learn_english</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置所有问候语结束是否加上表情符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1表示是，0表示否</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flag_wx_emoj</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置节日祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情人节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Valentine</span> = 亲爱的，情人节快乐！我想和你一起分享生命中的每一天，直到永远。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三八妇女节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Women</span> = 嘿，女神节到了，祝我的女神开心快乐！你每天都是那么好看^_^</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平安夜祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas_Eve</span> = 宝贝，平安夜快乐，你吃苹果了吗？n(*≧▽≦*)n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 圣诞节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas</span> = 小仙女，圣诞节快乐哦！（づ￣<span class="number">3</span>￣）づ╭❤～</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 她生日的时候的祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_birthday</span> = 亲爱的，生日快乐，我已经给你准备好了礼物哦，明天你就能看到啦！(*@ο@*) 哇～</span><br></pre></td></tr></table></figure><h2 id="完整代码下载"><a href="#完整代码下载" class="headerlink" title="完整代码下载:"></a>完整代码下载:</h2><p><a href="https://github.com/llqing/Guardian-of-girlfriend.git" target="_blank" rel="noopener">https://github.com/llqing/Guardian-of-girlfriend.git</a></p><h2 id="演示图片"><a href="#演示图片" class="headerlink" title="演示图片"></a>演示图片</h2><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095634fescbfaccax777aa.jpg" weight="620" height="993"></p><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095635mgnnooldeqlqkshd.jpg" weight="620" height="993"></p><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095636u1vkrnkkkyjzgo2m.jpg" alt></p><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095637jovs995vwj7lvsvs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 好玩的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 撩妹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/04/14/Redis/"/>
      <url>/2019/04/14/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="一-是什么"><a href="#一-是什么" class="headerlink" title="一. 是什么?"></a>一. 是什么?</h2><blockquote><p>redis是一款优秀的nosql（非关系型），key-vlaue,内存级别的数据库！redis是单线程,操作是安全的！<br>关系型:用一张二维表格来表示和存储现实生活中对象的这一类数据库。 oracle ，mysql<br>非关系型（nosql）:不用二维表格，比如key-value ,文档等数据.Redis,MongoDB ,Hadoop</p></blockquote><h2 id="二-特点"><a href="#二-特点" class="headerlink" title="二. 特点"></a>二. 特点</h2><blockquote><p>1.Redis支持数据的持久化，会根据一定的策略持久化到磁盘,即使断电也不会丢失数据.<br>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>3.Redis支持数据的备份，即master-slave模式的数据备份。</p></blockquote><h2 id="三-数据及应用场景"><a href="#三-数据及应用场景" class="headerlink" title="三. 数据及应用场景"></a>三. 数据及应用场景</h2><blockquote><p>1.String : string是redis最基本的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如图片或者序列化的对象。String类型是Redis最基本的数据类型，一个键最大能存储512MB。<br>常用命令:<br>① get、获取存储在指定键中的值<br>② set、设置存储在指定键中的值<br>③ del、删除存储在指定键中的值（这个命令可以用于所有的类型）<br>使用场景:利用incr生成id,decr减库存, 缓存–过期时间设置，模拟session</p></blockquote><p>-</p><blockquote><p>2.list: Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>常用命令：<br>① rpush、将给定值推入列表的右端<br>② lrange、获取列表在指定范围上的所有值<br>③ lindex、获取列表在指定范围上的单个元素<br>使用场景: 多任务调度队列</p></blockquote><p>-</p><blockquote><p>3.set: Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。<br>常用命令：<br>①sadd、将给定元素添加到集合<br>②smembers、返回集合包含的所有元素<br>③sismember、检查指定元素是否存在于集合中<br>使用场景: 微博关注数</p></blockquote><p>-</p><blockquote><p>4.hash : Redis hash 是一个键值(key=&gt;value)对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>常用命令：<br>①hset、在散列里面关联起指定的键值对<br>②hget、获取指定散列键的值<br>③hgetall、获取散列包含的所有键值对<br>④hdel、如果给定键存在于散列里面，那么移除这个键<br>使用场景:购物车</p></blockquote><p>-</p><blockquote><p>5.zset: Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。<br>常用命令：<br>①zadd、将一个带有给定分值的成员添加到有序集合里面<br>②zrange、根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>③zrangebyscore、获取有序集合在给定分值范围内的所有元素 ④zrem、如果指定成员存在于有序集合中，那么移除这个成员<br>使用场景:排行榜</p></blockquote><h2 id="四-持久化"><a href="#四-持久化" class="headerlink" title="四:持久化"></a>四:持久化</h2><blockquote><ol><li>rdb 快照:默认redis是会以快照的形式将数据持久化到磁盘的（一个二进制文件，dump.rdb，这个文件名字可以指定），在配置文件(redis.conf)中的格式是：save<br>N M表示在N秒之内，redis至少发生M次修改则redis抓快照到磁盘。当然我们也可以手动执行save或者bgsave（异步）做快照。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  #################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Save the DB on disk:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment">#   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Note: you can disable saving at all commenting all the "save" lines.</span></span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">1000012345678910111213141516171819</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>aof 命令副本: AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li></ol></blockquote><h2 id="五-优点"><a href="#五-优点" class="headerlink" title="五. 优点"></a>五. 优点</h2><blockquote><p>1.性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br>2.丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br>3.原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。<br>4.丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p></blockquote><h2 id="六-访问"><a href="#六-访问" class="headerlink" title="六.访问"></a>六.访问</h2><p>Java访问redis:</p><blockquote><p>1.使用jedisjava客户端来访问redis服务器,优点类似jdbc访问db一样<br>2.如果是spring进行集成时,可以使用springDataRedis来访问redis , springDataRedis 只是对jedis的二次封装</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法（1）——冒泡排序算法详解</title>
      <link href="/2019/04/14/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/14/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>基本思想</strong></li></ol><p>冒泡排序的基本思想就是：从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。</p><p>算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。</p><ol start="2"><li><strong>运行过程</strong></li></ol><p>冒泡排序算法的运作如下：</p><p>1、比较相邻的元素。如果第一个比第二个大（小），就交换他们两个。</p><p>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大（小）的数。</p><p>3、针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。</p><p>4、持续每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序。</p><p><img src="https://img-blog.csdn.net/20160316103848750" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):  <span class="comment"># 这个循环负责设置冒泡排序进行的次数</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums) - i - <span class="number">1</span>):  <span class="comment"># j为列表下标</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">print(bubble_sort([<span class="number">45</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">97</span>]))</span><br><span class="line"><span class="comment"># 输出：[8, 12, 19, 22, 32, 33, 45, 97]</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>算法变种</strong></li></ol><p>鸡尾酒排序又叫定向冒泡排序，搅拌排序、来回排序等，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p><p>鸡尾酒排序在于排序过程是先从低到高，然后从高到低；而冒泡排序则仅从低到高去比较序列里的每个元素。它可以得到比冒泡排序稍微好一点的效能，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环只移动一个项目。</p><p>以序列(2,3,4,5,1)为例，鸡尾酒排序只需要从低到高，然后从高到低就可以完成排序，但如果使用冒泡排序则需要四次。</p><p>但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cocktail_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = left; j &lt; right; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">for</span> (j = right; j &gt; left; j--)</span><br><span class="line"><span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">swap(arr[j - <span class="number">1</span>], arr[j]);</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>性能分析</strong></li></ol><ul><li><p>时间复杂度</p><p>在设置标志变量之后：</p><p>当原始序列“正序”排列时，冒泡排序总的比较次数为n-1，移动次数为0，也就是说冒泡排序在最好情况下的时间复杂度为O(n)；</p><p>当原始序列“逆序”排序时，冒泡排序总的比较次数为n(n-1)/2，移动次数为3n(n-1)/2次，所以冒泡排序在最坏情况下的时间复杂度为O(n^2)；</p><p>当原始序列杂乱无序时，冒泡排序的平均时间复杂度为O(n^2)。</p></li><li><p>空间复杂度</p><p>冒泡排序排序过程中需要一个临时变量进行两两交换，所需要的额外空间为1，因此空间复杂度为O(1)。</p></li><li><p>稳定性</p><p>冒泡排序在排序过程中，元素两两交换时，相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python：类属性，实例属性，私有属性与静态方法，类方法，实例方法</title>
      <link href="/2019/04/14/python%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/14/python%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Python：类属性，实例属性，私有属性与静态方法，类方法，实例方法 </span><br><span class="line">属性分为实例属性与类属性</span><br><span class="line"></span><br><span class="line">方法分为普通方法，类方法，静态方法</span><br><span class="line"></span><br><span class="line">一：属性：</span><br><span class="line"></span><br><span class="line">　　尽量把需要用户传入的属性作为实例属性，而把同类都一样的属性作为类属性。实例属性在每创造一个实例时都会初始化一遍，不同的实例的实例属性可能不同，不同实例的类属性都相同。从而减少内存。</span><br><span class="line"></span><br><span class="line">　　<span class="number">1</span>：实例属性：</span><br><span class="line"></span><br><span class="line">　　　　最好在init(self,…)中初始化</span><br><span class="line"></span><br><span class="line">　　　　内部调用时都需要加上self.</span><br><span class="line"></span><br><span class="line">　　　　外部调用时用instancename.propertyname</span><br><span class="line"></span><br><span class="line">　　<span class="number">2</span>:类属性：</span><br><span class="line"></span><br><span class="line">　　　　在init()外初始化</span><br><span class="line"></span><br><span class="line">　　　　在内部用classname.类属性名调用</span><br><span class="line"></span><br><span class="line">　　　　外部既可以用classname.类属性名又可以用instancename.类属性名来调用</span><br><span class="line"></span><br><span class="line">　　<span class="number">3</span>：私有属性：</span><br><span class="line"></span><br><span class="line">　　　　<span class="number">1</span>）：单下划线_开头：只是告诉别人这是私有属性，外部依然可以访问更改</span><br><span class="line"></span><br><span class="line">　　　　<span class="number">2</span>）：双下划线__开头：外部不可通过instancename.propertyname来访问或者更改</span><br><span class="line"></span><br><span class="line">　　　　　　实际将其转化为了_classname__propertyname</span><br><span class="line"></span><br><span class="line">二：方法</span><br><span class="line"></span><br><span class="line">　　<span class="number">1</span>：普通类方法：</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">def</span> <span class="title">fun_name</span><span class="params">(self,…)</span>:</span></span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">　　　　外部用实例调用</span><br><span class="line"></span><br><span class="line">　　<span class="number">2</span>：静态方法：@staticmethod</span><br><span class="line"></span><br><span class="line">　　　　　　不能访问实例属性！！！ 参数不能传入self！！！</span><br><span class="line"></span><br><span class="line">　　　　　　与类相关但是不依赖类与实例的方法！！</span><br><span class="line"></span><br><span class="line">　　<span class="number">3</span>:类方法：@classmethod</span><br><span class="line"></span><br><span class="line">　　　　　　不能访问实例属性！！！ 参数必须传入cls！！！</span><br><span class="line"></span><br><span class="line">　　　　　　必须传入cls参数（即代表了此类对象—–区别——self代表实例对象），并且用此来调用类属性：cls.类属性名</span><br><span class="line"></span><br><span class="line">　　*静态方法与类方法都可以通过类或者实例来调用。其两个的特点都是不能够调用实例属性</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 属性 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArcGIS API for JavaScript 入门教程(3)-你看得到：数据与视图分离</title>
      <link href="/2019/04/13/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-3-%E4%BD%A0%E7%9C%8B%E5%BE%97%E5%88%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%86%E5%9B%BE%E5%88%86%E7%A6%BB/"/>
      <url>/2019/04/13/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-3-%E4%BD%A0%E7%9C%8B%E5%BE%97%E5%88%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%86%E5%9B%BE%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇开始正式讲API。</p><p>数据和视图分离不是什么奇怪的事情了，这是一个著名的设计——数据与视图分开。</p></blockquote><p>请跟我做，把以下折叠的代码复制到新建的html文件中，并双击打开。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Intro to MapView - Create a 2D map - 4.7<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    html,</span></span><br><span class="line"><span class="undefined">    body,</span></span><br><span class="line"><span class="undefined">    #viewDiv &#123;</span></span><br><span class="line"><span class="undefined">      padding: 0; margin: 0;</span></span><br><span class="line"><span class="undefined">      height: 100%; width: 100%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://js.arcgis.com/4.7/esri/css/main.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://js.arcgis.com/4.7/"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    require([</span></span><br><span class="line"><span class="undefined">      "esri/Map","esri/views/MapView","dojo/domReady!"</span></span><br><span class="line"><span class="undefined">    ], function(Map, MapView) &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      var map = new Map(&#123;</span></span><br><span class="line"><span class="undefined">        basemap: "streets"</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      var view = new MapView(&#123;</span></span><br><span class="line"><span class="undefined">        container: "viewDiv",</span></span><br><span class="line"><span class="undefined">        map: map,</span></span><br><span class="line"><span class="undefined">        zoom: 4,</span></span><br><span class="line"><span class="undefined">        center: [15, 65] // longitude, latitude</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"viewDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大概是这样：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180523235618331-1247825520.png" alt="img"></p><p>打开后是这样的：</p><p>（环境说明：Chrome 65浏览器）</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180523235659575-1878304213.png" alt="img"></p><p>那我们再复制另一个代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Intro to SceneView - Create a 3D map - 4.7<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    html,</span></span><br><span class="line"><span class="undefined">    body,</span></span><br><span class="line"><span class="undefined">    #viewDiv &#123;</span></span><br><span class="line"><span class="undefined">      padding: 0;</span></span><br><span class="line"><span class="undefined">      margin: 0;</span></span><br><span class="line"><span class="undefined">      height: 100%;</span></span><br><span class="line"><span class="undefined">      width: 100%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://js.arcgis.com/4.7/esri/css/main.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://js.arcgis.com/4.7/"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    require([</span></span><br><span class="line"><span class="undefined">      "esri/Map",</span></span><br><span class="line"><span class="undefined">      "esri/views/SceneView",</span></span><br><span class="line"><span class="undefined">      "dojo/domReady!"</span></span><br><span class="line"><span class="undefined">    ], function(Map, SceneView) &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      var map = new Map(&#123;</span></span><br><span class="line"><span class="undefined">        basemap: "streets",</span></span><br><span class="line"><span class="undefined">        ground: "world-elevation"</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      var view = new SceneView(&#123;</span></span><br><span class="line"><span class="undefined">        container: "viewDiv",</span></span><br><span class="line"><span class="undefined">        map: map,</span></span><br><span class="line"><span class="undefined">        scale: 50000000,</span></span><br><span class="line"><span class="undefined">        center: [-101.17, 21.78]</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"viewDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到的结果是：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180523235927632-1266833964.png" alt="img"></p><h1 id="1-解释"><a href="#1-解释" class="headerlink" title="1. 解释"></a>1. 解释</h1><p>本着能不解释代码就不解释代码的精神，我先给大家讲一下我讲这个JsAPI的思路。</p><p>它分五个主要学习的部分：</p><ul><li>数据</li><li>视图</li><li>空间分析</li><li>符号渲染</li><li>小部件</li></ul><p>其他不说不代表不会用到，但是相对于入门而言，这五个部分足够了。其重点讲解前三部分。</p><p>如果看文字不舒服，那么上个结构图：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524193502413-859382166.png" alt="img"></p><p>而上面两个案例，拿同一份数据结合二三维视图作了展示。</p><p>抛开代码细节（如入口、引用、页面组织、样式等）不谈，我首先把代码中用于表示“数据”和“视图”的Js代码抽取出来：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524194308611-2083837347.png" alt="img"></p><p>左边是二维的，右边是三维的。</p><p>分别用两个对象来描述“数据”和“视图”，</p><p><strong>用Map类实例出来的【map对象】以描述数据；用MapView类、SceneView类实例出来的【view对象】以描述视图</strong>。</p><p>那么你可能会问了，倘若已经在代码里做出来了数据与视图，有什么桥梁可以连接它们呢？我们把view的代码展开。</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524194641686-280020319.png" alt="img"></p><p>我们知道，在Js中通过new关键字实例化一个类，SceneView类的构造函数指定了一个Js中的Object对象作为参数，这个Object对象是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    container: "viewDiv",</span><br><span class="line">    map: map,</span><br><span class="line">    scale: 50000000,</span><br><span class="line">    center: [-101.17, 21.78]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，就有一个Map类型的属性叫map，将上面实例化的map对象赋予给它就实现了视图（SceneView、MapView）与数据（Map）的连接。</p><p>其他的属性我们暂且不管，至少，在Js代码中，我们知道了哪些代码用于构造地理数据——用Map类、我们知道了哪些代码用于构造视图——View类。</p><blockquote><p>哦对了，SceneView和MapView都继承自View类。虽然我们知道Js是弱类型的语言，但是Dojo帮我们做了一些面向对象的工作。</p><p>在这里，我沿用更广泛的说法，那就是用“类”这个称呼去替代官方的“模块”这个称呼，其实MapView、Map、SceneView都是模块，它们存在于js包里面。</p></blockquote><h1 id="2-补充"><a href="#2-补充" class="headerlink" title="2. 补充"></a>2. 补充</h1><p>如果上面看得懂，这里可以作为补充材料来阅读。</p><h2 id="2-1-数据如何组织"><a href="#2-1-数据如何组织" class="headerlink" title="2.1 数据如何组织"></a>2.1 数据如何组织</h2><p>相信肯定有筒子开始疑问Map对象的构造参数中应该如何组织属性了吧，这个时候就需要去查示例代码和官方API参考了。</p><p>我可以简单说一说。先看一下这个类的继承关系图：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524200353650-538894986.png" alt="img"></p><p>清晰看到Map类的位置。</p><p>有趣的是，Map有WebMap和WebScene两个子类，由于继承和多态的特征，说明视图中map属性也可以设为WebMap和WebScene。</p><p>这有什么区别呢？暂且不说后期展开。</p><p>再展开Map类的属性：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524205007659-924807109.png" alt="img"></p><p>常用的有三个属性，底图、可操作图层集合、地形图层。</p><ol><li>basemap属性可使用预置的底图，也可以使用自定义的Basemap对象；</li><li><strong>[★]</strong>layers属性是<strong>可操作的Layer对象</strong>的集合，Layer类有很多子类，如几何图层、地图图层、要素图层等，这些到以后会讲，这些<strong>都是赤果果的数据组成啊</strong>！</li><li>ground属性表示地图高程，可以用预置的世界高程数据，也可以自定义高程图层，后期会讲。</li></ol><p>哦对了，对<strong>数据的在线简单编辑、绘制</strong>，也是由数据部分组织的，后面展开。</p><h2 id="2-2-视图有什么用"><a href="#2-2-视图有什么用" class="headerlink" title="2.2 视图有什么用"></a>2.2 视图有什么用</h2><p>视图是管理“看得到”的东西的。</p><p>其一，我们看得到的二三维地图、场景都是由它渲染的；</p><p>其二，我们需要对数据进行展示时，是由它进行弹窗（Popup）展示的；</p><p>这些业务和数据无关，任何一份数据都可以由视图进行前端渲染、数据展示，所以被抽取出来了，做到了高内聚低耦合、数据视图分离。</p><hr><p>好啦，到这里，“数据”与“视图”已经有了个大概的了解了，下一篇将开始讲解如何代码入门，可以学一下Dojo用于预习，尤其是Dojo的模块化。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcGIS </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArcGIS API for JavaScript 入门教程(2)-授人以渔</title>
      <link href="/2019/04/09/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-2-%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94/"/>
      <url>/2019/04/09/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-2-%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94/</url>
      
        <content type="html"><![CDATA[<p>这篇仍然不讲怎么做，但是我要告诉你如何获取资源。</p><h1 id="1-官方在线帮助、示例代码及入门导航"><a href="#1-官方在线帮助、示例代码及入门导航" class="headerlink" title="1. 官方在线帮助、示例代码及入门导航"></a>1. 官方在线帮助、示例代码及入门导航</h1><p>JsAPI最新版首页：<a href="https://developers.arcgis.com/javascript/" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/</a></p><p>JsAPI最新版在线帮助（模块查询）：<a href="https://developers.arcgis.com/javascript/latest/api-reference/index.html" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/latest/api-reference/index.html</a></p><p>JsAPI最新版示例代码：<a href="https://developers.arcgis.com/javascript/latest/sample-code/index.html" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/latest/sample-code/index.html</a></p><p>JsAPI最新版入门导航：<a href="https://developers.arcgis.com/javascript/latest/guide/index.html" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/latest/guide/index.html</a></p><h1 id="2-ArcGIS-Runtime-SDKs家族"><a href="#2-ArcGIS-Runtime-SDKs家族" class="headerlink" title="2. ArcGIS Runtime SDKs家族"></a>2. ArcGIS Runtime SDKs家族</h1><p>地址：<a href="https://developers.arcgis.com/" target="_blank" rel="noopener">https://developer.arcgis.com</a></p><p>文档：<a href="https://developers.arcgis.com/documentation/" target="_blank" rel="noopener">https://developers.arcgis.com/documentation/</a></p><p>Github地址：<a href="http://esri.github.io/" target="_blank" rel="noopener">http://esri.github.io/</a></p><p>文档处也有很多好东西，有机会也要做翻译。</p><h1 id="3-获取API和SDK"><a href="#3-获取API和SDK" class="headerlink" title="3. 获取API和SDK"></a>3. 获取API和SDK</h1><p>Runtime SDK家族API和SDK和文档：<a href="https://developers.arcgis.com/downloads/apis-and-sdks" target="_blank" rel="noopener">https://developers.arcgis.com/downloads/apis-and-sdks</a></p><h1 id="4-善用搜索引擎"><a href="#4-善用搜索引擎" class="headerlink" title="4. 善用搜索引擎"></a>4. 善用搜索引擎</h1><p>如果百度/必应不到，请用谷歌，总有你需要的。</p><p>——————————————————————————</p><p>最后说个事，教程和笔记</p><p>好多人混淆了教程和笔记。教程是力求别人能看懂，尽可能抓重点和抓主干讲，无关痛痒的不要讲太多。所以，此入门教程，我打算10来篇博客讲完，细致的可以自己慢慢学的，毕竟更新如此之快，我自己也在不断学习。</p><p>而笔记，自己看得懂就行了，好多人挂着教程写的笔记哦…笔记是自己反复琢磨用的。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcGIS </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArcGIS API for JavaScript入门教程(1)-前戏</title>
      <link href="/2019/04/07/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-1-%E5%89%8D%E6%88%8F/"/>
      <url>/2019/04/07/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-1-%E5%89%8D%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>-&gt;对于萌新，你可能需要了解一下这个东西是什么</li><li>-&gt;对于已经知道要用这个东西的开发者，你可能需要了解一下它的底层机制</li><li>不针对大牛。龟速更新ing.</li></ul></blockquote><h1 id="1-是什么【萌新别跳这一步】"><a href="#1-是什么【萌新别跳这一步】" class="headerlink" title="1. 是什么【萌新别跳这一步】"></a>1. 是什么【萌新别跳这一步】</h1><p><em>如果非萌新，可以跳过这一段文字。</em></p><p>想要知道ArcGIS API for JavaScript是什么，我大概用以下几条条目描述：</p><ul><li>是一个WebGIS二次开发（如果不知道什么是WebGIS请用搜索引擎···）的前端开发包，使用JavaScript语言</li><li>出自美国Esri公司</li><li>是Esri的ArcGIS Runtime SDK家族中的一员</li><li>它不是纯Js写的库</li></ul><p>能说明什么呢？</p><ol><li>它能制作在线地理信息系统平台，能做数据分析、空间分析、数据展示等；</li><li>歪果仁写的，英文资料多，虽然中文也有一定数量的资料（博客、书籍等），但是呢，由于Esri更新贼快，一年三四更的，中文资料不一定跟得上速度；</li><li>你可能需要学很多附属的东西，这个API很庞大、很笨重，入门门槛其实不高，但是深入难，前端上，你得知道造这个API的基础——Dojo框架，而Dojo框架由于历史渊源，又来自从属AMD（异步模块定义）规范的RequireJs，要想了解AMD，又不得不去看一些前端和后端的发展史，甚至不可避免要学一些基础的后端。</li></ol><p>如果你做好了这些准备，继续。</p><p>哦对了，这个API当前有两个大支线，一个是3.x版本，一个是4.x版本；</p><p>3.x版本已经很成熟，用于2D的WebGIS二次开发很完美，如果你用的是ArcGIS整套产品；</p><p>我重点讲一下类和模块经过重新构造、较为简单的4.x版本，因为它最大的特征是数据视图分离、支持3D，旗帜鲜明对接ArcGIS Pro.</p><h1 id="2-我必须学它吗？"><a href="#2-我必须学它吗？" class="headerlink" title="2. 我必须学它吗？"></a>2. 我必须学它吗？</h1><p>如果你的项目需求很大，大量用到空间分析、三维展示，频繁交互ArcGIS家族的产品（Server、ArcGIS Desktop等），请学；</p><p>如果你的项目需求比较小，也可以学，当然也可以有别的选择：</p><ul><li>开源解决方案：Openlayers/Leaflets替代JsAPI。</li></ul><p>Openlayers和Leaflets同样是WebGIS二次开发工具包，排名很靠前，二者区别是ol自己提供了封装好的功能模块，而lf则支持插件式，它的插件很多。他们都支持npm方式引入。</p><ul><li>当然，为了实现简单的三维GIS，Cesium了解一下；</li><li>如果只是3D数据展示，ThreeJs了解一下；</li><li>如果数据源缺乏，不想自己做数据服务，对WebGIS标准缺少耐心，可以试试高德地图API、百度地图API等。</li><li>如果想全开源，就目前而言3DGIS还是ArcGIS最强外，传统二维WebGIS可以用QGIS代替ArcGIS Desktop、用PostgreSQL代替Geodatabase、用GeoServer代替ArcGIS for Server。</li></ul><p>使用JsAPI最强大的特征就是真三维空间分析+无比强大的ArcTools工具箱了。</p><h1 id="3-学习此API需要些什么"><a href="#3-学习此API需要些什么" class="headerlink" title="3. 学习此API需要些什么"></a>3. 学习此API需要些什么</h1><p>熟练HTML 5的学习方式、熟练CSS 3的学习方式、能自我学习JavaScript，最好有一定的GIS基础知识、一定的数学知识。</p><p>我们在这里约定</p><p>ArcGIS API for JavaScript = jsapi/JsAPI/jsAPI…</p><p>你可能还要学习的是：</p><ul><li>NodeJs与npm（在4.7及3.24版本后可能要用npm下载）——作备选项，不学也无所谓</li><li>webpack——上面那俩如果你学了，这个肯定要学了。</li><li>英语</li></ul><p>对了，你不需要学怎么配置本地环境（就是说用官方的在线API进行学习就好了），我觉得那些东西网上太多了，查一下就行。有可能遇到跨域的问题，你也可以问搜索引擎，这里更关注的是“入门”而不是全面、细节，我需要把你快速带入门，之后看你的造化。</p><h1 id="4-它怎么来的"><a href="#4-它怎么来的" class="headerlink" title="4. 它怎么来的"></a>4. 它怎么来的</h1><p>它基于一个更复杂的前端框架，Dojo.js。</p><p>除了当前两条支线3.x和4.x，其实早些年还有过ArcGIS API for Sliverlight和ArcGIS API for Flex，当然他们已经退休了。</p><p>JavaScript那么火热，自然而然选他啦。</p><p>由于GIS数据模型的复杂性，和普通的Web信息系统不同，面向对象的机制更合适去描述GIS数据和GIS分析。当时，没有别的好选择，只能选Dojo，因为它支持许多符合WebGIS的特性，如异步操作、面向对象等。</p><p>现如今，基于Node的包管理模式的前端开发早已不是什么难事，甚至还冒出了MVVM框架的一大堆火热框架。老迈的Dojo框架不能很好地融入其中，这让人很无奈。</p><p>在JsAPI中，地图可以是一个模块，图层可以是一个模块，一个用于空间分析的“东西”也可以是一个模块。类似于桌面编程中的类、继承机制，AMD规范下的RequireJs就产生了。Dojo基于此，定制了一大批的有用模块，能做图表，能做页面，能读写DOM，能做动画，当然是你需要什么模块就调用什么模块，并不需要一次性全部加载。JsAPI基于Dojo，定制了各个方面的模块，从而向开发者提供了一套强大的WebGIS二次开发包。</p><p>——————————</p><p>好了，可以开始讲了。</p><p>哦对了，我学的也不深，请不要用教程二字绑架我，认为我什么都会，我也在学习，希望一起交流，一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcGIS </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何重装系统</title>
      <link href="/2019/04/06/%E5%A6%82%E4%BD%95%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/04/06/%E5%A6%82%E4%BD%95%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来我是不想写这篇文章的<del>因为懒</del>。</p><p>但是有鉴于最近<strong>找我装系统的人太多</strong>了，再加上看见小白被无良商家骗于心不忍，就写篇教程吧-_-。</p><p>我会把装机的主要几个阶段讲一下，但是任何跟着提示稍微理解下就可以无风险走的小步骤就不讲了。</p><h2 id="装系统之前的准备"><a href="#装系统之前的准备" class="headerlink" title="装系统之前的准备"></a>装系统之前的准备</h2><p>首先要有个概念 <code>装系统是一件很简单的事</code>。电脑是一件给人用的 <strong>工具</strong> ，厂商没有理由设置门槛。装机是很简单的，<strong>但是最好不要随意重装系统，文件、软件重新安置太麻烦了</strong>。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ul><li>物理准备<ul><li>一只8G以上U盘</li></ul></li><li>心理准备<ul><li>一小时不到的时间</li><li>一定的理解能力</li></ul></li></ul><h2 id="装机阶段"><a href="#装机阶段" class="headerlink" title="装机阶段"></a>装机阶段</h2><ol><li><p>找到你所用电脑的<strong>主板</strong>厂商（<em>不需要拆机箱，直接用aida64或者别的软件看</em>）以及<strong>型号</strong>，如果是笔记本就直接使用<strong>电脑型号</strong>。</p></li><li><p>搜索 xxxx（<em>你的主板型号</em>） 进入bios的<strong>快捷键</strong>，并记住它。</p></li><li><p>在<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">msdn 我告诉你</a>，这个网站上找到你要装的系统的 <strong>64位</strong> <strong>最新版本</strong>。</p></li><li><p>下载它。</p></li><li><p><strong>格式化</strong>U盘。</p></li><li><p>把下载的镜像文件用解压软件<strong>解压到U盘</strong>。</p></li><li><p><strong>备份c盘里的文件</strong>，其它盘看你想不想顺便格式化。</p></li><li><p>重启，并在开机的过程中<strong>狂按</strong>你记住的<strong>快捷键</strong>。</p></li><li><p>你将会进入一个蓝蓝白白的界面（bios），请动用你的英语水平进行翻译后使用。</p></li><li><p>你有两个选择</p><ul><li>UEFI路线<ol><li>找到<strong>boot</strong>里面的<strong>UEFI</strong>设置为<strong>ENABLE</strong></li><li><strong>重启</strong>，开机过程中<strong>狂按</strong>快捷键</li><li>会看见弹出一个<strong>对话框</strong>，选择 <strong>WINDOWS</strong> <strong>BOOT</strong> <strong>MANAGER</strong></li></ol></li><li>传统路线<ol><li>找到<strong>boot</strong>里面的<strong>启动顺序</strong></li><li>按照操作指示，把<strong>U盘</strong>放到最上面</li><li>重启</li></ol></li></ul></li><li><p>在Windows安装指示界面中，按照指示</p><p>操作</p><p>进行操作</p><ul><li>分区格式化请<strong>谨慎</strong></li></ul></li><li><p>开机后联网会<strong>自动</strong>安装驱动</p></li><li><p>在你的显卡的对应官网下载安装<strong>显卡驱动</strong></p></li><li><p>在设备管理器中查看有无设备上有<strong>感叹号标识</strong>，若有，去官网下载驱动。</p></li><li><p>是否安装</p><p>360、驱动大师等软件自行判断</p><ul><li>我推荐ccleaner、火绒</li></ul></li><li><p>重启进入bios，把设置还原为改动之前的</p></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>简单的电脑维护其实很简单(<del>废话</del>)，只要不<strong>先入为主</strong>地认为自己不会，<strong>善用搜索引擎</strong>，不懂的东西<strong>稍微研究</strong>一下，一般都没有问题的。</p><p><strong>如果看完本文仍觉得无从下手的话，可以联系QQ:244675854提供技术支持（收辛苦费20~30呦！），嘻嘻</strong></p><blockquote><p>我不对任何本文后果负责，还请读者们自行判断。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重装系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键激活window &amp; office</title>
      <link href="/2019/04/06/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow-office/"/>
      <url>/2019/04/06/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow-office/</url>
      
        <content type="html"><![CDATA[<h1 id="一键激活windows-amp-office"><a href="#一键激活windows-amp-office" class="headerlink" title="一键激活windows&amp;office"></a>一键激活windows&amp;office</h1><p>自建的激活服务器，可以一键激活VOL版的window和office。</p><p>推荐去<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a> 下载安装正版的window和office。</p><h2 id="单击下载-一键激活window-amp-office-bat"><a href="#单击下载-一键激活window-amp-office-bat" class="headerlink" title="单击下载 一键激活window&amp;office.bat"></a>单击下载 <a href="https://tohot.top/download/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow&amp;office.bat" target="_blank" rel="noopener">一键激活window&amp;office.bat</a></h2>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何开发一个用户脚本系列——脚本1:视频跳过广告和 VIP 视频解析</title>
      <link href="/2019/04/06/%E8%A7%86%E9%A2%91%E8%B7%B3%E8%BF%87%E5%B9%BF%E5%91%8A%E5%92%8CVIP%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/04/06/%E8%A7%86%E9%A2%91%E8%B7%B3%E8%BF%87%E5%B9%BF%E5%91%8A%E5%92%8CVIP%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在这篇文章中，我们一起学习脚本 <strong>视频跳过广告和 VIP 视频解析</strong> 的开发。这也是本系列文章的最后一篇，希望完成这个系列的学习之后，你能够掌握编写脚本的方法。在正式开始之前，先说一下我认为开发脚本应该遵循的两个准则:</p><ul><li>功能实现。当你决定要开发一个脚本的时候，你肯定清楚你的脚本要实现什么功能，只有你的脚本实现了你所描述的功能，才会有更多的人安装使用，才会有更多的人给你好评；</li><li>样式实现。什么叫样式实现？就是你在目标网站中添加的元素，要尽量与原网站的配色，样式相一致。这一项是非必须的，但我认为是非常重要的。你想想，如果原网站整体是蓝色，而你添加的按钮是红色，那该有多突兀，有多丑，虽然你的按钮确实突出了，但别人一看就是山寨，看着会很不舒服。而如果你的按钮也用它网站的颜色，这样就会跟原网站已有的元素契合，整体特别自然，做到以假乱真的效果。你的脚本让别人用的舒服，别人才更愿意给你好评。</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>我们在日常闲暇时间都会看点视频娱乐一下，而现在各大视频网站都推出了会员体系，一个视频网站的年费会员往往需要 200 块左右。然而我们想看的电视剧，电影，通常都不在一个平台上，导致我们就需要开通各个网站的会员。一个网站还好，但多个网站叠加起来，这笔钱也不少。所以有没有什么方法能够不需要开通各个网站的会员就可以看想看的视频呢？网上现在有一些免费公开的接口提供这种解析服务，只需要将视频播放页面的地址作为参数传给接口，接口就能完成解析，然后播放视频。但我们每次都复制视频播放地址给接口，也会很麻烦，这时候就可以写个脚本，在这些视频网站上添加一个按钮，当用户点击按钮的时候，自动获取到当前页面的播放地址，然后传给接口解析播放。HTML 中有个 <code>iframe</code> 标签，可以用来在当前页面中嵌入其他网页，所以使用 <code>iframe</code> 标签就能够实现在原视频网站站内解析播放视频，体验很好。在某视频网站上的效果如下图:<br><a href="https://mofiter-blog.oss-cn-hangzhou.aliyuncs.com/images/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%84%9A%E6%9C%AC6-1.png" target="_blank" rel="noopener"><img src="https://mofiter-blog.oss-cn-hangzhou.aliyuncs.com/images/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%84%9A%E6%9C%AC6-1.png" alt="img"></a></p><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>视频的解析都是解析接口实现的，脚本本身并不进行视频解析。所以解析接口是否稳定，是否有较高的成功率是很关键的。现在网上有很多解析接口，本文只提供 <a href="https://api.bbbbbb.me/" target="_blank" rel="noopener">思古解析</a>(用于站内解析)和 <a href="http://www.1717yun.com/" target="_blank" rel="noopener">1717yun解析</a>(用于站外解析)作为示例，同时由于视频网站很多，所以本文只选择 <a href="https://v.qq.com/" target="_blank" rel="noopener">腾讯视频</a> 作为运行脚本的示例。腾讯视频某一个视频的具体播放地址形式为 <code>https://v.qq.com/x/cover/xxx</code>，用 <code>@match</code> 匹配。在脚本编写过程中会用到 jQuery，使用 <code>@require</code> 引入 jQuery 库。站外解析需要在新 tab 页中打开链接，所以需要脚本管理器的 <code>GM_openInTab()</code> 函数，我们用 <code>@grant</code> 声明(为了兼容 Greasemonkey，我们还要声明它的函数 <code>GM.openInTab</code>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy// @require           https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js</span><br><span class="line">// @match             *://v.qq.com/x/cover/*</span><br><span class="line">// @grant             GM_openInTab</span><br><span class="line">// @grant             GM.openInTab</span><br></pre></td></tr></table></figure><p>通过观察原网站可知，功能菜单都是在视频播放窗口下面，当鼠标放在功能按钮上面时，会显示功能面板，当鼠标移出功能按钮时，功能面板隐藏。所以我们将解析按钮加到功能菜单里面，将各个接口添加到功能面板，这样就可以选择不同的接口进行解析，同时使用原网站的样式风格。我们使用一个数组保存接口信息，这样方便遍历添加。由于安全问题，以 https 开头的视频网站内部不能使用 http 开头的接口，所以我们利用接口类型字段来标识接口是用来进行站内解析还是站外解析，如果是站内解析，它应该以 https 开头，如果接口以 http 开头，只能用来站外解析。我们希望将所有的接口以一个列表的形式呈现，所以我们把它放在一个 <code>&lt;ul&gt;</code> 标签里，然后每一个接口放在一个 <code>&lt;li&gt;</code> 标签里面。我们创建一个 <code>&lt;div&gt;</code> 标签，在里面添加一个 <code>&lt;iframe&gt;</code> 标签，用来加载解析结果的网页。在后面进行站内解析的时候，我们用这个 <code>&lt;div&gt;</code> 替换原视频网站播放窗口里面的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copyvar originalInterfaceList = [&#123;&quot;name&quot;:&quot;思古解析&quot;,&quot;type&quot;:&quot;站内&quot;,&quot;url&quot;:&quot;https://api.bbbbbb.me/jx/?url=&quot;&#125;,</span><br><span class="line">                             &#123;&quot;name&quot;:&quot;1717yun解析&quot;,&quot;type&quot;:&quot;站外&quot;,&quot;url&quot;:&quot;http://www.1717yun.com/jx/ty.php?url=&quot;&#125;];</span><br><span class="line">    var parseList = &quot;&lt;ul&gt;&quot;;</span><br><span class="line">    parseInterfaceList.forEach((item,index)=&gt;&#123;</span><br><span class="line">        parseList += &quot;&lt;li&gt;&quot; + item.name + &quot;(&quot; + item.type + &quot;)&lt;/li&gt;&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    parseList += &quot;&lt;/ul&gt;&quot;;</span><br><span class="line">    var videoPlayer = $(&quot;&lt;div id=&apos;iframe-div&apos; style=&apos;width:100%;height:100%;z-index:2147483647;&apos;&gt;&lt;iframe id=&apos;iframe-player&apos; frameborder=&apos;0&apos; allowfullscreen=&apos;true&apos; width=&apos;100%&apos; height=&apos;100%&apos;&gt;&lt;/iframe&gt;&lt;/div&gt;&quot;);</span><br></pre></td></tr></table></figure><p>准备好解析接口和要替换的内容之后，我们就要去原网站添加解析按钮，并添加点击事件，在点击事件里面，替换播放窗口的内容。通过 <code>location.href</code> 能拿到当前页面的 url，我们使用 <code>indexOf()</code> 方法查看 <code>v.qq.com</code> 的索引值，如果索引值大于 -1 说明当前匹配的网站是腾讯视频，我们再进行处理。我们使用 jQuery 获取到功能菜单的父元素，然后创建解析按钮元素，将解析按钮添加到功能菜单父元素。给解析按钮添加鼠标移入移出操作，来显示和隐藏接口列表的功能面板。在每一个解析接口上面添加点击操作，判断被点击的 <code>&lt;li&gt;</code> 标签的接口类型，如果是站内解析，则替换播放窗口的内容，如果是站外解析，则打开一个新的页面显示解析链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copyif(location.href.indexOf(&quot;v.qq.com&quot;) &gt; -1)&#123;</span><br><span class="line">        var action_wrap = $(&quot;.action_wrap&quot;);</span><br><span class="line">        var qq_jiexi = $(&quot;&lt;div id=&apos;qq-jiexi-btn&apos; class=&apos;action_item action_jiexi&apos; style=&apos;position:relative;&apos;&gt;&lt;a class=&apos;action_title fn-qq-jiexi-text&apos;&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/a&gt;&lt;div class=&apos;mod_pop_action fn-qq-jiexi&apos; style=&apos;background-color:#fff;width:120px;left:-50px;text-align:center;line-height:25px;&apos;&gt;&quot; + parseList + &quot;&lt;/div&gt;&lt;/div&gt;&quot;);</span><br><span class="line">        action_wrap.append(qq_jiexi);</span><br><span class="line">        document.getElementById(&quot;qq-jiexi-btn&quot;).addEventListener(&quot;mouseover&quot;,()=&gt;&#123;</span><br><span class="line">            $(&quot;.action_jiexi&quot;).toggleClass(&quot;open&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        document.getElementById(&quot;qq-jiexi-btn&quot;).addEventListener(&quot;mouseout&quot;,()=&gt;&#123;</span><br><span class="line">            $(&quot;.action_jiexi&quot;).toggleClass(&quot;open&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        $(&quot;.fn-qq-jiexi li&quot;).each((index,item)=&gt;&#123;</span><br><span class="line">            item.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">                if(parseInterfaceList[index].type == &quot;站内&quot;)&#123;</span><br><span class="line">                    if(document.getElementById(&quot;iframe-player&quot;) == null)&#123;</span><br><span class="line">                        var txp_ad_skip_text = $(&quot;.txp_ad_inner .txp_ad_skip_text&quot;);</span><br><span class="line">                        if(txp_ad_skip_text.text() === &quot;VIP可关闭广告&quot;)&#123;</span><br><span class="line">                            txp_ad_skip_text.click();</span><br><span class="line">                            mod_player = $(&quot;#mod_player&quot;);</span><br><span class="line">                            mod_player.empty();</span><br><span class="line">                            mod_player.append(videoPlayer);</span><br><span class="line">                        &#125;else if(txp_ad_skip_text.text() === &quot;关闭广告&quot;)&#123;</span><br><span class="line">                            txp_ad_skip_text.click();</span><br><span class="line">                        &#125;else if(vipPage === true)&#123;</span><br><span class="line">                            var txp_btn_play = $(&quot;.txp_left_controls .txp_btn_play&quot;);</span><br><span class="line">                            if(txp_btn_play.attr(&quot;data-status&quot;) === &quot;pause&quot;)&#123;</span><br><span class="line">                                txp_btn_play.click();</span><br><span class="line">                            &#125;</span><br><span class="line">                            mod_player = $(&quot;#mod_player&quot;);</span><br><span class="line">                            mod_player.empty();</span><br><span class="line">                            mod_player.append(videoPlayer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    innerParse(parseInterfaceList[index].url + location.href);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    GMopenInTab(parseInterfaceList[index].url + location.href,false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function innerParse(url)&#123; // 站内解析</span><br><span class="line">    $(&quot;#iframe-player&quot;).attr(&quot;src&quot;,url);</span><br><span class="line">&#125;</span><br><span class="line">function GMopenInTab(url,open_in_background)&#123; //站外解析</span><br><span class="line">    if(typeof GM_openInTab === &quot;function&quot;)&#123; // Tampermonkey 和 Violentmonkey 调用 GM_openInTab</span><br><span class="line">        GM_openInTab(url,open_in_background);</span><br><span class="line">    &#125;else&#123; // Greasemonkey GM.openInTab</span><br><span class="line">        GM.openInTab(url,open_in_background);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此腾讯视频的解析差不多就完成了，还有些细节和用户体验方面的东西代码里面有写，这里就不再赘述了。其他视频网站的处理和腾讯视频的原理是一样的，都是添加解析按钮，然后给解析按钮添加点击事件，进行站内或站外解析。</p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何开发用户脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/06/hello-world/"/>
      <url>/2019/04/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>极限与导数</title>
      <link href="/2019/04/03/%E6%9E%81%E9%99%90%E4%B8%8E%E5%AF%BC%E6%95%B0/"/>
      <url>/2019/04/03/%E6%9E%81%E9%99%90%E4%B8%8E%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>最近学了一些基础微积分，这里稍微记录一下。</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>极限可以当做是一个函数f(x)f(x)的xx无限趋近于某一个常数或无穷远处时，函数数值所逼近的一个值。 例如，对于函数<br>$$<br>f(x)=2xx+1f(x)=2xx+1<br>$$<br>，当xx趋近于无穷大时，f(x)f(x)无限趋近于22。我们将此记成这样子：</p><p>$$<br>limx→∞f(x)=limx→∞2xx+1=2limx→∞f(x)=limx→∞2xx+1=2<br>$$</p><p>求极限需要会一点代数技巧，我反正是老是求不出……</p><p>极限有一些方便的性质：<br>当然，这些等式的左边都是存在极限的。</p><p>$$<br>limx→ca⋅f(x)=a⋅limx→cf(x)limx→ca⋅f(x)=a⋅limx→cf(x)<br>$$</p><p>对于两个函数f(x)f(x)和g(x)g(x)之间极限的关系：（当然f(x)f(x)和g(x)g(x)都要存在极限）</p><p>$$<br>limx→c[f(x)+g(x)]=limx→cf(x)+limx→cg(x)limx→c[f(x)+g(x)]=limx→cf(x)+limx→cg(x)<br>$$</p><p>$$<br>limx→c[f(x)−g(x)]=limx→cf(x)−limx→cg(x)limx→c[f(x)−g(x)]=limx→cf(x)−limx→cg(x)<br>$$</p><p>$$<br>limx→cf(x)⋅g(x)=limx→cf(x)⋅limx→cg(x)limx→cf(x)⋅g(x)=limx→cf(x)⋅limx→cg(x)<br>$$</p><p>$$<br>limx→cf(x)g(x)=limx→cf(x)limx→cg(x)(limx→cg(x)≠0)limx→cf(x)g(x)=limx→cf(x)limx→cg(x)(limx→cg(x)≠0)<br>$$<br>简而言之，极限这东西可以加减乘除。</p><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>对于函数f(x)f(x)而言，它在x0x0处的导数是这么定义的：</p><p>$$<br>limΔx→0f(x0+Δx)−f(x0)ΔxlimΔx→0f(x0+Δx)−f(x0)Δx<br>$$</p><p>从几何意义上讲，这个值可以视为是f(x)f(x)的图像在x0x0处的切线的斜率。 当然不是所有的函数都是可以求导数的，只有在那一段上是连续的函数时，才会有导数。<br>连续的函数f(x)f(x)在其定义域内的每一点上都可以计算导数，意味着每一个xx都会对应一个导数，这样就形成了一个函数关系。我们将这个函数叫作导函数，记作f′(x)f′(x)。</p><p>如何求导函数呢？根据导数的定义，我们将x0x0换为xx，然后求极限就好了。然而说的轻巧，实际上很多都比较难以求出，因此早有先人为我们把各种导函数算好了。</p><p>举一个典型的例子<br>$$<br>f(x)=x2f(x)=x2<br>$$<br>。按照求导数的方法：</p><p>$$<br>f′(x)=limΔx<br>$$<br>$$<br>→0f(x+Δx)−f(x)Δx=limΔx<br>$$<br>$$<br>→0(x+Δx)2−x2Δx=limΔx<br>$$<br>$$<br>→0Δx2+2xΔxΔx=limΔx<br>$$<br>$$<br>→0(Δx+2x)=2xf′(x)=limΔx<br>$$<br>$$<br>→0f(x+Δx)−f(x)Δx=limΔx<br>$$<br>$$<br>→0(x+Δx)2−x2Δx=limΔx<br>$$<br>$$<br>→0Δx2+2xΔxΔx=limΔx<br>$$<br>$$<br>→0(Δx+2x)=2x<br>$$</p><p>事实上，对于幂函数<br>$$<br>f(x)=xαf(x)=xα，其导函数为，其导函数为<br>$$<br>，其导函数为<br>$$<br>f′(x)=αxα−1f′(x)=αxα−1<br>$$<br>。</p><p>导数与导数之间存在运算关系，有了这些运算关系，我们就可以方便地进行求导。<br>类似于线性的性质：<br>$$<br>[a⋅f(x)+b⋅g(x)]′=a⋅f′(x)+b⋅g′(x)[a⋅f(x)+b⋅g(x)]′=a⋅f′(x)+b⋅g′(x)<br>$$</p><p>两个导数相乘：<br>$$<br>[f(x)g(x)]′=f′(x)g(x)+f(x)g′(x)[f(x)g(x)]′=f′(x)g(x)+f(x)g′(x)<br>$$</p><p>两个导数相除：<br>$$<br>[f(x)g(x)]′=f′(x)g(x)−f(x)g′(x)g2(x)(g(x)≠0)[f(x)g(x)]′=f′(x)g(x)−f(x)g′(x)g2(x)(g(x)≠0)<br>$$</p><p>复合函数：<br>$$<br>[f(g(x))]′=f′(g(x))⋅g′(x)[f(g(x))]′=f′(g(x))⋅g′(x)<br>$$</p><p>一些基本函数的导函数就放这里了，当我们要求一个特定函数的导函数时，可以利用上面的规则，然后根据导函数表来计算。下面只有xx是变量。<br>$$<br>c′=0c′=0<br>$$</p><p>$$<br>x′=1x′=1<br>$$</p><p>$$<br>(xα)′=αxα−1(xα)′=αxα−1<br>$$</p><p>$$<br>(ex)′=ex(ex)′=ex<br>$$</p><p>$$<br>(ax)′=axlna(ax)′=axln⁡a<br>$$</p><p>$$<br>(lnx)′=1x(ln⁡x)′=1x<br>$$</p><p>$$<br>(logax)′=1xlna(loga⁡x)′=1xln⁡a<br>$$</p><p>$$<br>sin′x=cosxsin′⁡x=cos⁡x<br>$$</p><p>$$<br>cos′x=−sinxcos′⁡x=−sin⁡x<br>$$</p><p>$$<br>tan′x=1cos2xtan′⁡x=1cos2⁡x<br>$$</p><p>$$<br>cot′x=−1sin2xcot′⁡x=−1sin2⁡x<br>$$</p><h2 id="对数求导法"><a href="#对数求导法" class="headerlink" title="对数求导法"></a>对数求导法</h2><p>上面的求导公式已经能够应对大部分基本函数的求导了，但是对于下面的函数：<br>$$<br>f(x)=x1/xf(x)=x1/x<br>$$<br>该如何求导呢？<br>这就要用到对数来进行求导。</p><p>我们知道，对于一个函数f(x)f(x)：<br>$$<br>[lnf(x)]′=ln′f(x)⋅f′(x)[ln⁡f(x)]′=ln′⁡f(x)⋅f′(x)<br>$$</p><p>换言之：<br>$$<br>f′(x)=[lnf(x)]′ln′f(x)(1)(1)f′(x)=[ln⁡f(x)]′ln′⁡f(x)<br>$$<br>利用这一点，我们就可以对<br>$$<br>f(x)=x1/xf(x)=x1/x<br>$$<br>求导。 首先，为了方便我们设：<br>$$<br>y=x1/xy=x1/x<br>$$<br>由于两者相等，所以两者的对数也应相等：<br>$$<br>lny=lnx1/x=1xlnxln⁡y=ln⁡x1/x=1xln⁡x<br>$$</p><p>将两边对xx求导。注意按照(1)(1)式，左式需要乘上y′y′两者才能相等。<br>$$<br>y′y=1−lnxx2y′y=1−ln⁡xx2<br>$$</p><p>于是我们可以得到：<br>$$<br>y′=1−lnxx2y=1−lnxx2x1/x=f′(x)y′=1−ln⁡xx2y=1−ln⁡xx2x1/x=f′(x)<br>$$</p><p>这样我们就完成了求导。<br>既然都对这个函数求过导了，我们来验证一下它的一个性质。<br>将ee代入导函数：<br>$$<br>f′(e)=1−lnee2e1/e=1−1e2=0f′(e)=1−ln⁡ee2e1/e=1−1e2=0<br>$$</p><p>因此我们发现<br>$$<br>x=ex=e<br>$$<br>是这个函数的极值点。</p>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极限 </tag>
            
            <tag> 导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统结构</title>
      <link href="/2019/04/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>在 Linux 操作系统, 我们是看不到这些驱动器盘符, 而是文件夹(目录):</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g1poi8yj5tj30ku07ndhn.jpg" alt="Linux文件目录示意图"><br>​                                <strong><em>Linux文件目录示意图</em></strong></p><p>Ubuntu 没有盘符概念, 只有一个根目录 <strong>/</strong>, 所有文件都在它下面.</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g1poizwgvjj30ip0bfaa7.jpg" alt="Linux 目录结构示意图"></p><p>​                                <strong><em>Linux 目录结构示意图</em></strong></p><h3 id="Linux-主要目录速查表"><a href="#Linux-主要目录速查表" class="headerlink" title="Linux 主要目录速查表"></a>Linux 主要目录速查表</h3><ul><li><p>/：根目录，</p><p>一般根目录下只存放目录</p><p>，在 linux 下有且只有一个根目录，所有的东西都是从这里开始</p><ul><li>当在终端里输入 <code>/home</code>，其实是在告诉电脑，先从 <code>/</code>（根目录）开始，再进入到 <code>home</code> 目录</li></ul></li><li><p>/bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等</p></li><li><p>/boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：<code>/boot/vmlinuz</code>，系统引导管理器：<code>/boot/grub</code></p></li><li><p>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom /mnt</code></p></li><li><p>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有</p><ul><li>/etc/inittab</li><li>/etc/fstab</li><li>/etc/init.d</li><li>/etc/X11</li><li>/etc/sysconfig</li><li>/etc/xinetd.d</li></ul></li><li><p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下</p><ul><li><code>~</code> 表示当前用户的家目录</li><li><code>~edu</code> 表示用户 <code>edu</code> 的家目录</li></ul></li><li><p>/lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</p></li><li><p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</p></li><li><p>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载</p></li><li><p>/opt：给主机额外安装软件所摆放的目录</p></li><li><p>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等</p></li><li><p>/root：系统管理员root的家目录</p></li><li><p>/sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用</p></li><li><p>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下</p></li><li><p>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内</p></li><li><p>/usr：应用程序存放目录</p><ul><li>/usr/bin：存放应用程序可执行二进制文件的目录</li><li>/usr/share：存放共享数据</li><li>/usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</li><li>/usr/local：存放软件升级包</li><li>/usr/share/doc：系统说明文件存放目录</li><li>/usr/share/man：程序说明文件存放目录</li></ul></li><li><p>/var：放置系统执行过程中经常变化的文件</p><ul><li>/var/log：随时更改的日志文件</li><li>/var/spool/mail：邮件存放的目录</li><li>/var/run：程序或服务启动后，其 PID 存放在该目录下</li></ul></li></ul><p><strong>重点:</strong> <strong>/home/用户名</strong> 是用户的家目录.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Linux 和 Windows 文件系统的区别<br> 1.1 Linux 文件系统只有一个根目录(<strong>/</strong>)<br> 1.2 Windows 文件系统会有可能会有多个盘符(例如C、D、E…)</li><li><strong>/home/用户名</strong> 是用户的家目录, 是经常使用的目录.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥是人工智能</title>
      <link href="/2019/04/03/%E5%95%A5%E6%98%AF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
      <url>/2019/04/03/%E5%95%A5%E6%98%AF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZukIrsq7161xeGvkFcNun46boShNiatq5JZvqdjX5XjVlR6ToY48GAxQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>作者：武博士、宋知达、袁雪瑶、聂文韬</p></blockquote><p>本节我们会以生动有趣的漫画来介绍关于人工智能（AI）相关的故事，你将会学习到： <strong>人工智能的基本概念</strong></p><p><strong>1.1 啥是人工智能</strong><br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZWzSukZqmRVrdvVemO9siatS9tjtGR81eAGYv7NWSyWITibOOrTf2xK9w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>当有人问我，Dr.Wu 你的研究方向是什么？我回答：人工智能。 接着大约会得到以下四种问题： </p><p><strong>哇，好酷！是不是很难呢？</strong> </p><p><strong>是不是制造机器人帮助我们呢？</strong> </p><p><strong>AI和人工智能有什么区别？</strong> </p><p><strong>究竟啥是人工之智能？</strong> </p><p>接下来，我会带大家一一解惑。</p><p><strong>1.1.1 人的智慧和人工智能</strong></p><p>究竟什么是人工智能，什么是AI，接下来，由我为大家解答。 媒体上几乎每天都有AI和人工智能的词汇，总给人一种深奥神秘的感觉。人工智能顾名思义就是人类制造的智慧，英文叫Artificial Intelligence（AI），所以人工智能=AI。 </p><p>那么问题又来了，智慧究竟是什么？我们要以何种方式去制造智慧？要回答这个问题，就必须从人与人造物的 区别和人的智慧说起。 </p><p>对于人工智能的研究人员来说，目标并不是研究人类智慧的来源，而是以工程技术手段制造出类似人类智慧的 产品。  </p><p>人类和人工智能最大的差异是，肉体的有无。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZSbYzsu8L847X5pXuYGvEiaVvNfatNdYJBwXpzhE2JG29x9wSLnVpRuw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>人类可以通过身体获得外界资讯。透过感觉器官，我们可以感觉到声音、外观、触感、气味等，让我们觉得舒服或者讨厌，进而产生感情。 </p><p>不过人工智能并没有人类的身体，因此无法像人类一样通过肉体感觉器官来积累感觉经验，也无法借此获得知识。 </p><p>人工智能必须依赖人类，将人类通过鼻子、眼睛、嘴巴、皮肤…获得的外界资讯，以某种形式”输入“到人工智能，人工智能才可以加工和处理这些信息。 具体输入方式我们未来讨论。</p><p><strong>1.1.2 图灵测试：哪个一边是人？</strong></p><p>英国数学家，Dr.Wu 认为二十世纪最聪明的人三个人（爱因斯坦、图灵、冯诺依曼）之一，艾伦.图灵（Alan Turing：1912-1954）定义了一种方法，来判断人工智能是否成功，这种方法是：和自己对话的对象是人类还是人工智能？ </p><p>这种方法就是大名鼎鼎的图灵测试。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZZhXpn1212YWcQFkmNibWOfmjIC6gvgJPcb5TL2ykLTs2ykXX2CwRnAw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>只要三成以上的研究员将人工智能误以为是人类，就算通过图灵测试。 </p><p>但是由于计算机很难做到与人类接近的对话，所以很长一段时间都没有任何人工智能通过图灵测试。反而人类在不断学习计算机语言，这就是大量程序员的工作，和计算机对话。 </p><p>图灵测试又叫做模仿游戏‘Imitation Game’，一部描绘图灵一生的自传电影一样也叫模仿游戏，我觉得很好看哦。 Imitation 即为模仿。 </p><p>除了这部电影之外，《黑客帝国》、《终结者》、《全面进化》等描述人工智能的电影中，大多提到人工智能会威胁到人类生活，而不是给人类带来幸福，这让很多人谈到人工智能都会感到恐慌。 </p><p>但是，事实上，目前还没有做出公认通过图灵测试的人工智能。所以大家也不必恐慌哦。</p><p><strong>1.1.3 人工智能会思考吗？</strong></p><p>“思考”，大多数人会想到计算，应该是人工智能的专长。但事实上，要想像人类一样思考其实是一件非常困难的事情。 </p><p>人工智能需要以各种输入数据案例为基础，通过这些数据案例获取经验和知识，然后进行预测和判断。如果输入的案例太少，就无法做出判断。 情况相反，人类即使遇到过去未曾遇到的状况，也可以以弹性的方式面对各种状况。 </p><p>例如，人工智能需要看过上万张猫狗的图片才可以相对准确的识别猫狗图片，但是人类3岁左右的小朋友，只需要见过几次，就可以识别。差距还是巨大的。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZTfZic3rXM0eic33pYlPM6y45wP2gefKMfsysGPAgLShCPIOeqnIKgGGg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>但是，人类对于人类来说很难解决的问题，人工智能却能够迅速解决。例如：训练好的人工智能在图片识别过程中，效率远远高于人类，给他们10万张图片，他们会很快的为人类做好分类工作，无怨无悔，而且在工作过程中，人工智能本来的”智慧”也在提升。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZic88PlEGsls1K27E2XaOIaylGaP5yicPeRlOIvPtQkwVQmrjFd0lyXbA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>我们将在未来的章节提到，目前具有一定“智能”的AI，可以用什么样的方式来解决什么样的问题。明白人工智能的擅长之处与不擅长之处，是未来社会我们能够幸福生活的关键。</p><p>（未完待续…）</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零基础15行python代码搞定网易云热门歌单</title>
      <link href="/2019/03/31/15%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E9%97%A8%E6%AD%8C%E5%8D%95/"/>
      <url>/2019/03/31/15%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E9%97%A8%E6%AD%8C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>健身、吃饭、敲代码；等车、撸猫、下午茶……若能佐以合适的音乐当“配餐”，总是惬意非常。本文就将带你爬一爬网易云的那些热门歌单！</p></blockquote><p>心情好或心情坏，点一首歌抚慰你受伤或躁动的心灵——下面教你用 15 行代码搞定热门歌单！</p><p>本文使用的是 Selenium 模块，它是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作，对于一些 JavaScript 渲染的页面来说，此种抓取方式非常有效。</p><p>采用了 Chrome 浏览器配合 Selenium 工作，本文的 Python 版本是 3.7.2。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h1><ol><li>若你的环境中没有 Selenium 模块，直接使用 pip 安装即可：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><ol start="2"><li><p>打开谷歌浏览器，检查Chrome的版本：在浏览器地址中输入 chrome://settings/help 回车即可看到：</p><p><img src="https://img.vim-cn.com/ac/4ed0c338deb650848bbc8e56ea2c6147b1bf17.png" alt="02.png"></p></li><li><p>打开 ChromeDriver 的官方网站（<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads），寻找与你当前浏览器版本相对应的" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads），寻找与你当前浏览器版本相对应的</a> ChromeDriver 下载：</p><p><img src="https://img.vim-cn.com/05/758873fffa1036762e388ecff28eead7b0be1f.png" alt="03.png"></p></li><li><p>选择你自己的操作系统类型进行下载即可：</p><p><img src="https://img.vim-cn.com/d1/7821da501ffe292bc5e376857e402582d194e0.png" alt="04.png"></p></li><li><p>以 Windows 为例，下载结束后，将 ChromeDriver 放置在 Python 安装目录下的 Scripts 文件夹即可：</p><p><img src="https://img.vim-cn.com/1b/5ca9231635c8c93f78b4c1a051573209cefdf6.png" alt="05.png"></p></li></ol><p>准备工作完成，代码写起来吧~</p><h1 id="迷你爬虫的实现"><a href="#迷你爬虫的实现" class="headerlink" title="迷你爬虫的实现"></a><strong>迷你爬虫的实现</strong></h1><p>我们这次的目标是爬取热门歌单，比如网易云音乐中播放量大于 1000万 的歌单信息（歌单名称、链接）。</p><ol><li><p>先来打开网易云的歌单第一页：    </p><p><a href="https://music.163.com/#/discover/playlist/" target="_blank" rel="noopener">https://music.163.com/#/discover/playlist/</a></p></li><li><p>使用 Chrome 的开发者工具 <f12> 进行分析：</f12></p><p><img src="https://img.vim-cn.com/f8/79c7e9ee5bb3083922c40acec3cf36cf3818ad.png" alt="02-2.png"></p></li></ol><p>我们想要拿的信息全在这里：</p><p>msk，封面 [mask]：有歌单的名称及链接</p><p>nb，播放数 [number broadcast]：135万</p><ol start="3"><li><p>我们还需要遍历所有的页，使用工具继续分析，找到“下一页”的 URL：</p><p><img src="https://img.vim-cn.com/d3/6bef2ed87892bb9d6d86935cc23cab4afb5c87.png" alt="02-3.png"></p></li><li><p>切换至最后一页，拿到最后一页的 URL：</p><p><img src="https://img.vim-cn.com/1f/9ec15c2bd641cce2ea5d1dbba8a3c8de3885c7.png" alt="02-4.png"></p></li><li><p>等我们爬取完所有符合的歌单信息后，将其保存在本地；</p></li><li><p>全部工作结束，最后再通过下面的伪代码回顾下整体思路：</p><p><img src="https://img.vim-cn.com/3f/b955a96ab865b20641f7498479a9a2441e3707.png" alt="02-6.png"></p></li><li><p>爬取的效果如下：</p><p><img src="https://img.vim-cn.com/46/826692648fd04b345d5754c9125e5f1ec9fe60.png" alt="02-7.png"></p></li></ol><p>另附源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网易云音乐歌单列表第一页地址</span></span><br><span class="line">url = <span class="string">'https://music.163.com/#/discover/playlist/?order=hot&amp;cat=%E5%85%A8%E9%83%A8&amp;limit=35&amp;offset=0'</span></span><br><span class="line"><span class="comment"># 用Chrome接口创建一个Selenium的WebDriver</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐页解析，直至歌单列表的最后一页</span></span><br><span class="line"><span class="keyword">while</span> url != <span class="string">'javacript:void(0)'</span>:</span><br><span class="line">    <span class="comment"># 用WebDriver加载页面</span></span><br><span class="line">    browser.get(url)</span><br><span class="line">    <span class="comment"># 切换至内容的iframe</span></span><br><span class="line">    browser.switch_to.frame(<span class="string">"contentFrame"</span>)</span><br><span class="line">    <span class="comment"># 定位歌单标签</span></span><br><span class="line">    data = browser.find_element_by_id(<span class="string">"m-pl-container"</span>).find_elements_by_tag_name(<span class="string">"li"</span>)</span><br><span class="line">    <span class="comment"># 解析当前页中所有的歌单详情</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="comment"># 获取歌单的播放量</span></span><br><span class="line">        num = data[i].find_element_by_class_name(<span class="string">"nb"</span>).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'万'</span> <span class="keyword">in</span> num <span class="keyword">and</span> int(num.split(<span class="string">'万'</span>)[<span class="number">0</span>]) &gt; <span class="number">1000</span>:</span><br><span class="line">            <span class="comment"># 获取播放量大于1000万的歌单封面</span></span><br><span class="line">            msk = data[i].find_element_by_css_selector(<span class="string">"a.msk"</span>)</span><br><span class="line">            <span class="comment"># 把歌单封面中的标题、链接以及播放量，存储在TXT文件中</span></span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"163playlist.txt"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">' '</span>.join([msk.get_attribute(<span class="string">'title'</span>), num, msk.get_attribute(<span class="string">"href"</span>)]) + <span class="string">'\n'</span> + <span class="string">'='</span> * <span class="number">50</span> + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment"># 定位'下一页'的URL</span></span><br><span class="line">    url = browser.find_element_by_css_selector(<span class="string">"a.zbtn.znxt"</span>).get_attribute(<span class="string">"href"</span>) </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结束调用</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
            <tag> 网易 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX初识</title>
      <link href="/2019/03/30/LaTeX%E5%88%9D%E8%AF%86/"/>
      <url>/2019/03/30/LaTeX%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>闲来无事，想起了自己当年的毕业论文，想拿来再次修改修改，看到网上很多专业人士都是使用LaTeX来写论文，似乎很流弊的样子，天呐，想想当年我还是使用的Word，就修改格式都用了大半天的时间，太可怕了，难道这就是专业人士和我们这些业余的区别！老衲怎能轻言放弃，于是乎就一顿Google，百度，看看是何方技能！传播与众人</p><h1 id="LaTeX简介"><a href="#LaTeX简介" class="headerlink" title="LaTeX简介"></a>LaTeX简介</h1><h2 id="什么是TeX"><a href="#什么是TeX" class="headerlink" title="什么是TeX"></a>什么是TeX</h2><p>电子排版系统的出现给印刷出版业带来了一场革命，利用电子计算机及各种辅助设备，可以完成从文稿、图表的录入、编辑、修改、组版，直至得到各种不同 用途、不同质量的输出结果。利用电子排版系统，可以减轻劳动强度，缩短出版周期。</p><p>目前世界上有许多电子排版系统。这些系统各有特点，也各有自己的适用范围。TeX 就是一种优秀的电子排版系统。</p><p>TeX 提供了一套功能强大并且十分灵活的排版语言，它多达 900 多条指令，并且 TeX 有宏功能，用户可以不断地定义自己适用的新命令来扩展 TeX 系统的功能。许多人利用 TeX 提供的宏定义功能对 TeX 进行了二次开发，其中比较著名的有美国数学学会推荐的非常适合于数学家使用的 AMS-TeX 以及适合于一般文章、报告、书籍的 LaTeX 系统。</p><p>TeX 系统是公认的数学公式排得最好的系统。<a href="http://www.ams.org/" target="_blank" rel="noopener">美国数学学会 （AMS）</a> 鼓励数学家们使用 TeX 系统向它的期刊投稿。世界上许多一流的出版社如 Kluwer、Addison-Wesley、牛津大学出版社等也利用 TeX 系统出版书籍和期刊。</p><p>大部分的 TeX 系统都是免费的。Knuth 教授还公开了他的全部源程序。TeX 系统目前已经在数百种计算机系统上得到实现。TeX 系统的排版结果 DVI（DeVice Independent）文件与输出设备无关。DVI 文件可以显示、打印、照排，几乎可以在所有的输出设备上输出。TeX 排版源文件及结果在各种计算机系统上互相兼容。</p><h2 id="TeX-的历史"><a href="#TeX-的历史" class="headerlink" title="TeX 的历史"></a>TeX 的历史</h2><p>七十年代末，<a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_blank" rel="noopener">Donald E. Knuth（高德纳）</a> 在看到其多卷巨著“The Art of Computer Programming”第二卷的校样时，对由计算机排版的校样的低质量感到无法忍受。因此决定自己来开发一个高质量的计算机排版系统，这样就有了 TeX 。</p><p>TeX 的名字是由大写的希腊字母“tec”(tau, epsilon, chi)组成。在希腊语中这个词的意思是“科技”和“艺术”，这也解释了它的发音。“T”和“E”就像在“technology”中的发音一样，而“x” 的发音类似于苏格兰语单词“loch”或德语单词“ach”中的“ch”，也类似于西班牙语中的“j”或俄语中的“kh”。TeX 标志为 TEX ，这三个字母相靠得很近，而且中间的那个 E 有点儿下沉。但在无格式文件中，就写为 TeX 。</p><p>TeX 的第一版于 1978 年面世。在经过了不断的改进后，1982 年版的 TeX 是一个十分稳定的版本。从此以后，TeX 没有较大的变动，只有很少部分的改进和错误修正。现在几乎所有的操作系统平台下，都有相应的 TeX 软件，而且用它们排版同一个文件得到的输出结果是相同的。TeX 目前的版本是 3.141592，很接近圆周率π。每有一新的版本，就会加上一个π的小数点后的数。所以我们已经知道下一版本的 TeX 是 3.1415926，最终将收敛到π。这也代表了 TeX 不断追求完美的理想。</p><p>TeX 的源程序是用 Pascal 写成的，原因是 Knuth 希望 TeX 尽可能方便地移植到其它的操作系统中去。当时 Pascal 是最适合于这一要求的编程语言。这也使得 TeX 现在已经在几乎所有的计算机系统中得到实现。</p><p>TeX 的另一个重要的特征就是它的输出是与设备无关的。TeX 的输出文件称为 DVI 文件，即是“Device Independent”。一旦 TeX 处理了你的文件，你所得到的 DVI 文件就可以被送到任何输出设备如打印机，屏幕等并且总会得到相同的结果，而这与这些输出设备的限制没有任何关系。这说明 DVI 文件中所有的元素，从页面设置到文本中字符的位置都被固定，不能更改。</p><p>TeX 现在已经被它的开发者 Knuth 所“冰封”(frozen)，新版本的 TeX 只有少许改进和错误修正。这些变动必须保证不会使得即使是写于 1982 年的 TeX 文档无法编译，TeX 自带了测试文件来确保这一点。如果测试文件文件的输出结果不同于预定的结果，那么这个排版系统就不能够被称为“TeX”。所以像一些对 TeX 有很大改进的软件，如“Omega”等将不能被称为“TeX”，尽管它也是基于“TeX”的。</p><p>在设计 TeX 的同时，Knuth 还设计了一个字体生成程序 MetaFont。MetaFont 是独立于 TeX 之外的，但又与 TeX 有着非常密切的联系。MetaFont 生成的只是位图字体，当对字体进行缩放时的效果不佳。对于如何得到像 Type1 字体一样的轮廓字体，现在还在研究之中。与 TeX 一样，Knuth 也“冰封”了 MetaFont 。所以 MetaFont 的进一步的改进和发展将会由其他人来完成，而且名字也将不再是 MetaFont 。</p><h2 id="TeX-的未来"><a href="#TeX-的未来" class="headerlink" title="TeX 的未来"></a>TeX 的未来</h2><p>虽然 TeX 在过去的二十多年中没有大的变化，但这并不意味着 TeX 是一个僵化的系统。恰恰相反，TeX 开放的设计使得它能够很容易的适应新的要求。例如，在没有改动内核的情形下，TeX 很容易地实现了对 PostScript 字体和外部图形的支持。TeX 还是第一个能够自动生成 HTML 的字处理软件。最近，TeX 又开始增加了在不借助其它工具（如 Adobe Distiller）的条件下生成 PDF 的扩展功能。下面列出的几个项目都是正在进行中，对 TeX 的功能进行了扩展。</p><h3 id="PDFTeX"><a href="#PDFTeX" class="headerlink" title="PDFTeX"></a>PDFTeX</h3><p>完全兼容标准的 TeX ，但能够给出 PDF 输出。它也可以输出标准的 DVI 。</p><h3 id="e-TeX"><a href="#e-TeX" class="headerlink" title="e-TeX"></a>e-TeX</h3><p>不仅完全兼容标准的 TeX ，还支持一种“扩展模式”。在“扩展模式”中引入了许多新的特性和增强功能。这些新的特性和增强功能提供了更好的编程工具和对输出的控制。</p><h3 id="Omega"><a href="#Omega" class="headerlink" title="Omega"></a>Omega</h3><p>这是一个几乎是完全重新写过的，支持 Unicode 的 TeX 程序。Omega 有很多特征都超出了 Knuth 对 TeX 的原始设想。它采用了与 TeX 不同的方法来处理字符，使得可以处理非拉丁语系的文本。也支持从右到左，从上到下的排版方式。</p><h3 id="NTS"><a href="#NTS" class="headerlink" title="NTS"></a>NTS</h3><p>NTS 代表“New Typesetting System”。Knuth 已经停止发展 TeX，并决定任何超越 TeX 的扩展都不能被称为 TeX 。NTS 只是一些对于 TeX 的后续继承者的设想和概念的集合，还不是一个实际上的系统。该项目的第一个公布的产品就是 e-TeX。后来不知什么缘故，NTS的开发就停止了。直到 2002 年左右，一些 TeX 专家，想用 Java 开发 TeX，于是把中途夭折的 NTS 项目捡了起来，搞出了一个叫做 ExTeX 的东西，但是并没有普遍应用。</p><h3 id="MLTeX"><a href="#MLTeX" class="headerlink" title="MLTeX"></a>MLTeX</h3><p>这个 TeX 的扩展引入了命令 \charsubdef，使得可以更为简单方便的使用 8 bit 字符。不过，与 e-TeX 相比，这只是一个微小的改进。</p><h3 id="XeTeX"><a href="#XeTeX" class="headerlink" title="XeTeX"></a>XeTeX</h3><p>Jonathan Kew 在 e-TeX 基础上添加 Unicode 支持，并且连接 Mac OS X 的各种技术，比如ATT,Quartz,QuickTime，产生了一个重要的TeX分支，叫做XeTeX.XeTeX在2005/6年陆续发布了它的 Windows 和 Linux版本，最终集成在 TeXLive 2007 当中，标志着它被广泛地认可。在 XeTeX 中，使用多国语言，变得非常轻松，并且可以方便地使用系统的 TrueType 和 OpenType 字体，因此得到许多 TeX Guru 的喜爱。</p><h3 id="LuaTeX"><a href="#LuaTeX" class="headerlink" title="LuaTeX"></a>LuaTeX</h3><p>尽管 Omega 项目在开始时看上去很有希望，但是它的开发进展缓慢并且功能上也非常不稳定（基本上可以认为这个项目已经死亡）。于是，Giuseppe Bilotta 等人启动了 Aleph 项目，目的是让 Omega 稳定并且引入了 e-TeX 的扩展功能。后来 Aleph 项目现在也停止了，不过它的大部分功能都被集成到了 <a href="http://wiki.ctex.org/index.php?title=LuaTeX&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">LuaTeX</a> 中。<a href="http://wiki.ctex.org/index.php?title=LuaTeX&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">LuaTeX</a> 是一个新的 TeX 引擎项目，由科罗拉多州立大学（Idris Samawi Hamid 的东方 TeX 项目）和 NTG 资助，该项目于 2006 年启动，于 2007 年夏季发布首个 beta 版本。</p><p>LuaTeX 是 Aleph 与 pdfTeX 项目的继任者，主要由 Taco Hoekwater 开发。除了兼有 Aleph 和 pdfTeX 的功能之外，LuaTeX还具有以下特点：</p><ul><li>内部集成了轻量级的动态编程语言 Lua，可以采用该语言扩展 LuaTeX 功能或宏包；</li><li>提供了 OpenType 字体的本地支持，与 XeTeX 做法不同的是，LuaTeX 没有使用操作系统自带的字体库来访问字体，而是使用了 FontForge库；</li><li>内部集成了 MPLib（一个扩展的 MetaPost 库模块）。</li></ul><h2 id="TeX-的优点"><a href="#TeX-的优点" class="headerlink" title="TeX 的优点"></a>TeX 的优点</h2><p>在一个充斥着“所见即所得”(WYSIWSG)桌面出版软件的情况下来使用 TeX 确是有点令人奇怪。但是，在某些情形下，你会感到 TeX 是最好的，甚至是唯一适合的系统。</p><p>首先我们来看一下 TeX 的优势所在：</p><ul><li><strong>高质量的输出</strong> TeX 遵循传统的排版规则，以排版的质量为最重要的目标。如果你把 TeX 的输出结果和用其它的排版软件排版相同的文本所得到的结果加以比较，你就会发现其中的区别。</li><li><strong>超常的稳定性</strong> 自从 TeX 出现以来，只有一些微小的改动。也就是说，十几年前的 TeX 文件用现在的 TeX 系统排版得到的结果与十几年前得到的结果是一样的。稳定性还体现在 TeX 系统极少会崩溃，可以处理任意大小的文件，即使你的计算机的内存很少，TeX 也可自如的工作。</li><li></li><li><p><strong>TeX 是可编程的</strong> TeX 是一种宏命令编程语言。你可以用很少的命令来完成非常复杂的工作。如果需要的话，你也可以重新定义 TeX 的所有命令来得到特殊的效果。</p></li><li><strong>高度的灵活性</strong> TeX 自从出现以来其内核只有微小的改动。但是由于其内核的设计方式，世界上的 TeX 使用者可以让 TeX 做几乎任何工作。你可以用 TeX 来排版英文文本，也可以排版德文，俄文，中文等多种语言。你还可以用 TeX 来排版乐谱，象棋，围棋棋谱等等。</li><li><strong>简单方便</strong> TeX 文档是 ASCII 码的文本文件。因此，即使你手边没有 TeX 系统，你也可以看懂绝大部分的内容。TeX 文件的这种特点使得它占用很少的存储空间，也可以很方便的用 email 来传输。</li><li><strong>良好的通用性</strong> 目前为止，TeX 几乎在所有的计算机操作系统平台上得到实现。如：Atari，Apple，Macintosh，Unix，VMS，MS-DOS，MS-Windows 和 OS/2 等等。TeX 的源文件可在不同的平台之间自由的交换，而得到的输出是完全相同的。</li><li><strong>低廉的价格</strong> TeX 是免费软件，它的源程序也是免费的。你可能仅仅需要支付邮费，甚至于一分不花地得到适合你的 TeX 系统。世界上有很多非常好的 TeX 免费软件如：teTeX，MikTeX，fpTeX 等等。同时也有一些具有各自特点（如或多或少的所见即所得特性的）和提供专家级帮助系统的商业版本。</li><li><strong>超级技术支持</strong> 由于 TeX 并不是被某个公司所垄断开发，所以世界各地的使用者设计了统一的技术支持的方式。这通常是通过因特网以 email, WWW, Usenet 或 Ftp 的方式来提供，有时也可能通过电话或传真的方式。绝大多数情况下这些技术支持都是免费的，这也是 TeX 的精神。</li><li><strong>TeX 是一种乐趣</strong> 使用 TeX 不仅仅是一种工作手段，也是一种乐趣。它有挑战，也有荣誉。很多人在熟悉了 TeX 之后都开始把使用 TeX 作为一种爱好，而不是一件枯燥无味的劳动。</li></ul><h2 id="TeX-的不足"><a href="#TeX-的不足" class="headerlink" title="TeX 的不足"></a>TeX 的不足</h2><p>在展示了 TeX 的优秀之处后，也得承认 TeX 也有一些不足的地方：</p><ol><li>TeX 不是在一个下午就能完全学会的，除非你是一个真正的天才。当你开始学习并使用它的时候，你将会不停的去翻看 TeX 的参考手册来寻找一个 TeX 命令。你也会发现 TeX 常常不理会你键入的命令，还给出一个让你感到迷惑的错误讯息。这一切都说明了掌握 TeX 需要一个比较长而且艰难的学习过程。TeX 的一些扩展如 LaTeX、ConTeXt 则要相对简单的多，使用起来也比 TeX 方便，一个新手完全可以在一个下午或者更短的时间内学会开始使用 LaTeX 或 ConTeXt。</li><li>当发生错误的时候，TeX 会给出一些信息来提示你。但很多情况下并不足以是你迅速准确的找到错误之所在。尤其对刚刚开始学习的新手来说更是如此。</li><li>像 TeX 这种宏语言不同于其它的计算机语言，如 C，Pascal 等，大多数人并不了解。因此，当你想要写自己的宏命令时，你需要对 TeX 有比较深入的了解才能写出牢固可靠的宏命令。</li><li>TeX 不是所见即所得的。尽管市场上有些近似于所见即所得的自由/开源软件（如 <a href="http://www.lyx.org/" target="_blank" rel="noopener">LyX</a>）或商业软件，但即使与最普通的字处理软件比，也 还是有不小的差距。</li></ol>]]></content>
      
      
      <categories>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇-杂谈WebGIS</title>
      <link href="/2019/03/30/%E6%9D%82%E8%B0%88WebGIS/"/>
      <url>/2019/03/30/%E6%9D%82%E8%B0%88WebGIS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>我相信大家对百度地图，谷歌地图等相关应用已经是非常熟悉了。通过这些应用，我们可以浏览地图、定位我们自己的位置、查找我们想知道的兴趣点、搜索交通路线等等。而其实，这些功能便是WebGIS的一些最基本的功能。</p><p>那么什么是WebGIS呢，说到这里，我还是首先给大家讲讲什么是GIS。</p><h2 id="2．GIS简介"><a href="#2．GIS简介" class="headerlink" title="2．GIS简介"></a>2．GIS简介</h2><h3 id="2-1-GIS的名词解释"><a href="#2-1-GIS的名词解释" class="headerlink" title="2.1 GIS的名词解释"></a>2.1 GIS的名词解释</h3><p>GIS的全名是Geographic Information System，中文全名是地理信息系统。它是在计算机硬、软件系统支持下，对整个或部分地球表层（包括大气层）空间中的有关地理分布数据进行采集、储存、管理、运算、分析、显示和描述的技术系统。</p><h3 id="2-2-什么是GIS学科"><a href="#2-2-什么是GIS学科" class="headerlink" title="2.2 什么是GIS学科"></a>2.2 什么是GIS学科</h3><p>撇开这些晦涩的文字，我争取用更形象的方法来给大家介绍下GIS这个学科。</p><p>我们人类在很久之前就已经开始使用羊皮或者纸质的地图了，他的用途主要便是给人们的行军、航海等做向导，而这同样也是现代GIS学科里GIS最基本的功能之一。到19世纪时，现代GIS学科开始慢慢萌芽。这里有一个很有名的例子。1854年伦敦发生霍乱，10天就死了500人。居民大多怀疑瘟疫是由于地下的墓穴引起的，引起了极大的社会恐慌。当时有个有名的医生叫Snow博士，他不信这个原因，为了查出真正的霍乱源头，他首先绘出了伦敦地图，然后将所有霍乱病人的所在地标出来，然后他发现了一个有趣的现象，在伦敦的一个居民饮水井附近出现的霍乱病人最多，并且最开始出现的霍乱病人也是在那里发现的。最后Snow博士对那口井进行检查，确定了霍乱发生的源头。从这个例子中我们可以看出，地图的应用已经不再局限于导航了，而开始慢慢利用其得天独厚的时间空间优势与其他学科开始进行结合。</p><p>到了20世纪电脑的出现，人造卫星的升天等技术的突破，GIS这个学科也相应的开始走向成熟以及开始普及。20世纪60年代，加拿大科学家首先提出了GIS这个学科。到了20世纪末，一大批优秀的GIS软件已经出现，比如Esri公司的ArcGIS系列，MapInfo公司的MapInfo。国内的GIS从上世纪80年代才开始起步，不过到上世纪末时，也出现了自己的GIS公司，比较有名的有GeoStar、MapGIS等。</p><p>而此时的GIS已不再是局限纸上的地图了，它已经成为了一个计算机技术和多种学科相交叉的新型学科了。它涉及到测量学——地理信息的采集和地图的制作等，计算机科学——电子地图的制作和展现以及各种GIS功能的实现，物理学——对传感器的研究以及光谱和影像的研究，气象学——大气层等对卫星影像的影响等，生物学、医学、犯罪学等——研究地理等各时间空间因素对这些学科的影响。</p><p>GIS是什么呢，说的最通熟易懂的就是，GIS是利用测绘生成纸制地图或者航拍以及卫星等生成影像后，将这些数据存储在计算机中，以地图或图片的形式表现出来，然后根据实际生产生活以及科研中的各种需求，进而提供具体的经过处理后的数据。</p><h2 id="3-WebGIS简介"><a href="#3-WebGIS简介" class="headerlink" title="3.WebGIS简介"></a>3.WebGIS简介</h2><h3 id="3-1什么是WebGIS"><a href="#3-1什么是WebGIS" class="headerlink" title="3.1什么是WebGIS"></a>3.1什么是WebGIS</h3><p>顾名思义，WebGIS就是展现于网络上的GIS。在上世纪八十年开始，出现的大量GIS软件，基本上都是C/S架构的，也就是首先需要在本机上装有专业的GIS软件，然后用户根据需求使用这些GIS软件。当然这种桌面端的GIS软件有其天然的优势，比如开发相对简单，不需要Internet支持，以及可以做更多的复杂功能、响应相对迅速等优势。但是同时，其缺点更是不容忽视。首当其冲的便是不便于推广，而不便于推广的原因在于C/S系统其本身的天然的劣势：不便于更新，不便于跨平台，不便于用户在不安装指定客户端的情况下使用。</p><p>从本世纪开始，internet进入了爆发式增长阶段，网络的铺设以及网速的提升都有了大幅度增加，这为WebGIS的发展提供了坚实的大环境。于是，基于B/S的GIS系统越来越多的开始提供服务，并且在RIA（富客户端）技术、AJAX（动态网页）技术的涌现和成熟，WebGIS也基本能展现出与C/S一样的效果和功能。而WebGIS的大发展，更是用户的需求，google地图和百度地图等服务提供商的大规模扩张便是最好的证明。</p><p>什么是WebGIS，就是将GIS这门学科所能提供的功能，以B/S技术展现给用户，使用户只需要在浏览器上便能使用这些GIS功能的一个应用方向。</p><h3 id="3-2对国内WebGIS行业的理解"><a href="#3-2对国内WebGIS行业的理解" class="headerlink" title="3.2对国内WebGIS行业的理解"></a>3.2对国内WebGIS行业的理解</h3><p>目前使用WebGIS技术的公司可以大致分为两个方向：一个是互联网方向，一个是行业应用方向。</p><p>国内的互联网方向里基本可以说已经被百度地图，搜搜地图，高德地图，三个巨头垄断。所以对于想从事互联网方向的WebGIS开发人员，其实可以选择的大公司并不多。但是，如果你是一个技术足够好，且技术不局限于一般的关系数据库，对大数据和分布式系统感兴趣的WebGIS开发人员，强烈建议你去这些互联网公司，在那里你能接触到最新的IT技术以及感受到强大的头脑风暴。也便是，对新技术，对前沿方向有更多追求的人，去互联网公司是很好的选择。</p><p>但是我们不得不承认另外一个现实，这些互联网公司基本集中在北上广深，并且对GIS研发人员在技术上的需求是，计算机技术的比重要远大于对GIS学科本身的理论所占的比重。于是，更多的GIS学科出身的人，最后选择的是行业应用公司。而投身于这样的公司，就没有前途吗？答案是否定的。</p><p>Esri公司作为全球最成功的GIS软件公司，很好的给出了这个答案。目前Esri的AO库号称世界上第二大的库，除了微软的Framework，就是它了。它同时也是一个年盈利在8亿美元的公司。Esri公司与美国和加拿大政府的合作堪称行业公司的典范，它为这两个国家的数字化城市的建设立下了汗马功劳，做出了很多优秀的作品。说这个例子，只是为了表明，在我们的数字化城市的需求越来越深入，政府的需求越来越实际，整个国家的市场建设越来越合理以及公平公正透明，WebGIS在行业上的应用也将越来越广泛，并且越来越能够服务政府、企业和人民，并且更能做出有真实价值的产品。并且，从事行业应用的研发人员，随着对所从事行业理解的深入，这些理解给未来所带来的收获可能比技术单纯的提高所带来的收获要大得多。要知道，项目需求分析靠的基本是行业理解，当然，对技术的了解也给项目可行性分析提供了保障。两者相辅相成。</p><p>每个人追求不一样，根据自己的需求，根据自己的现状，做出选择，坚持下去，不说梦想是否能实现，起码你不会是一个自己都认为自己活该如此平庸的人。</p><h2 id="4-WebGIS的框架"><a href="#4-WebGIS的框架" class="headerlink" title="4.WebGIS的框架"></a>4.WebGIS的框架</h2><p>前面说了太多的非技术类的话，这里我们开始提一个技术类话题——WebGIS的框架。其实WebGIS的框架跟其他Web项目的框架没有很多本质上的区别。可能唯一的不同是WebGIS需要提供一些地图方面的功能服务。这里我先把这个框架给出，同时每个层面需要的技术我也在其中大致画出。</p><p>​                                    <img src="https://images0.cnblogs.com/i/656746/201408/021630108995466.png" alt="img">                    </p><p>​                                       </p><h3 id="4-1前端"><a href="#4-1前端" class="headerlink" title="4.1前端"></a>4.1前端</h3><p>如所有的Web项目一样，前端由HTML、CSS、JS、Flex等语言组成。根据需求和语言的特性，选择合适的语言进行开发是至关重要的。没有最好的语言，只有最合适的语言。</p><h3 id="4-2-后台程序"><a href="#4-2-后台程序" class="headerlink" title="4.2 后台程序"></a>4.2 后台程序</h3><h4 id="4-2-1-中间件"><a href="#4-2-1-中间件" class="headerlink" title="4.2.1 中间件"></a>4.2.1 中间件</h4><p>开发时，我们要选择适合自己的中间件。不同的中间件有其特性，如果是一般项目，tomcat等是很合适的，其使用方便，相关技术支持和资料也很好查找。但是如果是大型的集群项目，Weblogic和WebShpere可能是更好的选择，但是这两个中间件首先配置就是有难度的，同时不同的版本，可能对某些jar包的支持存在问题。如果项目必须使用国产的中间件，TongWeb和Apusics是不错的选择。</p><h4 id="4-2-2-地图服务器"><a href="#4-2-2-地图服务器" class="headerlink" title="4.2.2 地图服务器"></a>4.2.2 地图服务器</h4><p>在WebGIS中，与其他一般的Web工程有明显区别的就体现在地图服务器上面。一般的地图服务器都由已有的软件商提供了解决方案，比较流行的有AGS、Geoserver、MapServer、SuperServer等。利用这些地图服务器我们能很好的实现地图的发布以及对一些空间查询和空间操作的支持。</p><h4 id="4-2-3-业务服务器"><a href="#4-2-3-业务服务器" class="headerlink" title="4.2.3 业务服务器"></a>4.2.3 业务服务器</h4><p>业务服务器是Web项目里不可获取的一环。不管是利用哪些已有框架编写，比如Spring、Struts、Hibernate等，我们一般还是会将业务服务器的实现分为三个层次，即有名的MVC模式。而不同的框架里这三个层次的实现各有差别。</p><h3 id="4-3-数据"><a href="#4-3-数据" class="headerlink" title="4.3 数据"></a>4.3 数据</h3><p>WebGIS的数据大致可以分为三种，一种是地图、影像数据，一种是空间属性数据、一种是业务数据。地图、影像数据一般是一些png或者其他格式的数据组成。</p><p>在GIS中有个很重要的概念，即影像金字塔。这个概念主要是为了加速地图在前端的显示。而我们准备地图、影像数据时，也一般会首先对这些数据进行切图。</p><p>空间属性数据，是通过一些工具将已经整理好的数据进行入库。对于AGS，只有连接的是入库数据的mxd，才能发布成FeatureServer服务，以供数据的编辑。当然，空间数据入库后还可以支持业务逻辑的使用。</p><p>第三种数据，业务逻辑数据，是每个Web项目必须有的，它根据不同的业务需求将业务所需的数据进行采集和入库。</p><h2 id="5-从WebGIS的原理谈起"><a href="#5-从WebGIS的原理谈起" class="headerlink" title="5.从WebGIS的原理谈起"></a>5.从WebGIS的原理谈起</h2><p>目前很多公司都提供了自己的二次开发包，在前端的有OpenLayers、AGS API for JS/Flex等。在后台的也有geoTools、AO等。用这些开发包，我们可以很快的实现出图以及很多GIS功能，基本上不用写太多的编码。</p><p>但是，同样，由于封装的太好，很多WebGIS的原理我们也便忽略而不做了解了。</p><p>这里，我希望利用我薄弱的知识，能和大家一起，探讨一些WebGIS中常用的原理知识。希望大家支持。</p><h2 id="6-感想"><a href="#6-感想" class="headerlink" title="6.感想"></a>6.感想</h2><p>由于我薄弱的理论和技术基础，也谈不上对WebGIS的明天有很大的预言。我只希望我们每个人都争取做一个完美主义者，同时也是一个有圣徒情怀的人，从而作践自己实现目标。与大家一起进步。希望我也能保持自己的写作动力，积累经验和知识。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么你得学些TCP知识</title>
      <link href="/2019/03/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BE%97%E5%AD%A6%E4%BA%9BTCP%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/03/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BE%97%E5%AD%A6%E4%BA%9BTCP%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>这不是指要明白 TCP 的所有东西，也不是说要通读 《TCP/IP 详解》。不过懂一点 TCP 知识是很有必要的。理由如下：</p><p>当我还在 Recurse Center 的时候，我用 Python 写过 TCP 协议栈（还写过一篇文章：如果你用 Python 写 TCP 协议栈会遇到什么？）。这是一次有趣的学习经历，但是也仅此而已。</p><p>一年以后，工作中有人在 Slack 上提到：“嘿，我在向 NSQ 发布消息时，每次要耗费 40 毫秒”。我已经断断续续思考了一个星期，但是没有任何结果。</p><p>一点背景知识：NSQ 是一个消息队列，你通过本地的一个 HTTP 请求向其发布消息。发送本地的一个 HTTP 请求确实不应该花费 40 毫秒，有时候会更差。NSQ 守护进程的负载不高，也没有使用过多的内存，也看不到 GC 停顿。这究竟是为什么呢？神呐，救救我吧！</p><p>突然我记起我一周以前看过的一篇叫做“性能研究（In search of performance）”的文章——我们如何为每个 POST 请求节省 200ms。在这篇文章中，他们说到为什么每个 POST 请求会花费额外的 200 毫秒。就是这个原因。这是该文章中的关键段落：</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="延迟确认（ACK）-与-TCP-NODELAY"><a href="#延迟确认（ACK）-与-TCP-NODELAY" class="headerlink" title="延迟确认（ACK） 与 TCP_NODELAY"></a><strong>延迟确认（ACK） 与 TCP_NODELAY</strong></h3><blockquote><p>Ruby 的 Net::HTTP 会将 POST 请求切分为两个 TCP 包，一个消息头，一个消息体。相反，curl 会将这两者合并为一个包。更糟糕的是，Net::HTTP 在打开 TCP 套接字时不会设置 TCP_NODELAY，这将导致第二个包需要等到第一个包的接收确认通知之后才能发送。这是 Nagle 算法导致的。</p></blockquote><blockquote><p>转换到连接的另一端，HAProxy 需要决定如何确认这两个包。在 1.4.18 版本中（我们正在用的版本），它是通过 TCP 延迟确认通知来实现的。延迟确认对 Nagle 算法有非常糟糕的影响，会导致请求暂停直到服务器延迟确认超时。</p></blockquote><p>现在我们解释这个段落说的内容。</p><ul><li>TCP 是一个通过数据包传输数据的算法</li><li>他们的 HTTP 库将 POST 请求分割成两个小的数据包发送</li></ul><p>接下来，TCP 采用类似如下的步骤进行交互：</p><blockquote><p>application：Hi！这里有一个数据包。<br>HAProxy：（沉默），等待第二个包发送<br>HAProxy：对了，我需要返回一个确认，不过没关系，等会吧<br>application: （沉默）<br>application：好吧，我正在等待确认，可能现在网络延迟比较大<br>HAProxy：好吧，太烦人了，这是一个确认。<br>application：好极了，这是第二个数据包！！！<br>HAProxy：亲，我们已经搞定了。</p></blockquote><p>这个过程是不是应用程序和 HAProxy 都在消极等待另一方发送信息？这就是那额外的 200ms。应用程序这么做的是因为 Nagle 算法，而 HAProxy 消息等待的原因是延迟确认。</p><p>据我所知，延迟确认是所有 Linux 系统的默认行为。所以这不是一个偶然或者异常情况，如果发送 TCP 数据包多一个 1 个，你就会遇到这种情况。</p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="现在，我们成为专家了"><a href="#现在，我们成为专家了" class="headerlink" title="现在，我们成为专家了"></a><strong>现在，我们成为专家了</strong></h3><p>读过这篇文章之后我很快就忘了。不过当我被额外的 40 毫秒难住的时候，我又记起来了。</p><p>所以我认为——这不可能是我的问题，可能吗？可能吗？？然后我发了一封邮件给我团队说：“我想我快要疯了，但是这可能是 TCP 的问题”。</p><p>所以我提交了一次修订，将我的应该调整为 TCP_NODELAY，然后问题就“嘣”的一声解决了。</p><p>40 毫秒的延迟立马就消失了。所有的事情都解决了，我就是个天才。</p><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="我们是否应该完全停止使用延迟确认？"><a href="#我们是否应该完全停止使用延迟确认？" class="headerlink" title="我们是否应该完全停止使用延迟确认？"></a><strong>我们是否应该完全停止使用延迟确认？</strong></h3><p>我刚好在 Hacker News 看到 John Nagle （Nagle 算法的创始人）对 @alicemazzy 提到这个问题的评论。</p><blockquote><p>本质问题是延迟确认。200 毫秒的“延迟确认”是一个非常不好的主意，1985 年中，在伯利克（Berkeley）研究 BSD 的人实际上没有真正明白这个问题。延迟确认是应用层对 200 毫秒内是否响应的一场赌博，但是即便每次它都赌输了，TCP 仍在使用延迟确认。</p></blockquote><p>他继续说到，确认本身是很小并且消耗很低的，延迟确认引起的问题可能比它解决的问题还要多。</p><h3 id="不懂得-TCP-你就无法解决-TCP-问题"><a href="#不懂得-TCP-你就无法解决-TCP-问题" class="headerlink" title="不懂得 TCP 你就无法解决 TCP 问题"></a><strong>不懂得 TCP 你就无法解决 TCP 问题</strong></h3><p>我曾经也认为，TCP 是一个相当底层的问题，我不需要明白。大多数时候你的确不需要明白。但是有的时候，当你在实践中遇到由于 TCP 算法引起的 bug 时，懂点 TCP 知识就变得非常重要了。（正如我们经常在博客中讨论的，许多事情都是这样，比如系统调用和操作系统:) ）</p><p>延迟确认及 TCP_NODELAY 的交互非常不好——这对任何语言实现的 HTTP 请求都有影响。你不需要很深入的去了解，成为系统程序专家。但是了解一点 TCP 是如何运作的，对我的工作的确大有裨益。通过对 TCP 的学习，我才意识到这篇博客所描述的问题也许正好是我所熟悉的领域。我也一直在使用 strace，并且会一直使用下去。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度解密 HTTP 通信细节</title>
      <link href="/2019/03/29/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86HTTP%E9%80%9A%E4%BF%A1%E7%BB%86%E8%8A%82/"/>
      <url>/2019/03/29/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86HTTP%E9%80%9A%E4%BF%A1%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>在上一篇《<a href="https://llqing.github.io/2019/03/28/san-ci-wo-shou-si-ci-hui-shou-ni-zhen-de-dong-ma/">“三次握手，四次挥手”你真的懂吗？</a>》中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的 <code>锤子</code>，拿着 <code>锤子</code>，看什么都像 <code>钉子</code>！在这篇文章中，我对准了 <code>HTTP</code>这颗钉子砸下去，咳咳。</p><p>为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我则是把复杂的东西撕碎了给人看。</p><p>文章稍长，请在看本文时保持耐心。我先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！</p><p>为了更好的阅读体验，我手动贴上本文的目录：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cjHbwiaFiaXcneDwD5tV48jf8JedJ22VnrWluok7iaZyP2aHSUfTeaRW9A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id="HTTP报文截获"><a href="#HTTP报文截获" class="headerlink" title="HTTP报文截获"></a>HTTP报文截获</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我手头现在有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是 <code>Fence2Area</code>. 使用方传入一个围栏（由点的列表组成，点由&lt;经度，纬度&gt;表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。</p><p>我请求服务的“Fence2Area”接口，输入围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，输出的则是多边形的面积(area).</p><p>一次正常的请求示例url, 这个大家都不陌生（我用docker_ip代替真实的ip）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>请求发出后，服务器进行处理，之后，客户端收到返回的数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;data&quot;: &#123;        &quot;area&quot;: 48764135597.842606    &#125;,    &quot;errstr&quot;: &quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p><code>area</code>字段表示面积， <code>errstr</code>表示出错信息，空说明没有出错。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>在真正发送请求之前，需要进行抓包前的设置。在本地mac，我用wireshark; 而在远程docker上，我用tcpdump工具。</p><h3 id="mac本地"><a href="#mac本地" class="headerlink" title="mac本地"></a>mac本地</h3><p>设置wireshark包过滤器，监控本地主机和远程docker之间的通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr eq docker_ip</span><br></pre></td></tr></table></figure><p>点击开始捕获。</p><h3 id="远程docker"><a href="#远程docker" class="headerlink" title="远程docker"></a>远程docker</h3><p>该服务通过7080端口对外提供，使用如下命令捕获网络包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w /tmp/testHttp.cap port 7080 -s0</span><br></pre></td></tr></table></figure><h2 id="请求-amp-amp-分析"><a href="#请求-amp-amp-分析" class="headerlink" title="请求 &amp;&amp; 分析"></a>请求 &amp;&amp; 分析</h2><p>准备工作做完，我选了一个神圣的时刻，在本地通过浏览器访问如下url:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。</p><h3 id="关闭服务进程"><a href="#关闭服务进程" class="headerlink" title="关闭服务进程"></a>关闭服务进程</h3><p>正式请求之前，我们先看一下几种特殊的情形。</p><p>首先，关闭gcs服务进程，请求直接返回RST报文。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1ib1lViaLiaASe6wCNRxwB8Xu769ic09sS7T7GbjkibZ1PUiae36SP7D4ntg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>如上图，我在请求的时候，访问服务端的另一个端口 <code>5010</code>, 这个端口没有服务监听，和关闭gcs服务进程是同样的效果。可以看到，客户端发送SYN报文，但直接被远程docker RST掉了。因为服务端操作系统找不到监听此端口的进程。</p><h3 id="关闭docker"><a href="#关闭docker" class="headerlink" title="关闭docker"></a>关闭docker</h3><p>关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbJoZcwl0vLPpwOqVb8B6XiaveJosgAibblK0IXaicGVEPXC1poXhQEohw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。</p><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><p>先进行一次正常的访问，随后重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，访问到服务端后，因为它已经重启了，所以服务端已经没有这个连接的消息了。因此会返回一个RST报文。</p><h3 id="正常请求"><a href="#正常请求" class="headerlink" title="正常请求"></a>正常请求</h3><p>服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckxkrMtp9vRhDDluuIBFDcK8tyfSNq6Mibu1bFL83korLAUfUyxT8qKg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为 <code>HTTP</code>层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在 <code>HTTP</code>层发送的响应数据，第七个包为mac对第六个包的确认报文。</p><p>重点来关注后面几个包，先看第四个包，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0295 0000 4000 3606 623b ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d0x0020:  8018 1015 0ee7 0000 0101 080a 2e4c b2ef0x0030:  0f20 3acf 4745 5420 2f64 6174 613f 636d0x0040:  643d 4665 6e63 6532 4172 6561 266d 65740x0050:  613d 7b25 3232 6361 6c6c 6572 2532 323a0x0060:  2532 3274 6573 7425 3232 2c25 3232 54720x0070:  6163 6549 6425 3232 3a25 3232 7465 73740x0080:  2532 327d 2672 6571 7565 7374 3d7b 25320x0090:  3266 656e 6365 2532 323a 5b7b 2532 326c0x00a0:  6e67 2532 323a 3130 2e32 2c25 3232 6c610x00b0:  7425 3232 3a31 302e 327d 2c25 3230 7b250x00c0:  3232 6c6e 6725 3232 3a31 302e 322c 25320x00d0:  326c 6174 2532 323a 382e 327d 2c25 32300x00e0:  7b25 3232 6c6e 6725 3232 3a38 2e32 2c250x00f0:  3232 6c61 7425 3232 3a38 2e32 7d2c 25320x0100:  307b 2532 326c 6e67 2532 323a 382e 322c0x0110:  2532 326c 6174 2532 323a 3130 2e32 7d5d0x0120:  2c25 3232 636f 6f72 6474 7970 6525 32320x0130:  3a32 7d20 4854 5450 2f31 2e31 0d0a 486f0x0140:  7374 3a20 3130 2e39 362e 3932 2e32 31320x0150:  3a37 3038 300d 0a55 7067 7261 6465 2d490x0160:  6e73 6563 7572 652d 5265 7175 6573 74730x0170:  3a20 310d 0a41 6363 6570 743a 2074 65780x0180:  742f 6874 6d6c 2c61 7070 6c69 6361 74690x0190:  6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 70700x01a0:  6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d300x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 55730x01c0:  6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c0x01d0:  612f 352e 3020 284d 6163 696e 746f 73680x01e0:  3b20 496e 7465 6c20 4d61 6320 4f53 20580x01f0:  2031 305f 3133 5f36 2920 4170 706c 65570x0200:  6562 4b69 742f 3630 352e 312e 3135 20280x0210:  4b48 544d 4c2c 206c 696b 6520 4765 636b0x0220:  6f29 2056 6572 7369 6f6e 2f31 322e 302e0x0230:  3220 5361 6661 7269 2f36 3035 2e31 2e310x0240:  350d 0a41 6363 6570 742d 4c61 6e67 75610x0250:  6765 3a20 7a68 2d63 6e0d 0a41 6363 65700x0260:  742d 456e 636f 6469 6e67 3a20 677a 69700x0270:  2c20 6465 666c 6174 650d 0a43 6f6e 6e650x0280:  6374 696f 6e3a 206b 6565 702d 616c 69760x0290:  650d 0a0d 0a</span><br></pre></td></tr></table></figure><p>我们来逐字节分析。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cESQM7mPYK50BUdqRtB4qISMY5VjrFYEL4fEVDMgMquTHMqhekaY2AA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTZn8gROeqs1ncqfs0lrbUic92cGeHU3xrZr76pslib22mnVPmXjz3DOA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure><p>可以得到ascii码，我们直接看十六进制的结果：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c0dZYr61gHv0qYGlBIVEM3zr6RIxqxW2s7ia5lRnAkgLzQVCfeovialmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cPt3Eicksdp2tfV1hJJcRPLib1SFEGno5wwa9rtDaQJOomYhp9focEribQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>把上表的最后一列连起来，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125; HTTP/1.1 Host: 10.96.92.212:7080 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15 Accept-Language: zh-cn Accept-Encoding: gzip, deflate Connection: keep-alive</span><br></pre></td></tr></table></figure><p>其中，cr nl表示回车，换行。</p><p>docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。另外，序列号为2778351310.</p><p>再来看第5个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 d28b 4000 4006 8810 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8010 00ec e04e 0000 0101 080a 0f20 3af70x0030:  2e4c b2ef</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cAZEWxWx96R82g4YMAKmw1BAibT6xxBcL1kjJf3fGaUqDFLGNLjleFsA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbI0RpST1AwXnJm99vUPedSEW5vsjxhIMfpnnVPqUMMfpib6ibkkWEcTQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnkkiao15MgfVBSI2lAicn9OKJwwmppIic9fxfpJkH5nHOyaoKGtnP8iakQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>数据部分为空，这个包仅为确认包。</p><p>再来看第六个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 00f9 d28c 4000 4006 874a 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8018 00ec e113 0000 0101 080a 0f20 3af80x0030:  2e4c b2ef 4854 5450 2f31 2e31 2032 30300x0040:  204f 4b0d 0a41 6363 6573 732d 436f 6e740x0050:  726f 6c2d 416c 6c6f 772d 4f72 6967 696e0x0060:  3a20 2a0d 0a44 6174 653a 2054 6875 2c200x0070:  3033 204a 616e 2032 3031 3920 3132 3a320x0080:  333a 3437 2047 4d54 0d0a 436f 6e74 656e0x0090:  742d 4c65 6e67 7468 3a20 3438 0d0a 436f0x00a0:  6e74 656e 742d 5479 7065 3a20 7465 78740x00b0:  2f70 6c61 696e 3b20 6368 6172 7365 743d0x00c0:  7574 662d 380d 0a0d 0a7b 2264 6174 61220x00d0:  3a7b 2261 7265 6122 3a34 3837 3634 31330x00e0:  3535 3937 2e38 3432 3630 367d 2c22 65720x00f0:  7273 7472 223a 2222 7d</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c4iaw0WsWa7KbicwicrJbrVm82c1z3OOQuCBG8MnezL90gSGbEWv5p1wLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0chROjPEbF98pwdNNGm56BqMY5TJhQ4UCMZQibicgkxxJum4EkLSoDKyHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩下来的就是数据部分了。我们一行一行地看。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cf9reib3oq2gOJVfkdHdEafO0t7ZibzwACqJl9F1BVonYzlXOib1orDpiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>把上表的最后一列连起来，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK Access-Control-Allow-Origin: * Date: Thu, 03 Jan 2019 12:23:47 GMT Content-Length: 48 Content-Type: text/plain; charset=utf-8 &#123;&quot;data&quot;:&#123;&quot;area&quot;:48764135597.842606&#125;,&quot;errstr&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p>Content-Length: 48，最后一行的长度即为48个字节。</p><p>最后，第七个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 0000 4000 3606 649c ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e9420x0020:  8010 100f 1eb9 0000 0101 080a 2e4c b3140x0030:  0f20 3af8</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0czCoePYTJlUT7ry6wUOC5sib1phKyp1odVXVHxGwmCVjZAxHfnQ6ugrA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cQcJTJtCqC5uUlc8fH3gCIvcR8FV3ayZu6LIBXVR32aUJGHDLK2Al8g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>至此，一次完整的http请求的报文就解析完了。感觉如何，是不是很亲切？</p><h1 id="HTTP协议分析"><a href="#HTTP协议分析" class="headerlink" title="HTTP协议分析"></a>HTTP协议分析</h1><p>上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步带你深入理解HTTP协议。</p><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><p><code>HTTP</code>(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。说得更形象一点： <code>HTTP</code>是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。</p><p>HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cd3E2bpHQ1JibJo1Cks0PtU75BD8UsUZQMIuutqGxuxDXqIbJicibk0NiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>HTTP在传输一段报文时，会以 <code>流</code>的形式将报文数据的内容通过 <code>一条打开</code>的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cvS3b6LIgaPLTfa4gdcLHKRMQV8A4mZF0Gux7vhwiapGLyB2tYFrrFew/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们再来回顾一下：</p><p>原始的url值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>编码后的url值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125;</span><br></pre></td></tr></table></figure><p>在之前的报文拆解过程中，我们看到多了很多 <code>%22</code>，其实， <code>0x22</code>是单引号 <code>&quot;</code>的ascii值，</p><p>一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，比如空格；最后，URL还得是完整的，它需要支持所有语言的字符。</p><p>总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。</p><p>转义的方法：百分号( <code>%</code>)后跟着两个表示ASCII码的十六进制数。比如：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ca1ibSClFurjoccZUHYENZbYZrf2opPyvfdM8Ll5770Uic6YaVsZXbLVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。</p><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p>响应数据中，我们注意到有一个首部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/plain; charset=utf-8</span><br></pre></td></tr></table></figure><p>互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的 <code>Content-Type</code>. MIME本来是用在邮件协议中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，是该展示图片，还是调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表展示了一些常见的类型，其中的实体主体是指body部分：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cibw7k636Y9k3xns3JuiapnxqgZzmqxXanpLUUk8VSYiclBGy1Gx4dgiawA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>URI/URL/URN</p><p>URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator, 统一资源定位符)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。</p><p>URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！</p><p>URL通常的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议方案+服务器地址+具体的资源路径</span><br></pre></td></tr></table></figure><p>协议方案(scheme)，如 <code>http</code>, <code>ftp</code>，告知web客户端怎样访问资源)；服务器地址，如 <code>www.oreilly.com</code>; 具体的资源路径，如 <code>index.html</code>.</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。这样，客户端可以获取即将请求资源的一些情况，可以做到心中有数。</p><p>POST用于向服务器发送数据，常见的是提交表单；PUT用于向服务器上的资源存储数据。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 OK 404 Not Found500 Internal Server Error</span><br></pre></td></tr></table></figure><p>我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是 <code>404NotFound</code>会穿透重重迷雾，来到我们面前，为何？那是因为他对我们爱的深沉啊！</p><p>客户端可以据此状态码，决定下一步的行动（如重定向等）。</p><p>三位数字的第一位表示分类：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cWscDzeA52lJGamzgqvAYianNebt2zoaHENFaJqrcOqjDTrTxgia5SGmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>HTTP报文实际上是由一行行的字符串组成的，每行字符串的末尾用 <code>\r\n</code>分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说 <code>0x0001</code>表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。不可能像HTTP协议这样，直接将字符编码，人类可以直接读懂。</p><p>举个简单的请求报文和响应报文的格式的例子：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cq5mHY7JwsGkIib9iazsoJk53tRRoc03B4GNgtLhpUjrsciaS0LGwW8nzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>实际上，请求报文也是可以有body（主体）部分的。请求报文是由 <code>请求行（request line）、请求头部（header）、空行、请求数据</code>四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的 <code>回车换行</code>符也是必须要有的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cozZdAPcASb3UUqYcqiaQuUvWgugEuaMu6Y3aiaxEia0ENTzVqvX8c9hgg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>响应报文的格式和请求报文的格式类似：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。</p><p>有些首部是通用的，有些则是请求或者响应报文才会有的。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后就可以通过这个通道直接发送HTTP请求数据，获取响应数据了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cFxrl1hgDlibWeYcEAMjgowiaZYLyf6FnsEuFr96UWxwicxDLLY44xPcuQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id="HTTP协议进阶"><a href="#HTTP协议进阶" class="headerlink" title="HTTP协议进阶"></a>HTTP协议进阶</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>HTTP的代理服务器既是Web服务器，又是Web客户端。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c98UALAtAUnx5oBJIOic3d9496dZl4NiaZQ9ZvQKxQq1VzzibvE4sr97xA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为 <code>反向代理</code>；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为 <code>内容转码器</code>; <code>匿名代理</code>会主动从HTTP报文中删除身份相关的信息，如 <code>User-Agent</code>, <code>Cookie</code>等字段。</p><p>现实中，请求通过以下几种方式打到代理服务器上去：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTVYicUUUFVOFN7jMXViaKEPaYicSLxlIEBYIribWicpuChGwah8gvtFImUQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。注意图中的via字段。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1PTaibUPaCtlroPcyicwRJoQUbWTqlVAGicicg359QyvdZsQmr3H0FjK4A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。</p><p>大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是 <code>If-Modified-Since</code>, 如果在xx时间(此时间即为If-Modified-Since的值)之后内容没有变化，服务器会回应一个 <code>304NotModified</code>. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为 <code>再验证命中</code>。</p><p>再验证可能出现命中或未命中的情况。未命中时，服务器回复 <code>200OK</code>，并且返回完整的数据；命中时，服务器回复 <code>304NotModified</code>; 还有一种情况，缓存被删除了，那么根据响应状态码，缓存服务器也会删除自己缓存的副本。</p><p>顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。</p><p>缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，再对一些首部字段做一些微调。比如向其中插入新鲜度信息（如 <code>Age</code>, <code>Expires</code>首部等），而且通常会包含一个 <code>via</code>首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改 <code>Date</code>字段，它表示原始服务器最初构建这条响应的日期。</p><p>HTTP通过 <code>文档过期机制</code>和 <code>服务器再验证机制</code>保持已缓存数据和服务器间的数据充分一致。</p><p>文档过期通过如下首部字段来表示缓存的有效期：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。如上表中提到的 <code>Expires</code>字段等。</p><p>为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个 <code>条件GET</code>请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。 <code>条件GET</code>请求会用到如下的字段：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cLIw08X75umvOGDoeZDlYcb74GDpKdsOAzRMnYt5p8KeptjE5ejaw6Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。</p><p>有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。</p><p>服务器在给客户端的响应字段首部加上 <code>Set-cookie</code>或 <code>Set-cookie2</code>, 值为 <code>名字=值</code>的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过 <code>Cookie</code>带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。</p><p>浏览器只会向产生这条cookie的站点发生cookie. <code>Set-cookie</code>字段的值会包含 <code>domain</code>这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。 <code>path</code>字段也是相似的功能。如i浏览器收到如下的cookie:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: user=&quot;mary&quot;; domain=&quot;stefno.com&quot;</span><br></pre></td></tr></table></figure><p>那么浏览器在访问任意以 <code>stefno.com</code>结尾的站点都会发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot;mary&quot;</span><br></pre></td></tr></table></figure><h2 id="实体和编码"><a href="#实体和编码" class="headerlink" title="实体和编码"></a>实体和编码</h2><p>响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果 <code>Content-Type</code>定义是 <code>text/plain</code>, 那说明body内容就是文本，我们直接按文本编码来解释；如果 <code>Content-Type</code>定义是 <code>image/png</code>, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。</p><p><code>Content-Length</code>标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外， <code>Content-Length</code>在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上 <code>Content-Length</code>字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的 <code>Content-Length</code>首部。</p><p>HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。</p><p>HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到 <code>Content-MD5</code>这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改 <code>Content-MD5</code>首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与 <code>Content-MD5</code>首部进行比较。这主要是防止代理对报文进行了无意的改动。</p><p>HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c3QiaTbXgX0sJtJicDibxDtN6wlniaHbgLSCwNiba2dXX12Z9jL5v12Gjshw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在 <code>Accept-Encoding</code>首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。</p><p>上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码： <code>传输编码</code>。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。</p><p>通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到 <code>Content-Length</code>中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到 <code>传输编码</code>来标注数据的结束的。</p><p>HTTP协议中通过如下两个首部来描述和控制传输编码：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>分块编码的报文形式是这样的：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckXIxrtbOKfscDcACkqLe3oOFeUOS25BxE4xBZ3zC0cvCibLMb3OicS2Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>每个分块包含一个长度值（十六进制，字节数）和该分块的数据。 <code>&lt;CR&gt;&lt;LF&gt;</code>用于区隔长度值和数据。长度值不包含分块中的任何 <code>&lt;CR&gt;&lt;LF&gt;</code>序列。最后一个分块，用长度值0来表示结束。注意报文首部包含一个 <code>Trailer:Content-MD5</code>, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如， <code>Content-Length</code>, <code>Trailer</code>, <code>Transfer-Encoding</code>也可以作为拖挂。</p><p>内容编码和传输编码是可以结合起来使用的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqvJ6263Sa8Ay3zGoGFqml8SWpzWtHL631ZTVqpRauJzoaNDltGeHibg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="国际化支持"><a href="#国际化支持" class="headerlink" title="国际化支持"></a>国际化支持</h2><p>HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，以及浏览器上安装了何种字母表编码算法。这通过 <code>Accept-Charset</code>和 <code>Accept-Language</code>首部实现。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: fr, en;q=0.8Accept-Charset: iso-8859-1, utf-8</span><br></pre></td></tr></table></figure><p>表示：客户端接受法语(fr, 优先级默认为1.0）、英语（en, 优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在 <code>Content-Type</code>首部里放上 <code>charset</code>.</p><p>本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码去字符集中找到对应的元素。</p><p>比较常见的字符集是 <code>US-ASCII</code>: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。可以再看下上文报文分析部分的acsii码集。</p><p><code>US-ASCII</code>是把每个字符编码成固定的7位二进制值。 <code>UTF-8</code>则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值，前两个bit位是用 <code>10</code>标识。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cJHSxBWJroo9TNWxXdoY9KiaPiaUYHLHaf77bqicIoQvYDKKDYPwtKqLIw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>举个例子，汉字“严”的Unicode编码为 <code>4E25</code>( <code>100111000100101</code>), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将 <code>100111000100101</code>填入上表中的 <code>c</code>位即可。因此，严的 <code>UTF-8</code>编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com.hk/search?q=%E4%B8%A5&amp;oq=%E4%B8%A5&amp;aqs=chrome..69i57j0l5.3802j0j4&amp;sourceid=chrome&amp;ie=UTF-8&amp;gws_rd=cr</span><br></pre></td></tr></table></figure><p><code>q=%E4%B8%A5</code>这个就是搜索的词了。</p><h2 id="重定向与负载均衡"><a href="#重定向与负载均衡" class="headerlink" title="重定向与负载均衡"></a>重定向与负载均衡</h2><p>Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。一般都会有所谓的“双活”，“多活”，所谓 <code>狡兔三窟</code>嘛。</p><p>这样，用户的请求会根据 <code>负载均衡</code>的原则，被 <code>重定向</code>到它应该去的地方。</p><h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>服务器收到客户端请求后，向客户端返回一条带有状态码 <code>302</code>重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用， <code>重定向</code>服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。</p><p>当然，缺点也是显而易见的，由于客户端要发送两次请求，因此会增加耗时。</p><h3 id="DNS重定向"><a href="#DNS重定向" class="headerlink" title="DNS重定向"></a>DNS重定向</h3><p>DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的 <code>轮转</code>；也可以是更高级的算法，如返回负载最轻的服务器的IP地址，称为 <code>负载均衡算法</code>；如果考虑地理位置，返回给客户端最近位置的地址，称为 <code>邻接路由算法</code>；还有一种是绕过出现故障的地址，称为 <code>故障屏蔽算法</code>。</p><p>DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。</p><h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>HTTP连接是HTTP报文传输的关键通道。</p><h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，速度会快起来。</p><p>如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqsP47SichhaMHESR59XzoJ1V635S2pk6AMQXMaBT4tqIDBIH3fhiccDA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>采用并行连接之后：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cyPg8tia0Y7V1b7CumlkvGcuicicNBEFZeatkJKbkf7gTWrfiaibKLcRMU5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。</p><p>另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP keep-alive机制</p><p>我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。</p><p>HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。</p><p>HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnp6MPI6YLshmc8PgDUv1jq8LUcbwBOiczicxiaMTqNOticYL70ONWSCnXQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>HTTP有keep-alive机制，目的是可以在一个TCP 连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcpsetkeepalive，来激活连接的keep-alive属性。</p><p>当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过 <code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcpkeepaliveprobes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试 <code>tcp_keepalive_probes</code>次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><h3 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h3><p>在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求按序放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。而且就算是服务端按序处理的，也不一定是按序返回给客户端，所以最好是在响应中附带一些可以标识请求的参数。</p><p>为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上，就是所有HTTP的通信细节了，足够在日常开发 作中使用了。更多没有涉及的细节可以在用到的时候再去仔细研究。</p><p>文章看完了，不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。</p><blockquote><p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p><p>如有冒犯，联系删除</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“三次握手，四次挥手”你真的懂吗？</title>
      <link href="/2019/03/28/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
      <url>/2019/03/28/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！</p><p>作为程序员，要有“刨根问底”的精神。知其然，更要知其所以然。这篇文章希望能抽丝剥茧，还原背后的原理。</p><h1 id="什么是“3次握手，4次挥手”"><a href="#什么是“3次握手，4次挥手”" class="headerlink" title="什么是“3次握手，4次挥手”"></a><strong>什么是“3次握手，4次挥手”</strong></h1><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h2 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a><strong>TCP服务模型</strong></h2><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a><strong>TCP头部</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF9sL0PPjOs0LotFFbWklFVlMPuGIp1ltEkbK0hIibHtzZsZRvn9Liaz4Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。<br>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。<br>SYN —— 用于初如化一个连接的序列号。<br>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a><strong>状态转换</strong></h2><p>三次握手和四次挥手的状态转换如下图。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFian001KXuKUicvYT7Pozrf2g50NrMtS2mPRuNYIWdgsSmplf8ic1KuV6g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id><a href="#" class="headerlink" title=" "></a> </h1><h1 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a><strong>为什么要“三次握手，四次挥手”</strong></h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。</p><p>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。</p><p>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th>视角</th><th>客收</th><th>客发</th><th>服收</th><th>服发</th></tr></thead><tbody><tr><td>客视角</td><td>二</td><td>一 + 二</td><td>一 + 二</td><td>二</td></tr><tr><td>服视角</td><td>二 + 三</td><td>一</td><td>一</td><td>二 + 三</td></tr></tbody></table><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><h1 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a><strong>“三次握手，四次挥手”怎么完成？</strong></h1><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFYpRyHjvicckYBlR5ShkUOy9kXicV904eC9yjU8j0JvAowEWGW4KIT1kA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h2 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmo1F4q8mQmxymUCGFAiaIu26E7mw2mj8cYu1qicdE4PVOsVtFJFrJMrw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong></h2><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h1 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a><strong>“三次握手，四次挥手”进阶</strong></h1><h2 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a><strong>ISN</strong></h2><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><blockquote><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p></blockquote><p>M是一个计时器，每隔4毫秒加1。</p><p>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><p><strong>序列号回绕</strong></p><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><blockquote><p>*/**</p><p>*<em> The next routines deal with comparing 32 bit unsigned ints</em></p><p>*<em> and worry about wraparound (automatic with unsigned arithmetic).</em></p><p>*<em>/</em></p><p>static inline <strong>int</strong> before(<strong>u32 seq1, </strong>u32 seq2)</p><p>{</p><p>​    <strong>return</strong> (__s32)(seq1-seq2) &lt; 0;</p><p>}</p><p>#define after(seq2, seq1) before(seq1, seq2)</p></blockquote><p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><blockquote><p>假设seq1=255， seq2=1（发生了回绕）。</p><p>seq1 = 1111 1111 seq2 = 0000 0001</p><p>我们希望比较结果是</p><p>seq1 - seq2=</p><p>1111 1111</p><p>-0000 0001</p><p>-———-</p><p>1111 1110</p><p>由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为</p><p>0000 0001 + 1 = 0000 0010 = 2</p><p>因此seq1 - seq2 &lt; 0</p></blockquote><h2 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a><strong>syn flood攻击</strong></h2><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h3 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h3><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h3 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h3><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h4 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h4 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h3 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h3><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h2 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a><strong>连接队列</strong></h2><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmakH75iacmvjKuByYibR6kVbsichiaV2aEYYhTicKdPJXAlJTMCmMCibUmKw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><blockquote><p>查看是否有连接溢出</p><p>netstat -s | grep LISTEN</p></blockquote><h3 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a><strong>半连接队列满了</strong></h3><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFNI7SPfVDd7oQRIrGy3ribyxr8S6W46SJ58ZT5BAeibiahonct8nbIQcsQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>全连接队列满了</strong></p><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>命令</strong></p><p>netstat -s命令</p><blockquote><p>[root@server ~]#  netstat -s | egrep “listen|LISTEN”</p><p>667399 times the listen queue of a socket overflowed</p><p>667399 SYNs <strong>to</strong> LISTEN sockets ignored</p></blockquote><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><blockquote><p>[root@server ~]#  netstat -s | grep TCPBacklogDrop</p></blockquote><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><blockquote><p>[root@server ~]#  ss -lnt</p><p>State Recv-Q Send-Q Local Address:Port Peer Address:Port</p><p>LISTEN     0      128 <em>:6379 </em>:*</p><p>LISTEN     0      128 <em>:22 </em>:*</p></blockquote><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。</p><p>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h1 id="“三次握手，四次挥手”redis实例分析"><a href="#“三次握手，四次挥手”redis实例分析" class="headerlink" title="“三次握手，四次挥手”redis实例分析"></a><strong>“三次握手，四次挥手”redis实例分析</strong></h1><ol><li>我在dev机器上部署redis服务，端口号为6379,</li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><blockquote><p>tcpdump -w /tmp/a.cap port 6379 -s0</p><p>-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S0则会抓到完整数据包</p></blockquote><ol><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><blockquote><p>tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</p><p>（-x 以16进制形式展示，便于后面分析）</p></blockquote><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFuia4XyKt3j44V4px2Fic7zjGvfOLTyohocqo1YhWamm3OdibRchUZaADg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>它由固定长度20B+可变长度构成。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF1ock0p3DyjYPgkVc3icNcTmSQYwEmKJFPuibnGjxItx5IXnK9uOjc6jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>对着IP头部格式，来拆解数据包的具体含义。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFLUSiaJdMOtSxZMAPSUH2J0cMLFqiaVzA83WrqWBhXWCIfjCeOnu54cUg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFFiaC1F0oOwQX4mDye7HnszaFEdNO3vJRrZMw07dmywApRckbhK3jxJg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>这样第一个包分析完了。dev2向dev发送SYN请求。也就是三次握手中的第一次了。</p><p>SYN seq(c)=4133153791</p><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.</p><p>SYN ack=seq(c)+1 seq(s)=4264776963</p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.</p><p>ack=seq(s)+1, seq=seq(c)+1</p><p>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFiaYrAMKnowJDk3ntjD7GeyOX5myHgZ0wBRciaMOFonkwNZJXRSJjlOicQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792</p><p>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><blockquote><p>0x2a31         -&gt; *1</p><p>0x0d0a         -&gt; \r\n</p><p>0x2434         -&gt; $4</p><p>0x0d0a         -&gt; \r\n</p><p>0x7069 0x6e67  -&gt; ping</p><p>0x0d0a         -&gt; \r\n</p></blockquote><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。</p><p>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.</p><p>数据部分2b50 4f4e 470d 0a, 翻译过来就是+PONG\r\n.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><p><strong>总结</strong></p><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><p>所以，“三次握手，四次挥手”你真的懂了吗？</p><blockquote><p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p><p>如有冒犯，联系删除</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是HTTPS协议</title>
      <link href="/2019/03/27/%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/03/27/%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者 | 小   灰</p><p>责编 | 胡巍巍</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QibiajkGYjaNxI6pTvG3ehic6EktzRvZ4GD9PPsKuwaQLH4jVFbf92Kfdg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QnIBhBKXbcKDoX44n2YMvdqdHicJQNpyWReyib2PnhMTxSicSDumbWKRpw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QVq4x8hoGTrGwe7dfBCkhwgV9gD81KGQBsl9yPa7ic0uQIibcGxicsAxLw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmRdRTQTIs9muXtgY77wialvjWV8StsrkOa4hxqjrkia8ngZ2UKwTLkiaQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QiaicqJked2A0l9hYpwJVGtGhlV2KwGPUMqt1O1m6jr7FlRfbfC8ib95Jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Q6pFlukc21dcoEdfEJvRoyBYA5WJmQW32drgyv0Uw02icmsrKgY5TuOw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSPn6JHA3Zyickib2fUa1dUwEfpjrcmZnYDXtrD207nibjkHEjVWiaPSwGQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSln0sXSXHqrz7U1P5PQ05HwkBv5hPicWib2ic7qQpfVkhFiaqIf1559JaA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QImf2zKCHx6OTJZnV2pYARgwUMF53UicibRdgCJNrAowibo3X0cMPeJXFw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>什么是HTTP协议？</strong></p><p>HTTP协议全称Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于TCP/IP四层模型当中的应用层。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>HTTP协议通过请求/响应的方式，在客户端和服务端之间进行通信。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这一切看起来很美好，但是HTTP协议有一个致命的缺点：不够安全。</p><p>HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢？让我们打一个比方：</p><p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做中间人攻击。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>如何进行加密呢？</strong></p><p>小灰和小红可以事先约定一种对称加密方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这样做是不是就绝对安全了呢？并不是。</p><p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这可怎么办呢？别担心，我们可以使用非对称加密，为密钥的传输做一层额外的保护。</p><p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p><p>在小灰和小红建立通信的时候，小红首先把自己的公钥Key1发给小灰：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥Key2，并且用刚才接收的公钥Key1对Key2进行加密（这里有点绕），发送给小红：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>小红利用自己非对称加密的私钥，解开了公钥Key1的加密，获得了Key2的内容。从此以后，两人就可以利用Key2进行对称加密的通信了。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>是什么坏主意呢？中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。</p><p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>是什么解决方案呢？难道再把公钥进行一次加密吗？这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p><p>这时候，我们有必要引入第三方，一个权威的证书颁发机构（CA）来解决。到底什么是证书呢？证书包含如下信息：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p><p>流程如下：</p><p>1.作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmrhYBUv6aQ6RPpbEEWV4jnWURYvnB7QKKkCeLzwMZeicp8lytYms0yg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>3.当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QjQldYuHCKOcibkUMf7nhX0DD4EasCGcQS0os6suCO7fSxia7FjOYiaOzA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>4.小灰收到证书以后，要做的第一件事情是验证证书的真伪。</p><p>需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。</p><p>所以小灰只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p><p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p><p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥Key1。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QENwxMWjnWv6iaCM0JjG1faFyrEmPC6c1n2tZDIGo3icONyV91INJicAJA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>5.像之前一样，小灰生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给小红。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QKLTGwWJXwaHibic78VTbibpEIO5UBGCj1D0cVSFp1W32MKLQRGiaibYcTHg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>6.最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是两人开始用Key2进行对称加密的通信。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QxwRCiac136C5VLuNyVjFDG3teRNtwh1GmPvolrtpRcLxc8XeM2ibibyeQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢？</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QXVOiaHUuKTsf5Iqy360ukSZoM3jwPa9KiaMbmiakquh2MvF1Eg52wAbCQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QwOLtEPPhJToUf4EaQ6XvtNoJsoc9ibUWBYXJ8VPIl4Xo7ppnuc4icsxA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qy676yjvxP11icXgFDZER6iahoXLggnt84XUlg2nDSRgJdsbWNuRENBfg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qc73BXAGJgwvq8HwbU4IzorxmNNUujleX4buaugp3a2X1hUt3cLNSYA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QOThp6PEtNpia48W7vLtb5viauwJZW2rxfIRVOoNAT4UMXJa2Mo2QkNDQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QFibuV1f5f5lCG2ryskiaickbbW88icxFjibZKv7uQglyWcVicgVnicN96R0wQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QplvDw2aicOOm3R55rqB8mzO8Gia2l54JIInWnUFhTylD3C9mevf7DqYg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>注：最新推出的TLS协议，是SSL 3.0协议的升级版，和SSL协议的大体原理是相同的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QDg1EJYjK2vZfPbrZfHNy3gibl4vqJGIFsgqD3OK2iaLqFNq3IlTrkH3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>声明：本文为作者投稿，首发于个人公众号程序员小灰，版权归其所有。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arcpy开发&amp;关于arcgis中的api arcpy.Describe</title>
      <link href="/2019/03/18/arcpy%E5%BC%80%E5%8F%91&amp;%E5%85%B3%E4%BA%8Earcgis%E4%B8%AD%E7%9A%84api%20arcpy.Describe/"/>
      <url>/2019/03/18/arcpy%E5%BC%80%E5%8F%91&amp;%E5%85%B3%E4%BA%8Earcgis%E4%B8%AD%E7%9A%84api%20arcpy.Describe/</url>
      
        <content type="html"><![CDATA[<p>今天在学习关于工作空间相关知识，用于了下面的函数来实现判断当前输入的要素参数在哪个工作空间。其中主要运用到了arcpy.Describe函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_workspace</span><span class="params">(featureClass)</span>:</span></span><br><span class="line"> catalogPath = os.path.dirname(featureClass.catalogPath)</span><br><span class="line">    <span class="keyword">if</span> arcpy.Describe(catalogPath).dataType == <span class="string">'FeatureDataset'</span>:</span><br><span class="line">        arcpy.env.workspace = arcpy.Describe(catalogPath).path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        arcpy.env.workspace = featureClass.path</span><br><span class="line">    <span class="keyword">return</span> arcpy.env.workspace</span><br></pre></td></tr></table></figure><p>研究罢了，调试时查阅了Describe相关的参数，于是来看一下esri官方的参考文档，如下所说关于describe的种种：</p><p>Describe 函数返回的 Describe 对象包含多个属性，如数据类型、字段、索引以及许多其他属性。该对象的属性是动态的，这意味着根据所描述的数据类型，会有不同的描述属性可供使用。</p><p>Describe 属性被组织成一系列属性组。任何特定数据集都将至少获取其中一个组的属性。例如，如果要描述一个地理数据库要素类，您可访问 GDB 要素类、要素类、表和数据集属性组中的属性。所有数据，不管是哪种数据类型，总会获取通用 Describe 对象属性。</p><p>好了，说了这么多。我其实想说的是，可以使用describe查看数据的相关信息。比如shapeType、dataType、catalogPath、spatialReference等等相关信息。我们来看一下下面这一段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input_fc = <span class="string">'D:/Data/中国国界和省界的SHP格式数据/省界/bou2_4p.shp'</span></span><br><span class="line">desc = arcpy.Describe(input_fc)</span><br><span class="line">catalogPath = os.path.dirname(desc.catalogPath)</span><br><span class="line">dataType=arcpy.Describe(catalogPath).dataType</span><br><span class="line">dataType2=desc.dataType</span><br></pre></td></tr></table></figure><p>现在我们把pycharm断点打开，一一窥探该函数会给我们带来什么样的信息。具体如下图所示。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1552917456413.png" alt="1552917456413"></p><p>好了，关于describe的学习就到处为此了。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIS; arcpy; python; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myFirstBlog</title>
      <link href="/2019/03/13/myFirstBlog/"/>
      <url>/2019/03/13/myFirstBlog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一则列表去重的思考</title>
      <link href="/2018/09/05/%E4%B8%80%E5%88%99%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/09/05/%E4%B8%80%E5%88%99%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>今天偶得休息,闲来无事悄悄代码,收到了一个这样的问题:</p><p>用两种或更多的方法实现对列表list1 = [1,1,2,3,3,5]进行去重。<br>时间紧任务急,博主现只写出了如下四种实现方式供大家参考,后续想到<br>更好的算法了再给大家分享,话不多说上代码,:</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>list1 = [1,1,2,3,3,5]</p><p>set1 = list(set(list1))</p><p>print(set1)</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>list2 = []</p><p>for i in range(len(list1)):<br>    if list1.index(list1[i]) == i:<br>        list2.append(list1[i])</p><p>print(list2)</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>list3 = [1,1,2,3,3,5]<br>for i in list3:<br>    if list3.count(i) 1:<br>        list3.pop(list3.index(i))</p><p>print(list3)</p><h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>list4 = []</p><p>for i in list1:<br>    if i not in list4:<br>        list4.append(i)</p><p>print(list4)</p><p>乍一看不觉这题难,对于接触过python的朋友来说,随手写出一两个不成问题,<br>但通过此事也意识到了,前面学过的知识还是要勤加复习避免遗忘,不说了博主要去复习了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 命令操作总结</title>
      <link href="/2018/08/17/git%20%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/17/git%20%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><ul><li><p>sudo apt-get intall git</p><blockquote><p>终端输入git 如果有提示证明安装成功</p></blockquote></li></ul><h3 id="2-git单人操作"><a href="#2-git单人操作" class="headerlink" title="2.git单人操作"></a>2.git单人操作</h3><ul><li><p>2.1 创建空的git仓库: git init</p><blockquote><p>提示: git仓库和项目的根路径在一起,用来管理项目</p></blockquote></li><li><p>2.2 配置git提交的用户名,邮箱</p><p>例如: git config user.name ‘zhangsan’</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; git config user.email <a href="mailto:&#39;111@qq.com" target="_blank" rel="noopener">&#39;111@qq.com</a>‘</p><blockquote><p>如果没有配置,默认使用的: home/.gitconfig  根目录下的用户信息</p></blockquote></li><li><p>2.3 查看文件状态: git status</p><blockquote><p>红色: 表示新建文件, 或者新修改了文件,目前位于工作区中</p><p>绿色: 表示文件在暂存区</p></blockquote></li><li><p>2.4将工作区代码, 添加到暂存区(工作区–&gt;暂存区)</p></li><li><p>例如: git add .  </p><p> &nbsp; &nbsp; &nbsp; git add xxx.py</p><blockquote><p>点表示添加所有变动,  xxx.py表示指定文件</p></blockquote></li><li><p>2.5将工作区代码,添加到仓库区(工作区—&gt;仓库区)</p></li><li><p>例如: git commit -m ‘注释’</p></li><li><p>2.6将工作区,直接添加到仓库区(工作区–&gt;暂存区—&gt;仓库区)</p></li><li><p>例如: git commit -am ‘注释信息’</p></li><li><p>2.7查看版本历史</p><p>例如: git log</p><p> &nbsp; &nbsp; &nbsp;  git reflog</p><blockquote><p>log查看详细信息, reflog查看简要信息</p></blockquote></li><li><p>2.8回退版本</p><p>例如: git reset –hard HEAD</p><p>或者: git reset –hard 版本号</p><blockquote><p>HEAD表示当前最新版本</p><p>HEAD^表示当前最新版本的,  上一个版本</p><p>HEAD^^表示当前最新版本的, 前两个版本, 依次类推</p><p>HEAD~1 表示当前最新版本的,  上一个版本</p><p>HEAD~2 表示当前最新版本的, 前两个版本, 依次类推</p></blockquote></li><li><p>2.9撤销工作区,暂存区修改</p><p>撤销工作区:  git checkout 文件名</p><p>撤销暂存区: </p><p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout HEAD 文件名 (暂存区-工作区)</p><p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout 文件名</p><blockquote><p>仓库区代码不能撤销</p></blockquote></li><li><p>2.10 版本对比</p><p>例如: git diff HEAD HEAD^ – xxx.py</p><blockquote><p>HEAD表示当前版本,   HEAD^表示上个版本, xxx.py对比的文件</p></blockquote></li><li><p>2.11误删除文件,恢复</p><p>格式1: rm 文件名</p><p>恢复1: git checkout – 文件名</p><p>格式2: git rm 文件名</p><p>恢复2: git reset –hard HEAD^</p></li></ul><h3 id="3-git多人操作"><a href="#3-git多人操作" class="headerlink" title="3.git多人操作"></a>3.git多人操作</h3><ul><li><p>3.1 clone项目到本地</p><p>例如: git clone 项目地址</p></li><li><p>3.2 推送项目到远程仓库</p><p>例如: git push</p><blockquote><p>第一次推送会提示输入账号, 密码</p></blockquote></li><li><p>3.3 配置是否输入登陆密码信息</p><blockquote><p>git config –global  credential.helper cache 十五分钟有效期</p><p>git config  credential.helper ‘cache –timeout==3600’ 一个小时有效期</p><p>git config –global credential.helper store 长期有效</p></blockquote></li><li><p>3.4 拉取远程最新代码到本地</p><p>例如: git pull</p></li></ul><h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4.标签"></a>4.标签</h3><ul><li><p>4.1 设置本地标签</p><p>例如: git tag -a  标签名 -m ‘标签描述’</p></li><li><p>4.2 推送本地标签到远程</p><p>例如: git push origin 标签名</p></li><li><p>4.3 删除本地标签</p><p>例如: git tag -d 标签名</p></li><li><p>4.4 删除远程标签</p><p>例如: git push origin –delete tag 标签名</p></li></ul><h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h3><ul><li><p>5.1查看当前分支</p><p>例如: git branch</p></li><li><p>5.2创建本地分支,并切换到指定分支</p><p>例如: git checkout -b 分支名</p></li><li><p>5.3推送本地分支,到远程</p><p>例如: git push -u origin 分支名</p></li><li><p>5.4切换分支</p><p>例如: git checkout master / dev</p><blockquote><p>切换到主分支,或者是其他分支</p><p>其他用户第一次pull代码后,切换切换后才能使用git branch查看</p></blockquote></li><li><p>5.5合并子分支到主分支</p><p>例如: git merge 分支</p><blockquote><p>需要在master分支下操作改命令</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git; 版本库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LivePreview无法正常工作</title>
      <link href="/2018/07/26/LivePreview%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/"/>
      <url>/2018/07/26/LivePreview%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>2018/7/26 22:28:25</p><p>自从搭建了个人博客,一直以来都是使用 MarkdownPad 2 来写Blog。近日由于重新安装了系统,想着把MarkdownPad 2再重新安装下,安装后却发现提示无法开启渲染预览,这能难道程序员吗?于是开始了bug查找,发现了如下提示:</p><pre><code>LivePreview is not working - it displays an error message stating This view has crashed!This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.To fix this issue, please try installing the Awesomium 1.6.6 SDK.If you continue to experience issues, please install Microsoft&apos;s DirectX End-User Runtimes.</code></pre><p>读后发现大概意思是需要下载安装Awesomium 1.6.6 SDK，OK,那就先试试 Awesomium 1.6.6 SDK.点击提示页面的下载链接地址，然后安装之后，重新启动MarkdownPad 2就可以正常使用了。</p><p>附带软件下载地址：</p><blockquote><p>MarkdownPad2破解版本地址：链接: <a href="https://pan.baidu.com/s/1dF6C1MT" target="_blank" rel="noopener">https://pan.baidu.com/s/1dF6C1MT</a> 密码: j3cy</p></blockquote><blockquote><p>awesomium软件下载地址：链接: <a href="https://pan.baidu.com/s/1nvRuNaT" target="_blank" rel="noopener">https://pan.baidu.com/s/1nvRuNaT</a> 密码: e7t2 </p></blockquote><p>很多人不太喜欢试用版,试用版功能不全,下面附带注册码激活使用:</p><p>打开markdownpad2 –&gt; 帮助 –&gt;升级为专业版<br>按照如下输入：<br>​</p><blockquote><p>邮箱地址：<a href="mailto:Soar360@live.com" target="_blank" rel="noopener">Soar360@live.com</a></p></blockquote><blockquote><p>授权秘钥：<br>    GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客出现command not found解决方案</title>
      <link href="/2018/07/26/hexo%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0command-not-found%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/07/26/hexo%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0command-not-found%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>2018/7/26 22:14:17</p><p>自从上次更新了博客后,后来就开始了正式的学习,由于电脑升级的原因考虑到今后需要用到的软件会比较多,现在用的电脑配置有点低了,所以对电脑进行了一次小升级购买了固态后重装了系统,以致于之前的博客文件和配置的环境出现了问题,导致不能正常上传博客文件,后来课程太紧,一拖再拖没有来及解决这个问题.</p><p>今天去网上看了下,发现有很多这样的问题,重装系统后会出现command not found提示,接下来就是一波百度,寻找解决办法,发现个办法都有瑕疵并不能一次完美解决.</p><p>最后决定还是使用最粗暴的办法吧,也避免出现一些环境,插件缺少的问题,于是按照我之前写的教程开始了重新配置,安装完毕之后,首先查看各种工具是否都安装好了，在命令行中输入<code>node -v</code><br>然后再检查<code>npm -v</code>,<br>这些都没有问题的话,接下来检查下环境变量有没有配置,如果发现没有配置的话,可以先去找到这个路径，<code>C:\Users\feng\node_modules\hexo\bin</code>，然后把它添加到环境变量PATH路径的后面。这样基本就配置完成了.</p><p>提示:如果发现安装过程存在,使用淘宝NPM镜像，输入以下命令安装  cnpm, <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>,时出错的情况,可以检查下你的git和node的版本,笔者此前出现过因为版本过高而不能正常安装的问题.希望能给大家提供帮助.</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中if __name__ == &quot;__main__&quot;是什么作用</title>
      <link href="/2018/04/15/Python%E4%B8%ADif-name-name-main/"/>
      <url>/2018/04/15/Python%E4%B8%ADif-name-name-main/</url>
      
        <content type="html"><![CDATA[<p>2018/4/15 22:19:35 </p><hr><ul><li>最近在写毕业论文使用到Python，在查找文献资源中看到了一行代码<br><code>Python中if __name__ == &quot;__main__:&quot;</code>之前练习Python并没有注意这个，也可能太就给忘了，为了搞清这个语句于是开始疯狂百度，各种论坛博客搜索，最终找到了这个语句的作用个人感觉最易懂的解释，分享给大家</li><li>python文件的后缀名是.py，python文件既可以用来直接执行，也可以作为模块被导入。<br>我们在使用python时经常会看到<code>Python中if __name__ == &quot;__main__:&quot;</code>这样一个句子,这是什么呢？<br>其中name是模块的内置属性，而这个内置属性的值取决于这个.py文件的使用方式，即你是作为模块导入还是直接执行。<br>如果你是直接执行，那么这个name的值就是’main’，如果你作为一个模块导入，那么这个内置属性值就取决于这个文件名(不包含路径和文件扩展名)。<br>所以我们在看到一个这样的句子<code>Python中if __name__ == &quot;__main__&quot;:</code>时，就是文件在执行时要执行这个main()函数</li></ul><hr><p>附上一张号称一篇程序覆盖Python基础的代码，基本的结构都涉及到了，看不清的话保存本地放大看吧。<br><img src="https://img-blog.csdn.net/20160511222649275" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用MarkdownX编写博文</title>
      <link href="/2018/04/09/%E7%94%A8MarkdownX%E7%BC%96%E5%86%99%E5%8D%9A%E6%96%87/"/>
      <url>/2018/04/09/%E7%94%A8MarkdownX%E7%BC%96%E5%86%99%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>2018/4/9 22:19:02    </p><hr><ul><li><p>　博客搭建好后，尽管下午没事用手机查询Markdown教程，可是搜了一圈发现网上的教程参差不齐，还不如直接用html编写博文，可是想到Markdown的初衷就是方便编写博文，于是想会不会有些工具使Markdown的编写自动化了，果然搜到了一篇用MarkdownX的于是下载下来试用一番，发现挺容易入手的。</p></li><li><p>　一个优秀的产品就应该这样让人尽量容易上手，不必拘于太多的条条框框，但Markdown毕竟还是有些功能不易实现，所以下一步准备尝试使用html+css制作一些漂亮的静态页面。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
