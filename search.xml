<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何重装系统</title>
      <link href="/2019/04/06/%E5%A6%82%E4%BD%95%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/04/06/%E5%A6%82%E4%BD%95%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来我是不想写这篇文章的<del>因为懒</del>。</p><p>但是有鉴于最近<strong>找我装系统的人太多</strong>了，再加上看见小白被无良商家骗于心不忍，就写篇教程吧-_-。</p><p>我会把装机的主要几个阶段讲一下，但是任何跟着提示稍微理解下就可以无风险走的小步骤就不讲了。</p><h2 id="装系统之前的准备"><a href="#装系统之前的准备" class="headerlink" title="装系统之前的准备"></a>装系统之前的准备</h2><p>首先要有个概念 <code>装系统是一件很简单的事</code>。电脑是一件给人用的 <strong>工具</strong> ，厂商没有理由设置门槛。装机是很简单的，<strong>但是最好不要随意重装系统，文件、软件重新安置太麻烦了</strong>。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ul><li>物理准备<ul><li>一只8G以上U盘</li></ul></li><li>心理准备<ul><li>一小时不到的时间</li><li>一定的理解能力</li></ul></li></ul><h2 id="装机阶段"><a href="#装机阶段" class="headerlink" title="装机阶段"></a>装机阶段</h2><ol><li><p>找到你所用电脑的<strong>主板</strong>厂商（<em>不需要拆机箱，直接用aida64或者别的软件看</em>）以及<strong>型号</strong>，如果是笔记本就直接使用<strong>电脑型号</strong>。</p></li><li><p>搜索 xxxx（<em>你的主板型号</em>） 进入bios的<strong>快捷键</strong>，并记住它。</p></li><li><p>在<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">msdn 我告诉你</a>，这个网站上找到你要装的系统的 <strong>64位</strong> <strong>最新版本</strong>。</p></li><li><p>下载它。</p></li><li><p><strong>格式化</strong>U盘。</p></li><li><p>把下载的镜像文件用解压软件<strong>解压到U盘</strong>。</p></li><li><p><strong>备份c盘里的文件</strong>，其它盘看你想不想顺便格式化。</p></li><li><p>重启，并在开机的过程中<strong>狂按</strong>你记住的<strong>快捷键</strong>。</p></li><li><p>你将会进入一个蓝蓝白白的界面（bios），请动用你的英语水平进行翻译后使用。</p></li><li><p>你有两个选择</p><ul><li>UEFI路线<ol><li>找到<strong>boot</strong>里面的<strong>UEFI</strong>设置为<strong>ENABLE</strong></li><li><strong>重启</strong>，开机过程中<strong>狂按</strong>快捷键</li><li>会看见弹出一个<strong>对话框</strong>，选择 <strong>WINDOWS</strong> <strong>BOOT</strong> <strong>MANAGER</strong></li></ol></li><li>传统路线<ol><li>找到<strong>boot</strong>里面的<strong>启动顺序</strong></li><li>按照操作指示，把<strong>U盘</strong>放到最上面</li><li>重启</li></ol></li></ul></li><li><p>在Windows安装指示界面中，按照指示</p><p>操作</p><p>进行操作</p><ul><li>分区格式化请<strong>谨慎</strong></li></ul></li><li><p>开机后联网会<strong>自动</strong>安装驱动</p></li><li><p>在你的显卡的对应官网下载安装<strong>显卡驱动</strong></p></li><li><p>在设备管理器中查看有无设备上有<strong>感叹号标识</strong>，若有，去官网下载驱动。</p></li><li><p>是否安装</p><p>360、驱动大师等软件自行判断</p><ul><li>我推荐ccleaner、火绒</li></ul></li><li><p>重启进入bios，把设置还原为改动之前的</p></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>简单的电脑维护其实很简单(<del>废话</del>)，只要不<strong>先入为主</strong>地认为自己不会，<strong>善用搜索引擎</strong>，不懂的东西<strong>稍微研究</strong>一下，一般都没有问题的。</p><p><strong>如果看完本文仍觉得无从下手的话，可以联系QQ:244675854提供技术支持（收辛苦费20~30呦！），嘻嘻</strong></p><blockquote><p>我不对任何本文后果负责，还请读者们自行判断。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重装系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键激活window &amp; office</title>
      <link href="/2019/04/06/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow-office/"/>
      <url>/2019/04/06/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow-office/</url>
      
        <content type="html"><![CDATA[<h1 id="一键激活windows-amp-office"><a href="#一键激活windows-amp-office" class="headerlink" title="一键激活windows&amp;office"></a>一键激活windows&amp;office</h1><p>自建的激活服务器，可以一键激活VOL版的window和office。</p><p>推荐去<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a> 下载安装正版的window和office。</p><h2 id="单击下载-一键激活window-amp-office-bat"><a href="#单击下载-一键激活window-amp-office-bat" class="headerlink" title="单击下载 一键激活window&amp;office.bat"></a>单击下载 <a href="https://tohot.top/download/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow&amp;office.bat" target="_blank" rel="noopener">一键激活window&amp;office.bat</a></h2>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何开发一个用户脚本系列——脚本1:视频跳过广告和 VIP 视频解析</title>
      <link href="/2019/04/06/%E8%A7%86%E9%A2%91%E8%B7%B3%E8%BF%87%E5%B9%BF%E5%91%8A%E5%92%8CVIP%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/04/06/%E8%A7%86%E9%A2%91%E8%B7%B3%E8%BF%87%E5%B9%BF%E5%91%8A%E5%92%8CVIP%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在这篇文章中，我们一起学习脚本 <strong>视频跳过广告和 VIP 视频解析</strong> 的开发。这也是本系列文章的最后一篇，希望完成这个系列的学习之后，你能够掌握编写脚本的方法。在正式开始之前，先说一下我认为开发脚本应该遵循的两个准则:</p><ul><li>功能实现。当你决定要开发一个脚本的时候，你肯定清楚你的脚本要实现什么功能，只有你的脚本实现了你所描述的功能，才会有更多的人安装使用，才会有更多的人给你好评；</li><li>样式实现。什么叫样式实现？就是你在目标网站中添加的元素，要尽量与原网站的配色，样式相一致。这一项是非必须的，但我认为是非常重要的。你想想，如果原网站整体是蓝色，而你添加的按钮是红色，那该有多突兀，有多丑，虽然你的按钮确实突出了，但别人一看就是山寨，看着会很不舒服。而如果你的按钮也用它网站的颜色，这样就会跟原网站已有的元素契合，整体特别自然，做到以假乱真的效果。你的脚本让别人用的舒服，别人才更愿意给你好评。</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>我们在日常闲暇时间都会看点视频娱乐一下，而现在各大视频网站都推出了会员体系，一个视频网站的年费会员往往需要 200 块左右。然而我们想看的电视剧，电影，通常都不在一个平台上，导致我们就需要开通各个网站的会员。一个网站还好，但多个网站叠加起来，这笔钱也不少。所以有没有什么方法能够不需要开通各个网站的会员就可以看想看的视频呢？网上现在有一些免费公开的接口提供这种解析服务，只需要将视频播放页面的地址作为参数传给接口，接口就能完成解析，然后播放视频。但我们每次都复制视频播放地址给接口，也会很麻烦，这时候就可以写个脚本，在这些视频网站上添加一个按钮，当用户点击按钮的时候，自动获取到当前页面的播放地址，然后传给接口解析播放。HTML 中有个 <code>iframe</code> 标签，可以用来在当前页面中嵌入其他网页，所以使用 <code>iframe</code> 标签就能够实现在原视频网站站内解析播放视频，体验很好。在某视频网站上的效果如下图:<br><a href="https://mofiter-blog.oss-cn-hangzhou.aliyuncs.com/images/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%84%9A%E6%9C%AC6-1.png" target="_blank" rel="noopener"><img src="https://mofiter-blog.oss-cn-hangzhou.aliyuncs.com/images/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%84%9A%E6%9C%AC6-1.png" alt="img"></a></p><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>视频的解析都是解析接口实现的，脚本本身并不进行视频解析。所以解析接口是否稳定，是否有较高的成功率是很关键的。现在网上有很多解析接口，本文只提供 <a href="https://api.bbbbbb.me/" target="_blank" rel="noopener">思古解析</a>(用于站内解析)和 <a href="http://www.1717yun.com/" target="_blank" rel="noopener">1717yun解析</a>(用于站外解析)作为示例，同时由于视频网站很多，所以本文只选择 <a href="https://v.qq.com/" target="_blank" rel="noopener">腾讯视频</a> 作为运行脚本的示例。腾讯视频某一个视频的具体播放地址形式为 <code>https://v.qq.com/x/cover/xxx</code>，用 <code>@match</code> 匹配。在脚本编写过程中会用到 jQuery，使用 <code>@require</code> 引入 jQuery 库。站外解析需要在新 tab 页中打开链接，所以需要脚本管理器的 <code>GM_openInTab()</code> 函数，我们用 <code>@grant</code> 声明(为了兼容 Greasemonkey，我们还要声明它的函数 <code>GM.openInTab</code>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy// @require           https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js</span><br><span class="line">// @match             *://v.qq.com/x/cover/*</span><br><span class="line">// @grant             GM_openInTab</span><br><span class="line">// @grant             GM.openInTab</span><br></pre></td></tr></table></figure><p>通过观察原网站可知，功能菜单都是在视频播放窗口下面，当鼠标放在功能按钮上面时，会显示功能面板，当鼠标移出功能按钮时，功能面板隐藏。所以我们将解析按钮加到功能菜单里面，将各个接口添加到功能面板，这样就可以选择不同的接口进行解析，同时使用原网站的样式风格。我们使用一个数组保存接口信息，这样方便遍历添加。由于安全问题，以 https 开头的视频网站内部不能使用 http 开头的接口，所以我们利用接口类型字段来标识接口是用来进行站内解析还是站外解析，如果是站内解析，它应该以 https 开头，如果接口以 http 开头，只能用来站外解析。我们希望将所有的接口以一个列表的形式呈现，所以我们把它放在一个 <code>&lt;ul&gt;</code> 标签里，然后每一个接口放在一个 <code>&lt;li&gt;</code> 标签里面。我们创建一个 <code>&lt;div&gt;</code> 标签，在里面添加一个 <code>&lt;iframe&gt;</code> 标签，用来加载解析结果的网页。在后面进行站内解析的时候，我们用这个 <code>&lt;div&gt;</code> 替换原视频网站播放窗口里面的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copyvar originalInterfaceList = [&#123;&quot;name&quot;:&quot;思古解析&quot;,&quot;type&quot;:&quot;站内&quot;,&quot;url&quot;:&quot;https://api.bbbbbb.me/jx/?url=&quot;&#125;,</span><br><span class="line">                             &#123;&quot;name&quot;:&quot;1717yun解析&quot;,&quot;type&quot;:&quot;站外&quot;,&quot;url&quot;:&quot;http://www.1717yun.com/jx/ty.php?url=&quot;&#125;];</span><br><span class="line">    var parseList = &quot;&lt;ul&gt;&quot;;</span><br><span class="line">    parseInterfaceList.forEach((item,index)=&gt;&#123;</span><br><span class="line">        parseList += &quot;&lt;li&gt;&quot; + item.name + &quot;(&quot; + item.type + &quot;)&lt;/li&gt;&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    parseList += &quot;&lt;/ul&gt;&quot;;</span><br><span class="line">    var videoPlayer = $(&quot;&lt;div id=&apos;iframe-div&apos; style=&apos;width:100%;height:100%;z-index:2147483647;&apos;&gt;&lt;iframe id=&apos;iframe-player&apos; frameborder=&apos;0&apos; allowfullscreen=&apos;true&apos; width=&apos;100%&apos; height=&apos;100%&apos;&gt;&lt;/iframe&gt;&lt;/div&gt;&quot;);</span><br></pre></td></tr></table></figure><p>准备好解析接口和要替换的内容之后，我们就要去原网站添加解析按钮，并添加点击事件，在点击事件里面，替换播放窗口的内容。通过 <code>location.href</code> 能拿到当前页面的 url，我们使用 <code>indexOf()</code> 方法查看 <code>v.qq.com</code> 的索引值，如果索引值大于 -1 说明当前匹配的网站是腾讯视频，我们再进行处理。我们使用 jQuery 获取到功能菜单的父元素，然后创建解析按钮元素，将解析按钮添加到功能菜单父元素。给解析按钮添加鼠标移入移出操作，来显示和隐藏接口列表的功能面板。在每一个解析接口上面添加点击操作，判断被点击的 <code>&lt;li&gt;</code> 标签的接口类型，如果是站内解析，则替换播放窗口的内容，如果是站外解析，则打开一个新的页面显示解析链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copyif(location.href.indexOf(&quot;v.qq.com&quot;) &gt; -1)&#123;</span><br><span class="line">        var action_wrap = $(&quot;.action_wrap&quot;);</span><br><span class="line">        var qq_jiexi = $(&quot;&lt;div id=&apos;qq-jiexi-btn&apos; class=&apos;action_item action_jiexi&apos; style=&apos;position:relative;&apos;&gt;&lt;a class=&apos;action_title fn-qq-jiexi-text&apos;&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/a&gt;&lt;div class=&apos;mod_pop_action fn-qq-jiexi&apos; style=&apos;background-color:#fff;width:120px;left:-50px;text-align:center;line-height:25px;&apos;&gt;&quot; + parseList + &quot;&lt;/div&gt;&lt;/div&gt;&quot;);</span><br><span class="line">        action_wrap.append(qq_jiexi);</span><br><span class="line">        document.getElementById(&quot;qq-jiexi-btn&quot;).addEventListener(&quot;mouseover&quot;,()=&gt;&#123;</span><br><span class="line">            $(&quot;.action_jiexi&quot;).toggleClass(&quot;open&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        document.getElementById(&quot;qq-jiexi-btn&quot;).addEventListener(&quot;mouseout&quot;,()=&gt;&#123;</span><br><span class="line">            $(&quot;.action_jiexi&quot;).toggleClass(&quot;open&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        $(&quot;.fn-qq-jiexi li&quot;).each((index,item)=&gt;&#123;</span><br><span class="line">            item.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">                if(parseInterfaceList[index].type == &quot;站内&quot;)&#123;</span><br><span class="line">                    if(document.getElementById(&quot;iframe-player&quot;) == null)&#123;</span><br><span class="line">                        var txp_ad_skip_text = $(&quot;.txp_ad_inner .txp_ad_skip_text&quot;);</span><br><span class="line">                        if(txp_ad_skip_text.text() === &quot;VIP可关闭广告&quot;)&#123;</span><br><span class="line">                            txp_ad_skip_text.click();</span><br><span class="line">                            mod_player = $(&quot;#mod_player&quot;);</span><br><span class="line">                            mod_player.empty();</span><br><span class="line">                            mod_player.append(videoPlayer);</span><br><span class="line">                        &#125;else if(txp_ad_skip_text.text() === &quot;关闭广告&quot;)&#123;</span><br><span class="line">                            txp_ad_skip_text.click();</span><br><span class="line">                        &#125;else if(vipPage === true)&#123;</span><br><span class="line">                            var txp_btn_play = $(&quot;.txp_left_controls .txp_btn_play&quot;);</span><br><span class="line">                            if(txp_btn_play.attr(&quot;data-status&quot;) === &quot;pause&quot;)&#123;</span><br><span class="line">                                txp_btn_play.click();</span><br><span class="line">                            &#125;</span><br><span class="line">                            mod_player = $(&quot;#mod_player&quot;);</span><br><span class="line">                            mod_player.empty();</span><br><span class="line">                            mod_player.append(videoPlayer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    innerParse(parseInterfaceList[index].url + location.href);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    GMopenInTab(parseInterfaceList[index].url + location.href,false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function innerParse(url)&#123; // 站内解析</span><br><span class="line">    $(&quot;#iframe-player&quot;).attr(&quot;src&quot;,url);</span><br><span class="line">&#125;</span><br><span class="line">function GMopenInTab(url,open_in_background)&#123; //站外解析</span><br><span class="line">    if(typeof GM_openInTab === &quot;function&quot;)&#123; // Tampermonkey 和 Violentmonkey 调用 GM_openInTab</span><br><span class="line">        GM_openInTab(url,open_in_background);</span><br><span class="line">    &#125;else&#123; // Greasemonkey GM.openInTab</span><br><span class="line">        GM.openInTab(url,open_in_background);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此腾讯视频的解析差不多就完成了，还有些细节和用户体验方面的东西代码里面有写，这里就不再赘述了。其他视频网站的处理和腾讯视频的原理是一样的，都是添加解析按钮，然后给解析按钮添加点击事件，进行站内或站外解析。</p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何开发用户脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/06/hello-world/"/>
      <url>/2019/04/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>极限与导数</title>
      <link href="/2019/04/03/%E6%9E%81%E9%99%90%E4%B8%8E%E5%AF%BC%E6%95%B0/"/>
      <url>/2019/04/03/%E6%9E%81%E9%99%90%E4%B8%8E%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>最近学了一些基础微积分，这里稍微记录一下。</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>极限可以当做是一个函数f(x)f(x)的xx无限趋近于某一个常数或无穷远处时，函数数值所逼近的一个值。 例如，对于函数<br>$$<br>f(x)=2xx+1f(x)=2xx+1<br>$$<br>，当xx趋近于无穷大时，f(x)f(x)无限趋近于22。我们将此记成这样子：</p><p>$$<br>limx→∞f(x)=limx→∞2xx+1=2limx→∞f(x)=limx→∞2xx+1=2<br>$$</p><p>求极限需要会一点代数技巧，我反正是老是求不出……</p><p>极限有一些方便的性质：<br>当然，这些等式的左边都是存在极限的。</p><p>$$<br>limx→ca⋅f(x)=a⋅limx→cf(x)limx→ca⋅f(x)=a⋅limx→cf(x)<br>$$</p><p>对于两个函数f(x)f(x)和g(x)g(x)之间极限的关系：（当然f(x)f(x)和g(x)g(x)都要存在极限）</p><p>$$<br>limx→c[f(x)+g(x)]=limx→cf(x)+limx→cg(x)limx→c[f(x)+g(x)]=limx→cf(x)+limx→cg(x)<br>$$</p><p>$$<br>limx→c[f(x)−g(x)]=limx→cf(x)−limx→cg(x)limx→c[f(x)−g(x)]=limx→cf(x)−limx→cg(x)<br>$$</p><p>$$<br>limx→cf(x)⋅g(x)=limx→cf(x)⋅limx→cg(x)limx→cf(x)⋅g(x)=limx→cf(x)⋅limx→cg(x)<br>$$</p><p>$$<br>limx→cf(x)g(x)=limx→cf(x)limx→cg(x)(limx→cg(x)≠0)limx→cf(x)g(x)=limx→cf(x)limx→cg(x)(limx→cg(x)≠0)<br>$$<br>简而言之，极限这东西可以加减乘除。</p><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>对于函数f(x)f(x)而言，它在x0x0处的导数是这么定义的：</p><p>$$<br>limΔx→0f(x0+Δx)−f(x0)ΔxlimΔx→0f(x0+Δx)−f(x0)Δx<br>$$</p><p>从几何意义上讲，这个值可以视为是f(x)f(x)的图像在x0x0处的切线的斜率。 当然不是所有的函数都是可以求导数的，只有在那一段上是连续的函数时，才会有导数。<br>连续的函数f(x)f(x)在其定义域内的每一点上都可以计算导数，意味着每一个xx都会对应一个导数，这样就形成了一个函数关系。我们将这个函数叫作导函数，记作f′(x)f′(x)。</p><p>如何求导函数呢？根据导数的定义，我们将x0x0换为xx，然后求极限就好了。然而说的轻巧，实际上很多都比较难以求出，因此早有先人为我们把各种导函数算好了。</p><p>举一个典型的例子<br>$$<br>f(x)=x2f(x)=x2<br>$$<br>。按照求导数的方法：</p><p>$$<br>f′(x)=limΔx<br>$$<br>$$<br>→0f(x+Δx)−f(x)Δx=limΔx<br>$$<br>$$<br>→0(x+Δx)2−x2Δx=limΔx<br>$$<br>$$<br>→0Δx2+2xΔxΔx=limΔx<br>$$<br>$$<br>→0(Δx+2x)=2xf′(x)=limΔx<br>$$<br>$$<br>→0f(x+Δx)−f(x)Δx=limΔx<br>$$<br>$$<br>→0(x+Δx)2−x2Δx=limΔx<br>$$<br>$$<br>→0Δx2+2xΔxΔx=limΔx<br>$$<br>$$<br>→0(Δx+2x)=2x<br>$$</p><p>事实上，对于幂函数<br>$$<br>f(x)=xαf(x)=xα，其导函数为，其导函数为<br>$$<br>，其导函数为<br>$$<br>f′(x)=αxα−1f′(x)=αxα−1<br>$$<br>。</p><p>导数与导数之间存在运算关系，有了这些运算关系，我们就可以方便地进行求导。<br>类似于线性的性质：<br>$$<br>[a⋅f(x)+b⋅g(x)]′=a⋅f′(x)+b⋅g′(x)[a⋅f(x)+b⋅g(x)]′=a⋅f′(x)+b⋅g′(x)<br>$$</p><p>两个导数相乘：<br>$$<br>[f(x)g(x)]′=f′(x)g(x)+f(x)g′(x)[f(x)g(x)]′=f′(x)g(x)+f(x)g′(x)<br>$$</p><p>两个导数相除：<br>$$<br>[f(x)g(x)]′=f′(x)g(x)−f(x)g′(x)g2(x)(g(x)≠0)[f(x)g(x)]′=f′(x)g(x)−f(x)g′(x)g2(x)(g(x)≠0)<br>$$</p><p>复合函数：<br>$$<br>[f(g(x))]′=f′(g(x))⋅g′(x)[f(g(x))]′=f′(g(x))⋅g′(x)<br>$$</p><p>一些基本函数的导函数就放这里了，当我们要求一个特定函数的导函数时，可以利用上面的规则，然后根据导函数表来计算。下面只有xx是变量。<br>$$<br>c′=0c′=0<br>$$</p><p>$$<br>x′=1x′=1<br>$$</p><p>$$<br>(xα)′=αxα−1(xα)′=αxα−1<br>$$</p><p>$$<br>(ex)′=ex(ex)′=ex<br>$$</p><p>$$<br>(ax)′=axlna(ax)′=axln⁡a<br>$$</p><p>$$<br>(lnx)′=1x(ln⁡x)′=1x<br>$$</p><p>$$<br>(logax)′=1xlna(loga⁡x)′=1xln⁡a<br>$$</p><p>$$<br>sin′x=cosxsin′⁡x=cos⁡x<br>$$</p><p>$$<br>cos′x=−sinxcos′⁡x=−sin⁡x<br>$$</p><p>$$<br>tan′x=1cos2xtan′⁡x=1cos2⁡x<br>$$</p><p>$$<br>cot′x=−1sin2xcot′⁡x=−1sin2⁡x<br>$$</p><h2 id="对数求导法"><a href="#对数求导法" class="headerlink" title="对数求导法"></a>对数求导法</h2><p>上面的求导公式已经能够应对大部分基本函数的求导了，但是对于下面的函数：<br>$$<br>f(x)=x1/xf(x)=x1/x<br>$$<br>该如何求导呢？<br>这就要用到对数来进行求导。</p><p>我们知道，对于一个函数f(x)f(x)：<br>$$<br>[lnf(x)]′=ln′f(x)⋅f′(x)[ln⁡f(x)]′=ln′⁡f(x)⋅f′(x)<br>$$</p><p>换言之：<br>$$<br>f′(x)=[lnf(x)]′ln′f(x)(1)(1)f′(x)=[ln⁡f(x)]′ln′⁡f(x)<br>$$<br>利用这一点，我们就可以对<br>$$<br>f(x)=x1/xf(x)=x1/x<br>$$<br>求导。 首先，为了方便我们设：<br>$$<br>y=x1/xy=x1/x<br>$$<br>由于两者相等，所以两者的对数也应相等：<br>$$<br>lny=lnx1/x=1xlnxln⁡y=ln⁡x1/x=1xln⁡x<br>$$</p><p>将两边对xx求导。注意按照(1)(1)式，左式需要乘上y′y′两者才能相等。<br>$$<br>y′y=1−lnxx2y′y=1−ln⁡xx2<br>$$</p><p>于是我们可以得到：<br>$$<br>y′=1−lnxx2y=1−lnxx2x1/x=f′(x)y′=1−ln⁡xx2y=1−ln⁡xx2x1/x=f′(x)<br>$$</p><p>这样我们就完成了求导。<br>既然都对这个函数求过导了，我们来验证一下它的一个性质。<br>将ee代入导函数：<br>$$<br>f′(e)=1−lnee2e1/e=1−1e2=0f′(e)=1−ln⁡ee2e1/e=1−1e2=0<br>$$</p><p>因此我们发现<br>$$<br>x=ex=e<br>$$<br>是这个函数的极值点。</p>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极限 </tag>
            
            <tag> 导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统结构</title>
      <link href="/2019/04/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>在 Linux 操作系统, 我们是看不到这些驱动器盘符, 而是文件夹(目录):</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g1poi8yj5tj30ku07ndhn.jpg" alt="Linux文件目录示意图"><br>​                                <strong><em>Linux文件目录示意图</em></strong></p><p>Ubuntu 没有盘符概念, 只有一个根目录 <strong>/</strong>, 所有文件都在它下面.</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g1poizwgvjj30ip0bfaa7.jpg" alt="Linux 目录结构示意图"></p><p>​                                <strong><em>Linux 目录结构示意图</em></strong></p><h3 id="Linux-主要目录速查表"><a href="#Linux-主要目录速查表" class="headerlink" title="Linux 主要目录速查表"></a>Linux 主要目录速查表</h3><ul><li><p>/：根目录，</p><p>一般根目录下只存放目录</p><p>，在 linux 下有且只有一个根目录，所有的东西都是从这里开始</p><ul><li>当在终端里输入 <code>/home</code>，其实是在告诉电脑，先从 <code>/</code>（根目录）开始，再进入到 <code>home</code> 目录</li></ul></li><li><p>/bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等</p></li><li><p>/boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：<code>/boot/vmlinuz</code>，系统引导管理器：<code>/boot/grub</code></p></li><li><p>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom /mnt</code></p></li><li><p>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有</p><ul><li>/etc/inittab</li><li>/etc/fstab</li><li>/etc/init.d</li><li>/etc/X11</li><li>/etc/sysconfig</li><li>/etc/xinetd.d</li></ul></li><li><p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下</p><ul><li><code>~</code> 表示当前用户的家目录</li><li><code>~edu</code> 表示用户 <code>edu</code> 的家目录</li></ul></li><li><p>/lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</p></li><li><p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</p></li><li><p>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载</p></li><li><p>/opt：给主机额外安装软件所摆放的目录</p></li><li><p>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等</p></li><li><p>/root：系统管理员root的家目录</p></li><li><p>/sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用</p></li><li><p>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下</p></li><li><p>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内</p></li><li><p>/usr：应用程序存放目录</p><ul><li>/usr/bin：存放应用程序可执行二进制文件的目录</li><li>/usr/share：存放共享数据</li><li>/usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</li><li>/usr/local：存放软件升级包</li><li>/usr/share/doc：系统说明文件存放目录</li><li>/usr/share/man：程序说明文件存放目录</li></ul></li><li><p>/var：放置系统执行过程中经常变化的文件</p><ul><li>/var/log：随时更改的日志文件</li><li>/var/spool/mail：邮件存放的目录</li><li>/var/run：程序或服务启动后，其 PID 存放在该目录下</li></ul></li></ul><p><strong>重点:</strong> <strong>/home/用户名</strong> 是用户的家目录.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Linux 和 Windows 文件系统的区别<br> 1.1 Linux 文件系统只有一个根目录(<strong>/</strong>)<br> 1.2 Windows 文件系统会有可能会有多个盘符(例如C、D、E…)</li><li><strong>/home/用户名</strong> 是用户的家目录, 是经常使用的目录.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥是人工智能</title>
      <link href="/2019/04/03/%E5%95%A5%E6%98%AF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
      <url>/2019/04/03/%E5%95%A5%E6%98%AF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZukIrsq7161xeGvkFcNun46boShNiatq5JZvqdjX5XjVlR6ToY48GAxQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>作者：武博士、宋知达、袁雪瑶、聂文韬</p></blockquote><p>本节我们会以生动有趣的漫画来介绍关于人工智能（AI）相关的故事，你将会学习到： <strong>人工智能的基本概念</strong></p><p><strong>1.1 啥是人工智能</strong><br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZWzSukZqmRVrdvVemO9siatS9tjtGR81eAGYv7NWSyWITibOOrTf2xK9w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>当有人问我，Dr.Wu 你的研究方向是什么？我回答：人工智能。 接着大约会得到以下四种问题： </p><p><strong>哇，好酷！是不是很难呢？</strong> </p><p><strong>是不是制造机器人帮助我们呢？</strong> </p><p><strong>AI和人工智能有什么区别？</strong> </p><p><strong>究竟啥是人工之智能？</strong> </p><p>接下来，我会带大家一一解惑。</p><p><strong>1.1.1 人的智慧和人工智能</strong></p><p>究竟什么是人工智能，什么是AI，接下来，由我为大家解答。 媒体上几乎每天都有AI和人工智能的词汇，总给人一种深奥神秘的感觉。人工智能顾名思义就是人类制造的智慧，英文叫Artificial Intelligence（AI），所以人工智能=AI。 </p><p>那么问题又来了，智慧究竟是什么？我们要以何种方式去制造智慧？要回答这个问题，就必须从人与人造物的 区别和人的智慧说起。 </p><p>对于人工智能的研究人员来说，目标并不是研究人类智慧的来源，而是以工程技术手段制造出类似人类智慧的 产品。  </p><p>人类和人工智能最大的差异是，肉体的有无。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZSbYzsu8L847X5pXuYGvEiaVvNfatNdYJBwXpzhE2JG29x9wSLnVpRuw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>人类可以通过身体获得外界资讯。透过感觉器官，我们可以感觉到声音、外观、触感、气味等，让我们觉得舒服或者讨厌，进而产生感情。 </p><p>不过人工智能并没有人类的身体，因此无法像人类一样通过肉体感觉器官来积累感觉经验，也无法借此获得知识。 </p><p>人工智能必须依赖人类，将人类通过鼻子、眼睛、嘴巴、皮肤…获得的外界资讯，以某种形式”输入“到人工智能，人工智能才可以加工和处理这些信息。 具体输入方式我们未来讨论。</p><p><strong>1.1.2 图灵测试：哪个一边是人？</strong></p><p>英国数学家，Dr.Wu 认为二十世纪最聪明的人三个人（爱因斯坦、图灵、冯诺依曼）之一，艾伦.图灵（Alan Turing：1912-1954）定义了一种方法，来判断人工智能是否成功，这种方法是：和自己对话的对象是人类还是人工智能？ </p><p>这种方法就是大名鼎鼎的图灵测试。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZZhXpn1212YWcQFkmNibWOfmjIC6gvgJPcb5TL2ykLTs2ykXX2CwRnAw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>只要三成以上的研究员将人工智能误以为是人类，就算通过图灵测试。 </p><p>但是由于计算机很难做到与人类接近的对话，所以很长一段时间都没有任何人工智能通过图灵测试。反而人类在不断学习计算机语言，这就是大量程序员的工作，和计算机对话。 </p><p>图灵测试又叫做模仿游戏‘Imitation Game’，一部描绘图灵一生的自传电影一样也叫模仿游戏，我觉得很好看哦。 Imitation 即为模仿。 </p><p>除了这部电影之外，《黑客帝国》、《终结者》、《全面进化》等描述人工智能的电影中，大多提到人工智能会威胁到人类生活，而不是给人类带来幸福，这让很多人谈到人工智能都会感到恐慌。 </p><p>但是，事实上，目前还没有做出公认通过图灵测试的人工智能。所以大家也不必恐慌哦。</p><p><strong>1.1.3 人工智能会思考吗？</strong></p><p>“思考”，大多数人会想到计算，应该是人工智能的专长。但事实上，要想像人类一样思考其实是一件非常困难的事情。 </p><p>人工智能需要以各种输入数据案例为基础，通过这些数据案例获取经验和知识，然后进行预测和判断。如果输入的案例太少，就无法做出判断。 情况相反，人类即使遇到过去未曾遇到的状况，也可以以弹性的方式面对各种状况。 </p><p>例如，人工智能需要看过上万张猫狗的图片才可以相对准确的识别猫狗图片，但是人类3岁左右的小朋友，只需要见过几次，就可以识别。差距还是巨大的。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZTfZic3rXM0eic33pYlPM6y45wP2gefKMfsysGPAgLShCPIOeqnIKgGGg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>但是，人类对于人类来说很难解决的问题，人工智能却能够迅速解决。例如：训练好的人工智能在图片识别过程中，效率远远高于人类，给他们10万张图片，他们会很快的为人类做好分类工作，无怨无悔，而且在工作过程中，人工智能本来的”智慧”也在提升。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZic88PlEGsls1K27E2XaOIaylGaP5yicPeRlOIvPtQkwVQmrjFd0lyXbA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>我们将在未来的章节提到，目前具有一定“智能”的AI，可以用什么样的方式来解决什么样的问题。明白人工智能的擅长之处与不擅长之处，是未来社会我们能够幸福生活的关键。</p><p>（未完待续…）</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零基础15行python代码搞定网易云热门歌单</title>
      <link href="/2019/03/31/15%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E9%97%A8%E6%AD%8C%E5%8D%95/"/>
      <url>/2019/03/31/15%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E9%97%A8%E6%AD%8C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>健身、吃饭、敲代码；等车、撸猫、下午茶……若能佐以合适的音乐当“配餐”，总是惬意非常。本文就将带你爬一爬网易云的那些热门歌单！</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAujmbtyGtGkagiaZCqLD1dXLxia1icvS3cazPR24ibGtun931k0rxNSRhCIbIuNLKjcjahJaibKQHhbELgQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>心情好或心情坏，点一首歌抚慰你受伤或躁动的心灵——下面教你用 15 行代码搞定热门歌单！</p><p>本文使用的是 Selenium 模块，它是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作，对于一些 JavaScript 渲染的页面来说，此种抓取方式非常有效。</p><p>采用了 Chrome 浏览器配合 Selenium 工作，本文的 Python 版本是 3.7.2。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h1><ol><li>若你的环境中没有 Selenium 模块，直接使用 pip 安装即可：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><ol start="2"><li><p>打开谷歌浏览器，检查Chrome的版本：在浏览器地址中输入 chrome://settings/help 回车即可看到：</p><p><img src="https://img.vim-cn.com/ac/4ed0c338deb650848bbc8e56ea2c6147b1bf17.png" alt="02.png"></p></li><li><p>打开 ChromeDriver 的官方网站（<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads），寻找与你当前浏览器版本相对应的" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads），寻找与你当前浏览器版本相对应的</a> ChromeDriver 下载：</p><p><img src="https://img.vim-cn.com/05/758873fffa1036762e388ecff28eead7b0be1f.png" alt="03.png"></p></li><li><p>选择你自己的操作系统类型进行下载即可：</p><p><img src="https://img.vim-cn.com/d1/7821da501ffe292bc5e376857e402582d194e0.png" alt="04.png"></p></li><li><p>以 Windows 为例，下载结束后，将 ChromeDriver 放置在 Python 安装目录下的 Scripts 文件夹即可：</p><p><img src="https://img.vim-cn.com/1b/5ca9231635c8c93f78b4c1a051573209cefdf6.png" alt="05.png"></p></li></ol><p>准备工作完成，代码写起来吧~</p><h1 id="迷你爬虫的实现"><a href="#迷你爬虫的实现" class="headerlink" title="迷你爬虫的实现"></a><strong>迷你爬虫的实现</strong></h1><p>我们这次的目标是爬取热门歌单，比如网易云音乐中播放量大于 1000万 的歌单信息（歌单名称、链接）。</p><ol><li><p>先来打开网易云的歌单第一页：    </p><p><a href="https://music.163.com/#/discover/playlist/" target="_blank" rel="noopener">https://music.163.com/#/discover/playlist/</a></p></li><li><p>使用 Chrome 的开发者工具 <f12> 进行分析：</f12></p><p><img src="https://img.vim-cn.com/f8/79c7e9ee5bb3083922c40acec3cf36cf3818ad.png" alt="02-2.png"></p></li></ol><p>我们想要拿的信息全在这里：</p><p>msk，封面 [mask]：有歌单的名称及链接</p><p>nb，播放数 [number broadcast]：135万</p><ol start="3"><li><p>我们还需要遍历所有的页，使用工具继续分析，找到“下一页”的 URL：</p><p><img src="https://img.vim-cn.com/d3/6bef2ed87892bb9d6d86935cc23cab4afb5c87.png" alt="02-3.png"></p></li><li><p>切换至最后一页，拿到最后一页的 URL：</p><p><img src="https://img.vim-cn.com/1f/9ec15c2bd641cce2ea5d1dbba8a3c8de3885c7.png" alt="02-4.png"></p></li><li><p>等我们爬取完所有符合的歌单信息后，将其保存在本地；</p></li><li><p>全部工作结束，最后再通过下面的伪代码回顾下整体思路：</p><p><img src="https://img.vim-cn.com/3f/b955a96ab865b20641f7498479a9a2441e3707.png" alt="02-6.png"></p></li><li><p>爬取的效果如下：</p><p><img src="https://img.vim-cn.com/46/826692648fd04b345d5754c9125e5f1ec9fe60.png" alt="02-7.png"></p></li></ol><p>另附源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网易云音乐歌单列表第一页地址</span></span><br><span class="line">url = <span class="string">'https://music.163.com/#/discover/playlist/?order=hot&amp;cat=%E5%85%A8%E9%83%A8&amp;limit=35&amp;offset=0'</span></span><br><span class="line"><span class="comment"># 用Chrome接口创建一个Selenium的WebDriver</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐页解析，直至歌单列表的最后一页</span></span><br><span class="line"><span class="keyword">while</span> url != <span class="string">'javacript:void(0)'</span>:</span><br><span class="line">    <span class="comment"># 用WebDriver加载页面</span></span><br><span class="line">    browser.get(url)</span><br><span class="line">    <span class="comment"># 切换至内容的iframe</span></span><br><span class="line">    browser.switch_to.frame(<span class="string">"contentFrame"</span>)</span><br><span class="line">    <span class="comment"># 定位歌单标签</span></span><br><span class="line">    data = browser.find_element_by_id(<span class="string">"m-pl-container"</span>).find_elements_by_tag_name(<span class="string">"li"</span>)</span><br><span class="line">    <span class="comment"># 解析当前页中所有的歌单详情</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="comment"># 获取歌单的播放量</span></span><br><span class="line">        num = data[i].find_element_by_class_name(<span class="string">"nb"</span>).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'万'</span> <span class="keyword">in</span> num <span class="keyword">and</span> int(num.split(<span class="string">'万'</span>)[<span class="number">0</span>]) &gt; <span class="number">1000</span>:</span><br><span class="line">            <span class="comment"># 获取播放量大于1000万的歌单封面</span></span><br><span class="line">            msk = data[i].find_element_by_css_selector(<span class="string">"a.msk"</span>)</span><br><span class="line">            <span class="comment"># 把歌单封面中的标题、链接以及播放量，存储在TXT文件中</span></span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"163playlist.txt"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">' '</span>.join([msk.get_attribute(<span class="string">'title'</span>), num, msk.get_attribute(<span class="string">"href"</span>)]) + <span class="string">'\n'</span> + <span class="string">'='</span> * <span class="number">50</span> + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment"># 定位'下一页'的URL</span></span><br><span class="line">    url = browser.find_element_by_css_selector(<span class="string">"a.zbtn.znxt"</span>).get_attribute(<span class="string">"href"</span>) </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结束调用</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
            <tag> 网易 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX初识</title>
      <link href="/2019/03/30/LaTeX%E5%88%9D%E8%AF%86/"/>
      <url>/2019/03/30/LaTeX%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>闲来无事，想起了自己当年的毕业论文，想拿来再次修改修改，看到网上很多专业人士都是使用LaTeX来写论文，似乎很流弊的样子，天呐，想想当年我还是使用的Word，就修改格式都用了大半天的时间，太可怕了，难道这就是专业人士和我们这些业余的区别！老衲怎能轻言放弃，于是乎就一顿Google，百度，看看是何方技能！传播与众人</p><h1 id="LaTeX简介"><a href="#LaTeX简介" class="headerlink" title="LaTeX简介"></a>LaTeX简介</h1><h2 id="什么是TeX"><a href="#什么是TeX" class="headerlink" title="什么是TeX"></a>什么是TeX</h2><p>电子排版系统的出现给印刷出版业带来了一场革命，利用电子计算机及各种辅助设备，可以完成从文稿、图表的录入、编辑、修改、组版，直至得到各种不同 用途、不同质量的输出结果。利用电子排版系统，可以减轻劳动强度，缩短出版周期。</p><p>目前世界上有许多电子排版系统。这些系统各有特点，也各有自己的适用范围。TeX 就是一种优秀的电子排版系统。</p><p>TeX 提供了一套功能强大并且十分灵活的排版语言，它多达 900 多条指令，并且 TeX 有宏功能，用户可以不断地定义自己适用的新命令来扩展 TeX 系统的功能。许多人利用 TeX 提供的宏定义功能对 TeX 进行了二次开发，其中比较著名的有美国数学学会推荐的非常适合于数学家使用的 AMS-TeX 以及适合于一般文章、报告、书籍的 LaTeX 系统。</p><p>TeX 系统是公认的数学公式排得最好的系统。<a href="http://www.ams.org/" target="_blank" rel="noopener">美国数学学会 （AMS）</a> 鼓励数学家们使用 TeX 系统向它的期刊投稿。世界上许多一流的出版社如 Kluwer、Addison-Wesley、牛津大学出版社等也利用 TeX 系统出版书籍和期刊。</p><p>大部分的 TeX 系统都是免费的。Knuth 教授还公开了他的全部源程序。TeX 系统目前已经在数百种计算机系统上得到实现。TeX 系统的排版结果 DVI（DeVice Independent）文件与输出设备无关。DVI 文件可以显示、打印、照排，几乎可以在所有的输出设备上输出。TeX 排版源文件及结果在各种计算机系统上互相兼容。</p><h2 id="TeX-的历史"><a href="#TeX-的历史" class="headerlink" title="TeX 的历史"></a>TeX 的历史</h2><p>七十年代末，<a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_blank" rel="noopener">Donald E. Knuth（高德纳）</a> 在看到其多卷巨著“The Art of Computer Programming”第二卷的校样时，对由计算机排版的校样的低质量感到无法忍受。因此决定自己来开发一个高质量的计算机排版系统，这样就有了 TeX 。</p><p>TeX 的名字是由大写的希腊字母“tec”(tau, epsilon, chi)组成。在希腊语中这个词的意思是“科技”和“艺术”，这也解释了它的发音。“T”和“E”就像在“technology”中的发音一样，而“x” 的发音类似于苏格兰语单词“loch”或德语单词“ach”中的“ch”，也类似于西班牙语中的“j”或俄语中的“kh”。TeX 标志为 TEX ，这三个字母相靠得很近，而且中间的那个 E 有点儿下沉。但在无格式文件中，就写为 TeX 。</p><p>TeX 的第一版于 1978 年面世。在经过了不断的改进后，1982 年版的 TeX 是一个十分稳定的版本。从此以后，TeX 没有较大的变动，只有很少部分的改进和错误修正。现在几乎所有的操作系统平台下，都有相应的 TeX 软件，而且用它们排版同一个文件得到的输出结果是相同的。TeX 目前的版本是 3.141592，很接近圆周率π。每有一新的版本，就会加上一个π的小数点后的数。所以我们已经知道下一版本的 TeX 是 3.1415926，最终将收敛到π。这也代表了 TeX 不断追求完美的理想。</p><p>TeX 的源程序是用 Pascal 写成的，原因是 Knuth 希望 TeX 尽可能方便地移植到其它的操作系统中去。当时 Pascal 是最适合于这一要求的编程语言。这也使得 TeX 现在已经在几乎所有的计算机系统中得到实现。</p><p>TeX 的另一个重要的特征就是它的输出是与设备无关的。TeX 的输出文件称为 DVI 文件，即是“Device Independent”。一旦 TeX 处理了你的文件，你所得到的 DVI 文件就可以被送到任何输出设备如打印机，屏幕等并且总会得到相同的结果，而这与这些输出设备的限制没有任何关系。这说明 DVI 文件中所有的元素，从页面设置到文本中字符的位置都被固定，不能更改。</p><p>TeX 现在已经被它的开发者 Knuth 所“冰封”(frozen)，新版本的 TeX 只有少许改进和错误修正。这些变动必须保证不会使得即使是写于 1982 年的 TeX 文档无法编译，TeX 自带了测试文件来确保这一点。如果测试文件文件的输出结果不同于预定的结果，那么这个排版系统就不能够被称为“TeX”。所以像一些对 TeX 有很大改进的软件，如“Omega”等将不能被称为“TeX”，尽管它也是基于“TeX”的。</p><p>在设计 TeX 的同时，Knuth 还设计了一个字体生成程序 MetaFont。MetaFont 是独立于 TeX 之外的，但又与 TeX 有着非常密切的联系。MetaFont 生成的只是位图字体，当对字体进行缩放时的效果不佳。对于如何得到像 Type1 字体一样的轮廓字体，现在还在研究之中。与 TeX 一样，Knuth 也“冰封”了 MetaFont 。所以 MetaFont 的进一步的改进和发展将会由其他人来完成，而且名字也将不再是 MetaFont 。</p><h2 id="TeX-的未来"><a href="#TeX-的未来" class="headerlink" title="TeX 的未来"></a>TeX 的未来</h2><p>虽然 TeX 在过去的二十多年中没有大的变化，但这并不意味着 TeX 是一个僵化的系统。恰恰相反，TeX 开放的设计使得它能够很容易的适应新的要求。例如，在没有改动内核的情形下，TeX 很容易地实现了对 PostScript 字体和外部图形的支持。TeX 还是第一个能够自动生成 HTML 的字处理软件。最近，TeX 又开始增加了在不借助其它工具（如 Adobe Distiller）的条件下生成 PDF 的扩展功能。下面列出的几个项目都是正在进行中，对 TeX 的功能进行了扩展。</p><h3 id="PDFTeX"><a href="#PDFTeX" class="headerlink" title="PDFTeX"></a>PDFTeX</h3><p>完全兼容标准的 TeX ，但能够给出 PDF 输出。它也可以输出标准的 DVI 。</p><h3 id="e-TeX"><a href="#e-TeX" class="headerlink" title="e-TeX"></a>e-TeX</h3><p>不仅完全兼容标准的 TeX ，还支持一种“扩展模式”。在“扩展模式”中引入了许多新的特性和增强功能。这些新的特性和增强功能提供了更好的编程工具和对输出的控制。</p><h3 id="Omega"><a href="#Omega" class="headerlink" title="Omega"></a>Omega</h3><p>这是一个几乎是完全重新写过的，支持 Unicode 的 TeX 程序。Omega 有很多特征都超出了 Knuth 对 TeX 的原始设想。它采用了与 TeX 不同的方法来处理字符，使得可以处理非拉丁语系的文本。也支持从右到左，从上到下的排版方式。</p><h3 id="NTS"><a href="#NTS" class="headerlink" title="NTS"></a>NTS</h3><p>NTS 代表“New Typesetting System”。Knuth 已经停止发展 TeX，并决定任何超越 TeX 的扩展都不能被称为 TeX 。NTS 只是一些对于 TeX 的后续继承者的设想和概念的集合，还不是一个实际上的系统。该项目的第一个公布的产品就是 e-TeX。后来不知什么缘故，NTS的开发就停止了。直到 2002 年左右，一些 TeX 专家，想用 Java 开发 TeX，于是把中途夭折的 NTS 项目捡了起来，搞出了一个叫做 ExTeX 的东西，但是并没有普遍应用。</p><h3 id="MLTeX"><a href="#MLTeX" class="headerlink" title="MLTeX"></a>MLTeX</h3><p>这个 TeX 的扩展引入了命令 \charsubdef，使得可以更为简单方便的使用 8 bit 字符。不过，与 e-TeX 相比，这只是一个微小的改进。</p><h3 id="XeTeX"><a href="#XeTeX" class="headerlink" title="XeTeX"></a>XeTeX</h3><p>Jonathan Kew 在 e-TeX 基础上添加 Unicode 支持，并且连接 Mac OS X 的各种技术，比如ATT,Quartz,QuickTime，产生了一个重要的TeX分支，叫做XeTeX.XeTeX在2005/6年陆续发布了它的 Windows 和 Linux版本，最终集成在 TeXLive 2007 当中，标志着它被广泛地认可。在 XeTeX 中，使用多国语言，变得非常轻松，并且可以方便地使用系统的 TrueType 和 OpenType 字体，因此得到许多 TeX Guru 的喜爱。</p><h3 id="LuaTeX"><a href="#LuaTeX" class="headerlink" title="LuaTeX"></a>LuaTeX</h3><p>尽管 Omega 项目在开始时看上去很有希望，但是它的开发进展缓慢并且功能上也非常不稳定（基本上可以认为这个项目已经死亡）。于是，Giuseppe Bilotta 等人启动了 Aleph 项目，目的是让 Omega 稳定并且引入了 e-TeX 的扩展功能。后来 Aleph 项目现在也停止了，不过它的大部分功能都被集成到了 <a href="http://wiki.ctex.org/index.php?title=LuaTeX&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">LuaTeX</a> 中。<a href="http://wiki.ctex.org/index.php?title=LuaTeX&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">LuaTeX</a> 是一个新的 TeX 引擎项目，由科罗拉多州立大学（Idris Samawi Hamid 的东方 TeX 项目）和 NTG 资助，该项目于 2006 年启动，于 2007 年夏季发布首个 beta 版本。</p><p>LuaTeX 是 Aleph 与 pdfTeX 项目的继任者，主要由 Taco Hoekwater 开发。除了兼有 Aleph 和 pdfTeX 的功能之外，LuaTeX还具有以下特点：</p><ul><li>内部集成了轻量级的动态编程语言 Lua，可以采用该语言扩展 LuaTeX 功能或宏包；</li><li>提供了 OpenType 字体的本地支持，与 XeTeX 做法不同的是，LuaTeX 没有使用操作系统自带的字体库来访问字体，而是使用了 FontForge库；</li><li>内部集成了 MPLib（一个扩展的 MetaPost 库模块）。</li></ul><h2 id="TeX-的优点"><a href="#TeX-的优点" class="headerlink" title="TeX 的优点"></a>TeX 的优点</h2><p>在一个充斥着“所见即所得”(WYSIWSG)桌面出版软件的情况下来使用 TeX 确是有点令人奇怪。但是，在某些情形下，你会感到 TeX 是最好的，甚至是唯一适合的系统。</p><p>首先我们来看一下 TeX 的优势所在：</p><ul><li><strong>高质量的输出</strong> TeX 遵循传统的排版规则，以排版的质量为最重要的目标。如果你把 TeX 的输出结果和用其它的排版软件排版相同的文本所得到的结果加以比较，你就会发现其中的区别。</li><li><strong>超常的稳定性</strong> 自从 TeX 出现以来，只有一些微小的改动。也就是说，十几年前的 TeX 文件用现在的 TeX 系统排版得到的结果与十几年前得到的结果是一样的。稳定性还体现在 TeX 系统极少会崩溃，可以处理任意大小的文件，即使你的计算机的内存很少，TeX 也可自如的工作。</li><li></li><li><p><strong>TeX 是可编程的</strong> TeX 是一种宏命令编程语言。你可以用很少的命令来完成非常复杂的工作。如果需要的话，你也可以重新定义 TeX 的所有命令来得到特殊的效果。</p></li><li><strong>高度的灵活性</strong> TeX 自从出现以来其内核只有微小的改动。但是由于其内核的设计方式，世界上的 TeX 使用者可以让 TeX 做几乎任何工作。你可以用 TeX 来排版英文文本，也可以排版德文，俄文，中文等多种语言。你还可以用 TeX 来排版乐谱，象棋，围棋棋谱等等。</li><li><strong>简单方便</strong> TeX 文档是 ASCII 码的文本文件。因此，即使你手边没有 TeX 系统，你也可以看懂绝大部分的内容。TeX 文件的这种特点使得它占用很少的存储空间，也可以很方便的用 email 来传输。</li><li><strong>良好的通用性</strong> 目前为止，TeX 几乎在所有的计算机操作系统平台上得到实现。如：Atari，Apple，Macintosh，Unix，VMS，MS-DOS，MS-Windows 和 OS/2 等等。TeX 的源文件可在不同的平台之间自由的交换，而得到的输出是完全相同的。</li><li><strong>低廉的价格</strong> TeX 是免费软件，它的源程序也是免费的。你可能仅仅需要支付邮费，甚至于一分不花地得到适合你的 TeX 系统。世界上有很多非常好的 TeX 免费软件如：teTeX，MikTeX，fpTeX 等等。同时也有一些具有各自特点（如或多或少的所见即所得特性的）和提供专家级帮助系统的商业版本。</li><li><strong>超级技术支持</strong> 由于 TeX 并不是被某个公司所垄断开发，所以世界各地的使用者设计了统一的技术支持的方式。这通常是通过因特网以 email, WWW, Usenet 或 Ftp 的方式来提供，有时也可能通过电话或传真的方式。绝大多数情况下这些技术支持都是免费的，这也是 TeX 的精神。</li><li><strong>TeX 是一种乐趣</strong> 使用 TeX 不仅仅是一种工作手段，也是一种乐趣。它有挑战，也有荣誉。很多人在熟悉了 TeX 之后都开始把使用 TeX 作为一种爱好，而不是一件枯燥无味的劳动。</li></ul><h2 id="TeX-的不足"><a href="#TeX-的不足" class="headerlink" title="TeX 的不足"></a>TeX 的不足</h2><p>在展示了 TeX 的优秀之处后，也得承认 TeX 也有一些不足的地方：</p><ol><li>TeX 不是在一个下午就能完全学会的，除非你是一个真正的天才。当你开始学习并使用它的时候，你将会不停的去翻看 TeX 的参考手册来寻找一个 TeX 命令。你也会发现 TeX 常常不理会你键入的命令，还给出一个让你感到迷惑的错误讯息。这一切都说明了掌握 TeX 需要一个比较长而且艰难的学习过程。TeX 的一些扩展如 LaTeX、ConTeXt 则要相对简单的多，使用起来也比 TeX 方便，一个新手完全可以在一个下午或者更短的时间内学会开始使用 LaTeX 或 ConTeXt。</li><li>当发生错误的时候，TeX 会给出一些信息来提示你。但很多情况下并不足以是你迅速准确的找到错误之所在。尤其对刚刚开始学习的新手来说更是如此。</li><li>像 TeX 这种宏语言不同于其它的计算机语言，如 C，Pascal 等，大多数人并不了解。因此，当你想要写自己的宏命令时，你需要对 TeX 有比较深入的了解才能写出牢固可靠的宏命令。</li><li>TeX 不是所见即所得的。尽管市场上有些近似于所见即所得的自由/开源软件（如 <a href="http://www.lyx.org/" target="_blank" rel="noopener">LyX</a>）或商业软件，但即使与最普通的字处理软件比，也 还是有不小的差距。</li></ol>]]></content>
      
      
      <categories>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇-杂谈WebGIS</title>
      <link href="/2019/03/30/%E6%9D%82%E8%B0%88WebGIS/"/>
      <url>/2019/03/30/%E6%9D%82%E8%B0%88WebGIS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>我相信大家对百度地图，谷歌地图等相关应用已经是非常熟悉了。通过这些应用，我们可以浏览地图、定位我们自己的位置、查找我们想知道的兴趣点、搜索交通路线等等。而其实，这些功能便是WebGIS的一些最基本的功能。</p><p>那么什么是WebGIS呢，说到这里，我还是首先给大家讲讲什么是GIS。</p><h2 id="2．GIS简介"><a href="#2．GIS简介" class="headerlink" title="2．GIS简介"></a>2．GIS简介</h2><h3 id="2-1-GIS的名词解释"><a href="#2-1-GIS的名词解释" class="headerlink" title="2.1 GIS的名词解释"></a>2.1 GIS的名词解释</h3><p>GIS的全名是Geographic Information System，中文全名是地理信息系统。它是在计算机硬、软件系统支持下，对整个或部分地球表层（包括大气层）空间中的有关地理分布数据进行采集、储存、管理、运算、分析、显示和描述的技术系统。</p><h3 id="2-2-什么是GIS学科"><a href="#2-2-什么是GIS学科" class="headerlink" title="2.2 什么是GIS学科"></a>2.2 什么是GIS学科</h3><p>撇开这些晦涩的文字，我争取用更形象的方法来给大家介绍下GIS这个学科。</p><p>我们人类在很久之前就已经开始使用羊皮或者纸质的地图了，他的用途主要便是给人们的行军、航海等做向导，而这同样也是现代GIS学科里GIS最基本的功能之一。到19世纪时，现代GIS学科开始慢慢萌芽。这里有一个很有名的例子。1854年伦敦发生霍乱，10天就死了500人。居民大多怀疑瘟疫是由于地下的墓穴引起的，引起了极大的社会恐慌。当时有个有名的医生叫Snow博士，他不信这个原因，为了查出真正的霍乱源头，他首先绘出了伦敦地图，然后将所有霍乱病人的所在地标出来，然后他发现了一个有趣的现象，在伦敦的一个居民饮水井附近出现的霍乱病人最多，并且最开始出现的霍乱病人也是在那里发现的。最后Snow博士对那口井进行检查，确定了霍乱发生的源头。从这个例子中我们可以看出，地图的应用已经不再局限于导航了，而开始慢慢利用其得天独厚的时间空间优势与其他学科开始进行结合。</p><p>到了20世纪电脑的出现，人造卫星的升天等技术的突破，GIS这个学科也相应的开始走向成熟以及开始普及。20世纪60年代，加拿大科学家首先提出了GIS这个学科。到了20世纪末，一大批优秀的GIS软件已经出现，比如Esri公司的ArcGIS系列，MapInfo公司的MapInfo。国内的GIS从上世纪80年代才开始起步，不过到上世纪末时，也出现了自己的GIS公司，比较有名的有GeoStar、MapGIS等。</p><p>而此时的GIS已不再是局限纸上的地图了，它已经成为了一个计算机技术和多种学科相交叉的新型学科了。它涉及到测量学——地理信息的采集和地图的制作等，计算机科学——电子地图的制作和展现以及各种GIS功能的实现，物理学——对传感器的研究以及光谱和影像的研究，气象学——大气层等对卫星影像的影响等，生物学、医学、犯罪学等——研究地理等各时间空间因素对这些学科的影响。</p><p>GIS是什么呢，说的最通熟易懂的就是，GIS是利用测绘生成纸制地图或者航拍以及卫星等生成影像后，将这些数据存储在计算机中，以地图或图片的形式表现出来，然后根据实际生产生活以及科研中的各种需求，进而提供具体的经过处理后的数据。</p><h2 id="3-WebGIS简介"><a href="#3-WebGIS简介" class="headerlink" title="3.WebGIS简介"></a>3.WebGIS简介</h2><h3 id="3-1什么是WebGIS"><a href="#3-1什么是WebGIS" class="headerlink" title="3.1什么是WebGIS"></a>3.1什么是WebGIS</h3><p>顾名思义，WebGIS就是展现于网络上的GIS。在上世纪八十年开始，出现的大量GIS软件，基本上都是C/S架构的，也就是首先需要在本机上装有专业的GIS软件，然后用户根据需求使用这些GIS软件。当然这种桌面端的GIS软件有其天然的优势，比如开发相对简单，不需要Internet支持，以及可以做更多的复杂功能、响应相对迅速等优势。但是同时，其缺点更是不容忽视。首当其冲的便是不便于推广，而不便于推广的原因在于C/S系统其本身的天然的劣势：不便于更新，不便于跨平台，不便于用户在不安装指定客户端的情况下使用。</p><p>从本世纪开始，internet进入了爆发式增长阶段，网络的铺设以及网速的提升都有了大幅度增加，这为WebGIS的发展提供了坚实的大环境。于是，基于B/S的GIS系统越来越多的开始提供服务，并且在RIA（富客户端）技术、AJAX（动态网页）技术的涌现和成熟，WebGIS也基本能展现出与C/S一样的效果和功能。而WebGIS的大发展，更是用户的需求，google地图和百度地图等服务提供商的大规模扩张便是最好的证明。</p><p>什么是WebGIS，就是将GIS这门学科所能提供的功能，以B/S技术展现给用户，使用户只需要在浏览器上便能使用这些GIS功能的一个应用方向。</p><h3 id="3-2对国内WebGIS行业的理解"><a href="#3-2对国内WebGIS行业的理解" class="headerlink" title="3.2对国内WebGIS行业的理解"></a>3.2对国内WebGIS行业的理解</h3><p>目前使用WebGIS技术的公司可以大致分为两个方向：一个是互联网方向，一个是行业应用方向。</p><p>国内的互联网方向里基本可以说已经被百度地图，搜搜地图，高德地图，三个巨头垄断。所以对于想从事互联网方向的WebGIS开发人员，其实可以选择的大公司并不多。但是，如果你是一个技术足够好，且技术不局限于一般的关系数据库，对大数据和分布式系统感兴趣的WebGIS开发人员，强烈建议你去这些互联网公司，在那里你能接触到最新的IT技术以及感受到强大的头脑风暴。也便是，对新技术，对前沿方向有更多追求的人，去互联网公司是很好的选择。</p><p>但是我们不得不承认另外一个现实，这些互联网公司基本集中在北上广深，并且对GIS研发人员在技术上的需求是，计算机技术的比重要远大于对GIS学科本身的理论所占的比重。于是，更多的GIS学科出身的人，最后选择的是行业应用公司。而投身于这样的公司，就没有前途吗？答案是否定的。</p><p>Esri公司作为全球最成功的GIS软件公司，很好的给出了这个答案。目前Esri的AO库号称世界上第二大的库，除了微软的Framework，就是它了。它同时也是一个年盈利在8亿美元的公司。Esri公司与美国和加拿大政府的合作堪称行业公司的典范，它为这两个国家的数字化城市的建设立下了汗马功劳，做出了很多优秀的作品。说这个例子，只是为了表明，在我们的数字化城市的需求越来越深入，政府的需求越来越实际，整个国家的市场建设越来越合理以及公平公正透明，WebGIS在行业上的应用也将越来越广泛，并且越来越能够服务政府、企业和人民，并且更能做出有真实价值的产品。并且，从事行业应用的研发人员，随着对所从事行业理解的深入，这些理解给未来所带来的收获可能比技术单纯的提高所带来的收获要大得多。要知道，项目需求分析靠的基本是行业理解，当然，对技术的了解也给项目可行性分析提供了保障。两者相辅相成。</p><p>每个人追求不一样，根据自己的需求，根据自己的现状，做出选择，坚持下去，不说梦想是否能实现，起码你不会是一个自己都认为自己活该如此平庸的人。</p><h2 id="4-WebGIS的框架"><a href="#4-WebGIS的框架" class="headerlink" title="4.WebGIS的框架"></a>4.WebGIS的框架</h2><p>前面说了太多的非技术类的话，这里我们开始提一个技术类话题——WebGIS的框架。其实WebGIS的框架跟其他Web项目的框架没有很多本质上的区别。可能唯一的不同是WebGIS需要提供一些地图方面的功能服务。这里我先把这个框架给出，同时每个层面需要的技术我也在其中大致画出。</p><p>​                                    <img src="https://images0.cnblogs.com/i/656746/201408/021630108995466.png" alt="img">                    </p><p>​                                       </p><h3 id="4-1前端"><a href="#4-1前端" class="headerlink" title="4.1前端"></a>4.1前端</h3><p>如所有的Web项目一样，前端由HTML、CSS、JS、Flex等语言组成。根据需求和语言的特性，选择合适的语言进行开发是至关重要的。没有最好的语言，只有最合适的语言。</p><h3 id="4-2-后台程序"><a href="#4-2-后台程序" class="headerlink" title="4.2 后台程序"></a>4.2 后台程序</h3><h4 id="4-2-1-中间件"><a href="#4-2-1-中间件" class="headerlink" title="4.2.1 中间件"></a>4.2.1 中间件</h4><p>开发时，我们要选择适合自己的中间件。不同的中间件有其特性，如果是一般项目，tomcat等是很合适的，其使用方便，相关技术支持和资料也很好查找。但是如果是大型的集群项目，Weblogic和WebShpere可能是更好的选择，但是这两个中间件首先配置就是有难度的，同时不同的版本，可能对某些jar包的支持存在问题。如果项目必须使用国产的中间件，TongWeb和Apusics是不错的选择。</p><h4 id="4-2-2-地图服务器"><a href="#4-2-2-地图服务器" class="headerlink" title="4.2.2 地图服务器"></a>4.2.2 地图服务器</h4><p>在WebGIS中，与其他一般的Web工程有明显区别的就体现在地图服务器上面。一般的地图服务器都由已有的软件商提供了解决方案，比较流行的有AGS、Geoserver、MapServer、SuperServer等。利用这些地图服务器我们能很好的实现地图的发布以及对一些空间查询和空间操作的支持。</p><h4 id="4-2-3-业务服务器"><a href="#4-2-3-业务服务器" class="headerlink" title="4.2.3 业务服务器"></a>4.2.3 业务服务器</h4><p>业务服务器是Web项目里不可获取的一环。不管是利用哪些已有框架编写，比如Spring、Struts、Hibernate等，我们一般还是会将业务服务器的实现分为三个层次，即有名的MVC模式。而不同的框架里这三个层次的实现各有差别。</p><h3 id="4-3-数据"><a href="#4-3-数据" class="headerlink" title="4.3 数据"></a>4.3 数据</h3><p>WebGIS的数据大致可以分为三种，一种是地图、影像数据，一种是空间属性数据、一种是业务数据。地图、影像数据一般是一些png或者其他格式的数据组成。</p><p>在GIS中有个很重要的概念，即影像金字塔。这个概念主要是为了加速地图在前端的显示。而我们准备地图、影像数据时，也一般会首先对这些数据进行切图。</p><p>空间属性数据，是通过一些工具将已经整理好的数据进行入库。对于AGS，只有连接的是入库数据的mxd，才能发布成FeatureServer服务，以供数据的编辑。当然，空间数据入库后还可以支持业务逻辑的使用。</p><p>第三种数据，业务逻辑数据，是每个Web项目必须有的，它根据不同的业务需求将业务所需的数据进行采集和入库。</p><h2 id="5-从WebGIS的原理谈起"><a href="#5-从WebGIS的原理谈起" class="headerlink" title="5.从WebGIS的原理谈起"></a>5.从WebGIS的原理谈起</h2><p>目前很多公司都提供了自己的二次开发包，在前端的有OpenLayers、AGS API for JS/Flex等。在后台的也有geoTools、AO等。用这些开发包，我们可以很快的实现出图以及很多GIS功能，基本上不用写太多的编码。</p><p>但是，同样，由于封装的太好，很多WebGIS的原理我们也便忽略而不做了解了。</p><p>这里，我希望利用我薄弱的知识，能和大家一起，探讨一些WebGIS中常用的原理知识。希望大家支持。</p><h2 id="6-感想"><a href="#6-感想" class="headerlink" title="6.感想"></a>6.感想</h2><p>由于我薄弱的理论和技术基础，也谈不上对WebGIS的明天有很大的预言。我只希望我们每个人都争取做一个完美主义者，同时也是一个有圣徒情怀的人，从而作践自己实现目标。与大家一起进步。希望我也能保持自己的写作动力，积累经验和知识。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么你得学些TCP知识</title>
      <link href="/2019/03/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BE%97%E5%AD%A6%E4%BA%9BTCP%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/03/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BE%97%E5%AD%A6%E4%BA%9BTCP%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>这不是指要明白 TCP 的所有东西，也不是说要通读 《TCP/IP 详解》。不过懂一点 TCP 知识是很有必要的。理由如下：</p><p>当我还在 Recurse Center 的时候，我用 Python 写过 TCP 协议栈（还写过一篇文章：如果你用 Python 写 TCP 协议栈会遇到什么？）。这是一次有趣的学习经历，但是也仅此而已。</p><p>一年以后，工作中有人在 Slack 上提到：“嘿，我在向 NSQ 发布消息时，每次要耗费 40 毫秒”。我已经断断续续思考了一个星期，但是没有任何结果。</p><p>一点背景知识：NSQ 是一个消息队列，你通过本地的一个 HTTP 请求向其发布消息。发送本地的一个 HTTP 请求确实不应该花费 40 毫秒，有时候会更差。NSQ 守护进程的负载不高，也没有使用过多的内存，也看不到 GC 停顿。这究竟是为什么呢？神呐，救救我吧！</p><p>突然我记起我一周以前看过的一篇叫做“性能研究（In search of performance）”的文章——我们如何为每个 POST 请求节省 200ms。在这篇文章中，他们说到为什么每个 POST 请求会花费额外的 200 毫秒。就是这个原因。这是该文章中的关键段落：</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="延迟确认（ACK）-与-TCP-NODELAY"><a href="#延迟确认（ACK）-与-TCP-NODELAY" class="headerlink" title="延迟确认（ACK） 与 TCP_NODELAY"></a><strong>延迟确认（ACK） 与 TCP_NODELAY</strong></h3><blockquote><p>Ruby 的 Net::HTTP 会将 POST 请求切分为两个 TCP 包，一个消息头，一个消息体。相反，curl 会将这两者合并为一个包。更糟糕的是，Net::HTTP 在打开 TCP 套接字时不会设置 TCP_NODELAY，这将导致第二个包需要等到第一个包的接收确认通知之后才能发送。这是 Nagle 算法导致的。</p></blockquote><blockquote><p>转换到连接的另一端，HAProxy 需要决定如何确认这两个包。在 1.4.18 版本中（我们正在用的版本），它是通过 TCP 延迟确认通知来实现的。延迟确认对 Nagle 算法有非常糟糕的影响，会导致请求暂停直到服务器延迟确认超时。</p></blockquote><p>现在我们解释这个段落说的内容。</p><ul><li>TCP 是一个通过数据包传输数据的算法</li><li>他们的 HTTP 库将 POST 请求分割成两个小的数据包发送</li></ul><p>接下来，TCP 采用类似如下的步骤进行交互：</p><blockquote><p>application：Hi！这里有一个数据包。<br>HAProxy：（沉默），等待第二个包发送<br>HAProxy：对了，我需要返回一个确认，不过没关系，等会吧<br>application: （沉默）<br>application：好吧，我正在等待确认，可能现在网络延迟比较大<br>HAProxy：好吧，太烦人了，这是一个确认。<br>application：好极了，这是第二个数据包！！！<br>HAProxy：亲，我们已经搞定了。</p></blockquote><p>这个过程是不是应用程序和 HAProxy 都在消极等待另一方发送信息？这就是那额外的 200ms。应用程序这么做的是因为 Nagle 算法，而 HAProxy 消息等待的原因是延迟确认。</p><p>据我所知，延迟确认是所有 Linux 系统的默认行为。所以这不是一个偶然或者异常情况，如果发送 TCP 数据包多一个 1 个，你就会遇到这种情况。</p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="现在，我们成为专家了"><a href="#现在，我们成为专家了" class="headerlink" title="现在，我们成为专家了"></a><strong>现在，我们成为专家了</strong></h3><p>读过这篇文章之后我很快就忘了。不过当我被额外的 40 毫秒难住的时候，我又记起来了。</p><p>所以我认为——这不可能是我的问题，可能吗？可能吗？？然后我发了一封邮件给我团队说：“我想我快要疯了，但是这可能是 TCP 的问题”。</p><p>所以我提交了一次修订，将我的应该调整为 TCP_NODELAY，然后问题就“嘣”的一声解决了。</p><p>40 毫秒的延迟立马就消失了。所有的事情都解决了，我就是个天才。</p><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="我们是否应该完全停止使用延迟确认？"><a href="#我们是否应该完全停止使用延迟确认？" class="headerlink" title="我们是否应该完全停止使用延迟确认？"></a><strong>我们是否应该完全停止使用延迟确认？</strong></h3><p>我刚好在 Hacker News 看到 John Nagle （Nagle 算法的创始人）对 @alicemazzy 提到这个问题的评论。</p><blockquote><p>本质问题是延迟确认。200 毫秒的“延迟确认”是一个非常不好的主意，1985 年中，在伯利克（Berkeley）研究 BSD 的人实际上没有真正明白这个问题。延迟确认是应用层对 200 毫秒内是否响应的一场赌博，但是即便每次它都赌输了，TCP 仍在使用延迟确认。</p></blockquote><p>他继续说到，确认本身是很小并且消耗很低的，延迟确认引起的问题可能比它解决的问题还要多。</p><h3 id="不懂得-TCP-你就无法解决-TCP-问题"><a href="#不懂得-TCP-你就无法解决-TCP-问题" class="headerlink" title="不懂得 TCP 你就无法解决 TCP 问题"></a><strong>不懂得 TCP 你就无法解决 TCP 问题</strong></h3><p>我曾经也认为，TCP 是一个相当底层的问题，我不需要明白。大多数时候你的确不需要明白。但是有的时候，当你在实践中遇到由于 TCP 算法引起的 bug 时，懂点 TCP 知识就变得非常重要了。（正如我们经常在博客中讨论的，许多事情都是这样，比如系统调用和操作系统:) ）</p><p>延迟确认及 TCP_NODELAY 的交互非常不好——这对任何语言实现的 HTTP 请求都有影响。你不需要很深入的去了解，成为系统程序专家。但是了解一点 TCP 是如何运作的，对我的工作的确大有裨益。通过对 TCP 的学习，我才意识到这篇博客所描述的问题也许正好是我所熟悉的领域。我也一直在使用 strace，并且会一直使用下去。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度解密 HTTP 通信细节</title>
      <link href="/2019/03/29/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86HTTP%E9%80%9A%E4%BF%A1%E7%BB%86%E8%8A%82/"/>
      <url>/2019/03/29/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86HTTP%E9%80%9A%E4%BF%A1%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>在上一篇《<a href="https://llqing.github.io/2019/03/28/san-ci-wo-shou-si-ci-hui-shou-ni-zhen-de-dong-ma/" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a>》中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的 <code>锤子</code>，拿着 <code>锤子</code>，看什么都像 <code>钉子</code>！在这篇文章中，我对准了 <code>HTTP</code>这颗钉子砸下去，咳咳。</p><p>为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我则是把复杂的东西撕碎了给人看。</p><p>文章稍长，请在看本文时保持耐心。我先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！</p><p>为了更好的阅读体验，我手动贴上本文的目录：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cjHbwiaFiaXcneDwD5tV48jf8JedJ22VnrWluok7iaZyP2aHSUfTeaRW9A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id="HTTP报文截获"><a href="#HTTP报文截获" class="headerlink" title="HTTP报文截获"></a>HTTP报文截获</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我手头现在有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是 <code>Fence2Area</code>. 使用方传入一个围栏（由点的列表组成，点由&lt;经度，纬度&gt;表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。</p><p>我请求服务的“Fence2Area”接口，输入围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，输出的则是多边形的面积(area).</p><p>一次正常的请求示例url, 这个大家都不陌生（我用docker_ip代替真实的ip）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>请求发出后，服务器进行处理，之后，客户端收到返回的数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;data&quot;: &#123;        &quot;area&quot;: 48764135597.842606    &#125;,    &quot;errstr&quot;: &quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p><code>area</code>字段表示面积， <code>errstr</code>表示出错信息，空说明没有出错。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>在真正发送请求之前，需要进行抓包前的设置。在本地mac，我用wireshark; 而在远程docker上，我用tcpdump工具。</p><h3 id="mac本地"><a href="#mac本地" class="headerlink" title="mac本地"></a>mac本地</h3><p>设置wireshark包过滤器，监控本地主机和远程docker之间的通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr eq docker_ip</span><br></pre></td></tr></table></figure><p>点击开始捕获。</p><h3 id="远程docker"><a href="#远程docker" class="headerlink" title="远程docker"></a>远程docker</h3><p>该服务通过7080端口对外提供，使用如下命令捕获网络包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w /tmp/testHttp.cap port 7080 -s0</span><br></pre></td></tr></table></figure><h2 id="请求-amp-amp-分析"><a href="#请求-amp-amp-分析" class="headerlink" title="请求 &amp;&amp; 分析"></a>请求 &amp;&amp; 分析</h2><p>准备工作做完，我选了一个神圣的时刻，在本地通过浏览器访问如下url:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。</p><h3 id="关闭服务进程"><a href="#关闭服务进程" class="headerlink" title="关闭服务进程"></a>关闭服务进程</h3><p>正式请求之前，我们先看一下几种特殊的情形。</p><p>首先，关闭gcs服务进程，请求直接返回RST报文。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1ib1lViaLiaASe6wCNRxwB8Xu769ic09sS7T7GbjkibZ1PUiae36SP7D4ntg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>如上图，我在请求的时候，访问服务端的另一个端口 <code>5010</code>, 这个端口没有服务监听，和关闭gcs服务进程是同样的效果。可以看到，客户端发送SYN报文，但直接被远程docker RST掉了。因为服务端操作系统找不到监听此端口的进程。</p><h3 id="关闭docker"><a href="#关闭docker" class="headerlink" title="关闭docker"></a>关闭docker</h3><p>关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbJoZcwl0vLPpwOqVb8B6XiaveJosgAibblK0IXaicGVEPXC1poXhQEohw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。</p><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><p>先进行一次正常的访问，随后重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，访问到服务端后，因为它已经重启了，所以服务端已经没有这个连接的消息了。因此会返回一个RST报文。</p><h3 id="正常请求"><a href="#正常请求" class="headerlink" title="正常请求"></a>正常请求</h3><p>服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckxkrMtp9vRhDDluuIBFDcK8tyfSNq6Mibu1bFL83korLAUfUyxT8qKg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为 <code>HTTP</code>层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在 <code>HTTP</code>层发送的响应数据，第七个包为mac对第六个包的确认报文。</p><p>重点来关注后面几个包，先看第四个包，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0295 0000 4000 3606 623b ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d0x0020:  8018 1015 0ee7 0000 0101 080a 2e4c b2ef0x0030:  0f20 3acf 4745 5420 2f64 6174 613f 636d0x0040:  643d 4665 6e63 6532 4172 6561 266d 65740x0050:  613d 7b25 3232 6361 6c6c 6572 2532 323a0x0060:  2532 3274 6573 7425 3232 2c25 3232 54720x0070:  6163 6549 6425 3232 3a25 3232 7465 73740x0080:  2532 327d 2672 6571 7565 7374 3d7b 25320x0090:  3266 656e 6365 2532 323a 5b7b 2532 326c0x00a0:  6e67 2532 323a 3130 2e32 2c25 3232 6c610x00b0:  7425 3232 3a31 302e 327d 2c25 3230 7b250x00c0:  3232 6c6e 6725 3232 3a31 302e 322c 25320x00d0:  326c 6174 2532 323a 382e 327d 2c25 32300x00e0:  7b25 3232 6c6e 6725 3232 3a38 2e32 2c250x00f0:  3232 6c61 7425 3232 3a38 2e32 7d2c 25320x0100:  307b 2532 326c 6e67 2532 323a 382e 322c0x0110:  2532 326c 6174 2532 323a 3130 2e32 7d5d0x0120:  2c25 3232 636f 6f72 6474 7970 6525 32320x0130:  3a32 7d20 4854 5450 2f31 2e31 0d0a 486f0x0140:  7374 3a20 3130 2e39 362e 3932 2e32 31320x0150:  3a37 3038 300d 0a55 7067 7261 6465 2d490x0160:  6e73 6563 7572 652d 5265 7175 6573 74730x0170:  3a20 310d 0a41 6363 6570 743a 2074 65780x0180:  742f 6874 6d6c 2c61 7070 6c69 6361 74690x0190:  6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 70700x01a0:  6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d300x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 55730x01c0:  6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c0x01d0:  612f 352e 3020 284d 6163 696e 746f 73680x01e0:  3b20 496e 7465 6c20 4d61 6320 4f53 20580x01f0:  2031 305f 3133 5f36 2920 4170 706c 65570x0200:  6562 4b69 742f 3630 352e 312e 3135 20280x0210:  4b48 544d 4c2c 206c 696b 6520 4765 636b0x0220:  6f29 2056 6572 7369 6f6e 2f31 322e 302e0x0230:  3220 5361 6661 7269 2f36 3035 2e31 2e310x0240:  350d 0a41 6363 6570 742d 4c61 6e67 75610x0250:  6765 3a20 7a68 2d63 6e0d 0a41 6363 65700x0260:  742d 456e 636f 6469 6e67 3a20 677a 69700x0270:  2c20 6465 666c 6174 650d 0a43 6f6e 6e650x0280:  6374 696f 6e3a 206b 6565 702d 616c 69760x0290:  650d 0a0d 0a</span><br></pre></td></tr></table></figure><p>我们来逐字节分析。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cESQM7mPYK50BUdqRtB4qISMY5VjrFYEL4fEVDMgMquTHMqhekaY2AA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTZn8gROeqs1ncqfs0lrbUic92cGeHU3xrZr76pslib22mnVPmXjz3DOA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure><p>可以得到ascii码，我们直接看十六进制的结果：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c0dZYr61gHv0qYGlBIVEM3zr6RIxqxW2s7ia5lRnAkgLzQVCfeovialmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cPt3Eicksdp2tfV1hJJcRPLib1SFEGno5wwa9rtDaQJOomYhp9focEribQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>把上表的最后一列连起来，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125; HTTP/1.1 Host: 10.96.92.212:7080 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15 Accept-Language: zh-cn Accept-Encoding: gzip, deflate Connection: keep-alive</span><br></pre></td></tr></table></figure><p>其中，cr nl表示回车，换行。</p><p>docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。另外，序列号为2778351310.</p><p>再来看第5个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 d28b 4000 4006 8810 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8010 00ec e04e 0000 0101 080a 0f20 3af70x0030:  2e4c b2ef</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cAZEWxWx96R82g4YMAKmw1BAibT6xxBcL1kjJf3fGaUqDFLGNLjleFsA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbI0RpST1AwXnJm99vUPedSEW5vsjxhIMfpnnVPqUMMfpib6ibkkWEcTQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnkkiao15MgfVBSI2lAicn9OKJwwmppIic9fxfpJkH5nHOyaoKGtnP8iakQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>数据部分为空，这个包仅为确认包。</p><p>再来看第六个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 00f9 d28c 4000 4006 874a 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8018 00ec e113 0000 0101 080a 0f20 3af80x0030:  2e4c b2ef 4854 5450 2f31 2e31 2032 30300x0040:  204f 4b0d 0a41 6363 6573 732d 436f 6e740x0050:  726f 6c2d 416c 6c6f 772d 4f72 6967 696e0x0060:  3a20 2a0d 0a44 6174 653a 2054 6875 2c200x0070:  3033 204a 616e 2032 3031 3920 3132 3a320x0080:  333a 3437 2047 4d54 0d0a 436f 6e74 656e0x0090:  742d 4c65 6e67 7468 3a20 3438 0d0a 436f0x00a0:  6e74 656e 742d 5479 7065 3a20 7465 78740x00b0:  2f70 6c61 696e 3b20 6368 6172 7365 743d0x00c0:  7574 662d 380d 0a0d 0a7b 2264 6174 61220x00d0:  3a7b 2261 7265 6122 3a34 3837 3634 31330x00e0:  3535 3937 2e38 3432 3630 367d 2c22 65720x00f0:  7273 7472 223a 2222 7d</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c4iaw0WsWa7KbicwicrJbrVm82c1z3OOQuCBG8MnezL90gSGbEWv5p1wLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0chROjPEbF98pwdNNGm56BqMY5TJhQ4UCMZQibicgkxxJum4EkLSoDKyHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩下来的就是数据部分了。我们一行一行地看。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cf9reib3oq2gOJVfkdHdEafO0t7ZibzwACqJl9F1BVonYzlXOib1orDpiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>把上表的最后一列连起来，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK Access-Control-Allow-Origin: * Date: Thu, 03 Jan 2019 12:23:47 GMT Content-Length: 48 Content-Type: text/plain; charset=utf-8 &#123;&quot;data&quot;:&#123;&quot;area&quot;:48764135597.842606&#125;,&quot;errstr&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p>Content-Length: 48，最后一行的长度即为48个字节。</p><p>最后，第七个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 0000 4000 3606 649c ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e9420x0020:  8010 100f 1eb9 0000 0101 080a 2e4c b3140x0030:  0f20 3af8</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0czCoePYTJlUT7ry6wUOC5sib1phKyp1odVXVHxGwmCVjZAxHfnQ6ugrA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cQcJTJtCqC5uUlc8fH3gCIvcR8FV3ayZu6LIBXVR32aUJGHDLK2Al8g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>至此，一次完整的http请求的报文就解析完了。感觉如何，是不是很亲切？</p><h1 id="HTTP协议分析"><a href="#HTTP协议分析" class="headerlink" title="HTTP协议分析"></a>HTTP协议分析</h1><p>上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步带你深入理解HTTP协议。</p><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><p><code>HTTP</code>(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。说得更形象一点： <code>HTTP</code>是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。</p><p>HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cd3E2bpHQ1JibJo1Cks0PtU75BD8UsUZQMIuutqGxuxDXqIbJicibk0NiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>HTTP在传输一段报文时，会以 <code>流</code>的形式将报文数据的内容通过 <code>一条打开</code>的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cvS3b6LIgaPLTfa4gdcLHKRMQV8A4mZF0Gux7vhwiapGLyB2tYFrrFew/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们再来回顾一下：</p><p>原始的url值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>编码后的url值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125;</span><br></pre></td></tr></table></figure><p>在之前的报文拆解过程中，我们看到多了很多 <code>%22</code>，其实， <code>0x22</code>是单引号 <code>&quot;</code>的ascii值，</p><p>一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，比如空格；最后，URL还得是完整的，它需要支持所有语言的字符。</p><p>总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。</p><p>转义的方法：百分号( <code>%</code>)后跟着两个表示ASCII码的十六进制数。比如：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ca1ibSClFurjoccZUHYENZbYZrf2opPyvfdM8Ll5770Uic6YaVsZXbLVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。</p><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p>响应数据中，我们注意到有一个首部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/plain; charset=utf-8</span><br></pre></td></tr></table></figure><p>互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的 <code>Content-Type</code>. MIME本来是用在邮件协议中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，是该展示图片，还是调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表展示了一些常见的类型，其中的实体主体是指body部分：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cibw7k636Y9k3xns3JuiapnxqgZzmqxXanpLUUk8VSYiclBGy1Gx4dgiawA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>URI/URL/URN</p><p>URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator, 统一资源定位符)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。</p><p>URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！</p><p>URL通常的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议方案+服务器地址+具体的资源路径</span><br></pre></td></tr></table></figure><p>协议方案(scheme)，如 <code>http</code>, <code>ftp</code>，告知web客户端怎样访问资源)；服务器地址，如 <code>www.oreilly.com</code>; 具体的资源路径，如 <code>index.html</code>.</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。这样，客户端可以获取即将请求资源的一些情况，可以做到心中有数。</p><p>POST用于向服务器发送数据，常见的是提交表单；PUT用于向服务器上的资源存储数据。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 OK 404 Not Found500 Internal Server Error</span><br></pre></td></tr></table></figure><p>我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是 <code>404NotFound</code>会穿透重重迷雾，来到我们面前，为何？那是因为他对我们爱的深沉啊！</p><p>客户端可以据此状态码，决定下一步的行动（如重定向等）。</p><p>三位数字的第一位表示分类：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cWscDzeA52lJGamzgqvAYianNebt2zoaHENFaJqrcOqjDTrTxgia5SGmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>HTTP报文实际上是由一行行的字符串组成的，每行字符串的末尾用 <code>\r\n</code>分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说 <code>0x0001</code>表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。不可能像HTTP协议这样，直接将字符编码，人类可以直接读懂。</p><p>举个简单的请求报文和响应报文的格式的例子：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cq5mHY7JwsGkIib9iazsoJk53tRRoc03B4GNgtLhpUjrsciaS0LGwW8nzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>实际上，请求报文也是可以有body（主体）部分的。请求报文是由 <code>请求行（request line）、请求头部（header）、空行、请求数据</code>四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的 <code>回车换行</code>符也是必须要有的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cozZdAPcASb3UUqYcqiaQuUvWgugEuaMu6Y3aiaxEia0ENTzVqvX8c9hgg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>响应报文的格式和请求报文的格式类似：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。</p><p>有些首部是通用的，有些则是请求或者响应报文才会有的。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后就可以通过这个通道直接发送HTTP请求数据，获取响应数据了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cFxrl1hgDlibWeYcEAMjgowiaZYLyf6FnsEuFr96UWxwicxDLLY44xPcuQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id="HTTP协议进阶"><a href="#HTTP协议进阶" class="headerlink" title="HTTP协议进阶"></a>HTTP协议进阶</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>HTTP的代理服务器既是Web服务器，又是Web客户端。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c98UALAtAUnx5oBJIOic3d9496dZl4NiaZQ9ZvQKxQq1VzzibvE4sr97xA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为 <code>反向代理</code>；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为 <code>内容转码器</code>; <code>匿名代理</code>会主动从HTTP报文中删除身份相关的信息，如 <code>User-Agent</code>, <code>Cookie</code>等字段。</p><p>现实中，请求通过以下几种方式打到代理服务器上去：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTVYicUUUFVOFN7jMXViaKEPaYicSLxlIEBYIribWicpuChGwah8gvtFImUQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。注意图中的via字段。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1PTaibUPaCtlroPcyicwRJoQUbWTqlVAGicicg359QyvdZsQmr3H0FjK4A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。</p><p>大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是 <code>If-Modified-Since</code>, 如果在xx时间(此时间即为If-Modified-Since的值)之后内容没有变化，服务器会回应一个 <code>304NotModified</code>. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为 <code>再验证命中</code>。</p><p>再验证可能出现命中或未命中的情况。未命中时，服务器回复 <code>200OK</code>，并且返回完整的数据；命中时，服务器回复 <code>304NotModified</code>; 还有一种情况，缓存被删除了，那么根据响应状态码，缓存服务器也会删除自己缓存的副本。</p><p>顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。</p><p>缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，再对一些首部字段做一些微调。比如向其中插入新鲜度信息（如 <code>Age</code>, <code>Expires</code>首部等），而且通常会包含一个 <code>via</code>首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改 <code>Date</code>字段，它表示原始服务器最初构建这条响应的日期。</p><p>HTTP通过 <code>文档过期机制</code>和 <code>服务器再验证机制</code>保持已缓存数据和服务器间的数据充分一致。</p><p>文档过期通过如下首部字段来表示缓存的有效期：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。如上表中提到的 <code>Expires</code>字段等。</p><p>为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个 <code>条件GET</code>请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。 <code>条件GET</code>请求会用到如下的字段：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cLIw08X75umvOGDoeZDlYcb74GDpKdsOAzRMnYt5p8KeptjE5ejaw6Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。</p><p>有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。</p><p>服务器在给客户端的响应字段首部加上 <code>Set-cookie</code>或 <code>Set-cookie2</code>, 值为 <code>名字=值</code>的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过 <code>Cookie</code>带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。</p><p>浏览器只会向产生这条cookie的站点发生cookie. <code>Set-cookie</code>字段的值会包含 <code>domain</code>这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。 <code>path</code>字段也是相似的功能。如i浏览器收到如下的cookie:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: user=&quot;mary&quot;; domain=&quot;stefno.com&quot;</span><br></pre></td></tr></table></figure><p>那么浏览器在访问任意以 <code>stefno.com</code>结尾的站点都会发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot;mary&quot;</span><br></pre></td></tr></table></figure><h2 id="实体和编码"><a href="#实体和编码" class="headerlink" title="实体和编码"></a>实体和编码</h2><p>响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果 <code>Content-Type</code>定义是 <code>text/plain</code>, 那说明body内容就是文本，我们直接按文本编码来解释；如果 <code>Content-Type</code>定义是 <code>image/png</code>, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。</p><p><code>Content-Length</code>标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外， <code>Content-Length</code>在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上 <code>Content-Length</code>字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的 <code>Content-Length</code>首部。</p><p>HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。</p><p>HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到 <code>Content-MD5</code>这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改 <code>Content-MD5</code>首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与 <code>Content-MD5</code>首部进行比较。这主要是防止代理对报文进行了无意的改动。</p><p>HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c3QiaTbXgX0sJtJicDibxDtN6wlniaHbgLSCwNiba2dXX12Z9jL5v12Gjshw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在 <code>Accept-Encoding</code>首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。</p><p>上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码： <code>传输编码</code>。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。</p><p>通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到 <code>Content-Length</code>中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到 <code>传输编码</code>来标注数据的结束的。</p><p>HTTP协议中通过如下两个首部来描述和控制传输编码：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>分块编码的报文形式是这样的：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckXIxrtbOKfscDcACkqLe3oOFeUOS25BxE4xBZ3zC0cvCibLMb3OicS2Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>每个分块包含一个长度值（十六进制，字节数）和该分块的数据。 <code>&lt;CR&gt;&lt;LF&gt;</code>用于区隔长度值和数据。长度值不包含分块中的任何 <code>&lt;CR&gt;&lt;LF&gt;</code>序列。最后一个分块，用长度值0来表示结束。注意报文首部包含一个 <code>Trailer:Content-MD5</code>, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如， <code>Content-Length</code>, <code>Trailer</code>, <code>Transfer-Encoding</code>也可以作为拖挂。</p><p>内容编码和传输编码是可以结合起来使用的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqvJ6263Sa8Ay3zGoGFqml8SWpzWtHL631ZTVqpRauJzoaNDltGeHibg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="国际化支持"><a href="#国际化支持" class="headerlink" title="国际化支持"></a>国际化支持</h2><p>HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，以及浏览器上安装了何种字母表编码算法。这通过 <code>Accept-Charset</code>和 <code>Accept-Language</code>首部实现。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: fr, en;q=0.8Accept-Charset: iso-8859-1, utf-8</span><br></pre></td></tr></table></figure><p>表示：客户端接受法语(fr, 优先级默认为1.0）、英语（en, 优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在 <code>Content-Type</code>首部里放上 <code>charset</code>.</p><p>本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码去字符集中找到对应的元素。</p><p>比较常见的字符集是 <code>US-ASCII</code>: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。可以再看下上文报文分析部分的acsii码集。</p><p><code>US-ASCII</code>是把每个字符编码成固定的7位二进制值。 <code>UTF-8</code>则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值，前两个bit位是用 <code>10</code>标识。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cJHSxBWJroo9TNWxXdoY9KiaPiaUYHLHaf77bqicIoQvYDKKDYPwtKqLIw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>举个例子，汉字“严”的Unicode编码为 <code>4E25</code>( <code>100111000100101</code>), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将 <code>100111000100101</code>填入上表中的 <code>c</code>位即可。因此，严的 <code>UTF-8</code>编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com.hk/search?q=%E4%B8%A5&amp;oq=%E4%B8%A5&amp;aqs=chrome..69i57j0l5.3802j0j4&amp;sourceid=chrome&amp;ie=UTF-8&amp;gws_rd=cr</span><br></pre></td></tr></table></figure><p><code>q=%E4%B8%A5</code>这个就是搜索的词了。</p><h2 id="重定向与负载均衡"><a href="#重定向与负载均衡" class="headerlink" title="重定向与负载均衡"></a>重定向与负载均衡</h2><p>Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。一般都会有所谓的“双活”，“多活”，所谓 <code>狡兔三窟</code>嘛。</p><p>这样，用户的请求会根据 <code>负载均衡</code>的原则，被 <code>重定向</code>到它应该去的地方。</p><h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>服务器收到客户端请求后，向客户端返回一条带有状态码 <code>302</code>重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用， <code>重定向</code>服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。</p><p>当然，缺点也是显而易见的，由于客户端要发送两次请求，因此会增加耗时。</p><h3 id="DNS重定向"><a href="#DNS重定向" class="headerlink" title="DNS重定向"></a>DNS重定向</h3><p>DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的 <code>轮转</code>；也可以是更高级的算法，如返回负载最轻的服务器的IP地址，称为 <code>负载均衡算法</code>；如果考虑地理位置，返回给客户端最近位置的地址，称为 <code>邻接路由算法</code>；还有一种是绕过出现故障的地址，称为 <code>故障屏蔽算法</code>。</p><p>DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。</p><h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>HTTP连接是HTTP报文传输的关键通道。</p><h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，速度会快起来。</p><p>如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqsP47SichhaMHESR59XzoJ1V635S2pk6AMQXMaBT4tqIDBIH3fhiccDA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>采用并行连接之后：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cyPg8tia0Y7V1b7CumlkvGcuicicNBEFZeatkJKbkf7gTWrfiaibKLcRMU5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。</p><p>另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP keep-alive机制</p><p>我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。</p><p>HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。</p><p>HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnp6MPI6YLshmc8PgDUv1jq8LUcbwBOiczicxiaMTqNOticYL70ONWSCnXQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>HTTP有keep-alive机制，目的是可以在一个TCP 连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcpsetkeepalive，来激活连接的keep-alive属性。</p><p>当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过 <code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcpkeepaliveprobes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试 <code>tcp_keepalive_probes</code>次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><h3 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h3><p>在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求按序放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。而且就算是服务端按序处理的，也不一定是按序返回给客户端，所以最好是在响应中附带一些可以标识请求的参数。</p><p>为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上，就是所有HTTP的通信细节了，足够在日常开发 作中使用了。更多没有涉及的细节可以在用到的时候再去仔细研究。</p><p>文章看完了，不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。</p><blockquote><p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p><p>如有冒犯，联系删除</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“三次握手，四次挥手”你真的懂吗？</title>
      <link href="/2019/03/28/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
      <url>/2019/03/28/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！</p><p>作为程序员，要有“刨根问底”的精神。知其然，更要知其所以然。这篇文章希望能抽丝剥茧，还原背后的原理。</p><h1 id="什么是“3次握手，4次挥手”"><a href="#什么是“3次握手，4次挥手”" class="headerlink" title="什么是“3次握手，4次挥手”"></a><strong>什么是“3次握手，4次挥手”</strong></h1><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h2 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a><strong>TCP服务模型</strong></h2><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a><strong>TCP头部</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF9sL0PPjOs0LotFFbWklFVlMPuGIp1ltEkbK0hIibHtzZsZRvn9Liaz4Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。<br>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。<br>SYN —— 用于初如化一个连接的序列号。<br>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a><strong>状态转换</strong></h2><p>三次握手和四次挥手的状态转换如下图。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFian001KXuKUicvYT7Pozrf2g50NrMtS2mPRuNYIWdgsSmplf8ic1KuV6g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id><a href="#" class="headerlink" title=" "></a> </h1><h1 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a><strong>为什么要“三次握手，四次挥手”</strong></h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。</p><p>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。</p><p>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th>视角</th><th>客收</th><th>客发</th><th>服收</th><th>服发</th></tr></thead><tbody><tr><td>客视角</td><td>二</td><td>一 + 二</td><td>一 + 二</td><td>二</td></tr><tr><td>服视角</td><td>二 + 三</td><td>一</td><td>一</td><td>二 + 三</td></tr></tbody></table><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><h1 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a><strong>“三次握手，四次挥手”怎么完成？</strong></h1><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFYpRyHjvicckYBlR5ShkUOy9kXicV904eC9yjU8j0JvAowEWGW4KIT1kA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h2 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmo1F4q8mQmxymUCGFAiaIu26E7mw2mj8cYu1qicdE4PVOsVtFJFrJMrw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong></h2><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h1 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a><strong>“三次握手，四次挥手”进阶</strong></h1><h2 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a><strong>ISN</strong></h2><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><blockquote><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p></blockquote><p>M是一个计时器，每隔4毫秒加1。</p><p>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><p><strong>序列号回绕</strong></p><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><blockquote><p>*/**</p><p>*<em> The next routines deal with comparing 32 bit unsigned ints</em></p><p>*<em> and worry about wraparound (automatic with unsigned arithmetic).</em></p><p>*<em>/</em></p><p>static inline <strong>int</strong> before(<strong>u32 seq1, </strong>u32 seq2)</p><p>{</p><p>​    <strong>return</strong> (__s32)(seq1-seq2) &lt; 0;</p><p>}</p><p>#define after(seq2, seq1) before(seq1, seq2)</p></blockquote><p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><blockquote><p>假设seq1=255， seq2=1（发生了回绕）。</p><p>seq1 = 1111 1111 seq2 = 0000 0001</p><p>我们希望比较结果是</p><p>seq1 - seq2=</p><p>1111 1111</p><p>-0000 0001</p><p>-———-</p><p>1111 1110</p><p>由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为</p><p>0000 0001 + 1 = 0000 0010 = 2</p><p>因此seq1 - seq2 &lt; 0</p></blockquote><h2 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a><strong>syn flood攻击</strong></h2><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h3 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h3><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h3 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h3><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h4 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h4 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h3 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h3><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h2 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a><strong>连接队列</strong></h2><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmakH75iacmvjKuByYibR6kVbsichiaV2aEYYhTicKdPJXAlJTMCmMCibUmKw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><blockquote><p>查看是否有连接溢出</p><p>netstat -s | grep LISTEN</p></blockquote><h3 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a><strong>半连接队列满了</strong></h3><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFNI7SPfVDd7oQRIrGy3ribyxr8S6W46SJ58ZT5BAeibiahonct8nbIQcsQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>全连接队列满了</strong></p><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>命令</strong></p><p>netstat -s命令</p><blockquote><p>[root@server ~]#  netstat -s | egrep “listen|LISTEN”</p><p>667399 times the listen queue of a socket overflowed</p><p>667399 SYNs <strong>to</strong> LISTEN sockets ignored</p></blockquote><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><blockquote><p>[root@server ~]#  netstat -s | grep TCPBacklogDrop</p></blockquote><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><blockquote><p>[root@server ~]#  ss -lnt</p><p>State Recv-Q Send-Q Local Address:Port Peer Address:Port</p><p>LISTEN     0      128 <em>:6379 </em>:*</p><p>LISTEN     0      128 <em>:22 </em>:*</p></blockquote><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。</p><p>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h1 id="“三次握手，四次挥手”redis实例分析"><a href="#“三次握手，四次挥手”redis实例分析" class="headerlink" title="“三次握手，四次挥手”redis实例分析"></a><strong>“三次握手，四次挥手”redis实例分析</strong></h1><ol><li>我在dev机器上部署redis服务，端口号为6379,</li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><blockquote><p>tcpdump -w /tmp/a.cap port 6379 -s0</p><p>-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S0则会抓到完整数据包</p></blockquote><ol><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><blockquote><p>tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</p><p>（-x 以16进制形式展示，便于后面分析）</p></blockquote><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFuia4XyKt3j44V4px2Fic7zjGvfOLTyohocqo1YhWamm3OdibRchUZaADg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>它由固定长度20B+可变长度构成。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF1ock0p3DyjYPgkVc3icNcTmSQYwEmKJFPuibnGjxItx5IXnK9uOjc6jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>对着IP头部格式，来拆解数据包的具体含义。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFLUSiaJdMOtSxZMAPSUH2J0cMLFqiaVzA83WrqWBhXWCIfjCeOnu54cUg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFFiaC1F0oOwQX4mDye7HnszaFEdNO3vJRrZMw07dmywApRckbhK3jxJg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>这样第一个包分析完了。dev2向dev发送SYN请求。也就是三次握手中的第一次了。</p><p>SYN seq(c)=4133153791</p><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.</p><p>SYN ack=seq(c)+1 seq(s)=4264776963</p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.</p><p>ack=seq(s)+1, seq=seq(c)+1</p><p>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFiaYrAMKnowJDk3ntjD7GeyOX5myHgZ0wBRciaMOFonkwNZJXRSJjlOicQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792</p><p>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><blockquote><p>0x2a31         -&gt; *1</p><p>0x0d0a         -&gt; \r\n</p><p>0x2434         -&gt; $4</p><p>0x0d0a         -&gt; \r\n</p><p>0x7069 0x6e67  -&gt; ping</p><p>0x0d0a         -&gt; \r\n</p></blockquote><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。</p><p>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.</p><p>数据部分2b50 4f4e 470d 0a, 翻译过来就是+PONG\r\n.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><p><strong>总结</strong></p><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><p>所以，“三次握手，四次挥手”你真的懂了吗？</p><blockquote><p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p><p>如有冒犯，联系删除</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是HTTPS协议</title>
      <link href="/2019/03/27/%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/03/27/%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者 | 小   灰</p><p>责编 | 胡巍巍</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QibiajkGYjaNxI6pTvG3ehic6EktzRvZ4GD9PPsKuwaQLH4jVFbf92Kfdg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QnIBhBKXbcKDoX44n2YMvdqdHicJQNpyWReyib2PnhMTxSicSDumbWKRpw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QVq4x8hoGTrGwe7dfBCkhwgV9gD81KGQBsl9yPa7ic0uQIibcGxicsAxLw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmRdRTQTIs9muXtgY77wialvjWV8StsrkOa4hxqjrkia8ngZ2UKwTLkiaQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QiaicqJked2A0l9hYpwJVGtGhlV2KwGPUMqt1O1m6jr7FlRfbfC8ib95Jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Q6pFlukc21dcoEdfEJvRoyBYA5WJmQW32drgyv0Uw02icmsrKgY5TuOw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSPn6JHA3Zyickib2fUa1dUwEfpjrcmZnYDXtrD207nibjkHEjVWiaPSwGQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSln0sXSXHqrz7U1P5PQ05HwkBv5hPicWib2ic7qQpfVkhFiaqIf1559JaA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QImf2zKCHx6OTJZnV2pYARgwUMF53UicibRdgCJNrAowibo3X0cMPeJXFw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>什么是HTTP协议？</strong></p><p>HTTP协议全称Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于TCP/IP四层模型当中的应用层。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>HTTP协议通过请求/响应的方式，在客户端和服务端之间进行通信。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这一切看起来很美好，但是HTTP协议有一个致命的缺点：不够安全。</p><p>HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢？让我们打一个比方：</p><p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做中间人攻击。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>如何进行加密呢？</strong></p><p>小灰和小红可以事先约定一种对称加密方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这样做是不是就绝对安全了呢？并不是。</p><p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这可怎么办呢？别担心，我们可以使用非对称加密，为密钥的传输做一层额外的保护。</p><p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p><p>在小灰和小红建立通信的时候，小红首先把自己的公钥Key1发给小灰：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥Key2，并且用刚才接收的公钥Key1对Key2进行加密（这里有点绕），发送给小红：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>小红利用自己非对称加密的私钥，解开了公钥Key1的加密，获得了Key2的内容。从此以后，两人就可以利用Key2进行对称加密的通信了。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>是什么坏主意呢？中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。</p><p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>是什么解决方案呢？难道再把公钥进行一次加密吗？这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p><p>这时候，我们有必要引入第三方，一个权威的证书颁发机构（CA）来解决。到底什么是证书呢？证书包含如下信息：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p><p>流程如下：</p><p>1.作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmrhYBUv6aQ6RPpbEEWV4jnWURYvnB7QKKkCeLzwMZeicp8lytYms0yg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>3.当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QjQldYuHCKOcibkUMf7nhX0DD4EasCGcQS0os6suCO7fSxia7FjOYiaOzA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>4.小灰收到证书以后，要做的第一件事情是验证证书的真伪。</p><p>需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。</p><p>所以小灰只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p><p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p><p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥Key1。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QENwxMWjnWv6iaCM0JjG1faFyrEmPC6c1n2tZDIGo3icONyV91INJicAJA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>5.像之前一样，小灰生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给小红。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QKLTGwWJXwaHibic78VTbibpEIO5UBGCj1D0cVSFp1W32MKLQRGiaibYcTHg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>6.最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是两人开始用Key2进行对称加密的通信。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QxwRCiac136C5VLuNyVjFDG3teRNtwh1GmPvolrtpRcLxc8XeM2ibibyeQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢？</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QXVOiaHUuKTsf5Iqy360ukSZoM3jwPa9KiaMbmiakquh2MvF1Eg52wAbCQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QwOLtEPPhJToUf4EaQ6XvtNoJsoc9ibUWBYXJ8VPIl4Xo7ppnuc4icsxA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qy676yjvxP11icXgFDZER6iahoXLggnt84XUlg2nDSRgJdsbWNuRENBfg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qc73BXAGJgwvq8HwbU4IzorxmNNUujleX4buaugp3a2X1hUt3cLNSYA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QOThp6PEtNpia48W7vLtb5viauwJZW2rxfIRVOoNAT4UMXJa2Mo2QkNDQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QFibuV1f5f5lCG2ryskiaickbbW88icxFjibZKv7uQglyWcVicgVnicN96R0wQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QplvDw2aicOOm3R55rqB8mzO8Gia2l54JIInWnUFhTylD3C9mevf7DqYg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>注：最新推出的TLS协议，是SSL 3.0协议的升级版，和SSL协议的大体原理是相同的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QDg1EJYjK2vZfPbrZfHNy3gibl4vqJGIFsgqD3OK2iaLqFNq3IlTrkH3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>声明：本文为作者投稿，首发于个人公众号程序员小灰，版权归其所有。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arcpy开发&amp;关于arcgis中的api arcpy.Describe</title>
      <link href="/2019/03/18/arcpy%E5%BC%80%E5%8F%91&amp;%E5%85%B3%E4%BA%8Earcgis%E4%B8%AD%E7%9A%84api%20arcpy.Describe/"/>
      <url>/2019/03/18/arcpy%E5%BC%80%E5%8F%91&amp;%E5%85%B3%E4%BA%8Earcgis%E4%B8%AD%E7%9A%84api%20arcpy.Describe/</url>
      
        <content type="html"><![CDATA[<p>今天在学习关于工作空间相关知识，用于了下面的函数来实现判断当前输入的要素参数在哪个工作空间。其中主要运用到了arcpy.Describe函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_workspace</span><span class="params">(featureClass)</span>:</span></span><br><span class="line"> catalogPath = os.path.dirname(featureClass.catalogPath)</span><br><span class="line">    <span class="keyword">if</span> arcpy.Describe(catalogPath).dataType == <span class="string">'FeatureDataset'</span>:</span><br><span class="line">        arcpy.env.workspace = arcpy.Describe(catalogPath).path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        arcpy.env.workspace = featureClass.path</span><br><span class="line">    <span class="keyword">return</span> arcpy.env.workspace</span><br></pre></td></tr></table></figure><p>研究罢了，调试时查阅了Describe相关的参数，于是来看一下esri官方的参考文档，如下所说关于describe的种种：</p><p>Describe 函数返回的 Describe 对象包含多个属性，如数据类型、字段、索引以及许多其他属性。该对象的属性是动态的，这意味着根据所描述的数据类型，会有不同的描述属性可供使用。</p><p>Describe 属性被组织成一系列属性组。任何特定数据集都将至少获取其中一个组的属性。例如，如果要描述一个地理数据库要素类，您可访问 GDB 要素类、要素类、表和数据集属性组中的属性。所有数据，不管是哪种数据类型，总会获取通用 Describe 对象属性。</p><p>好了，说了这么多。我其实想说的是，可以使用describe查看数据的相关信息。比如shapeType、dataType、catalogPath、spatialReference等等相关信息。我们来看一下下面这一段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input_fc = <span class="string">'D:/Data/中国国界和省界的SHP格式数据/省界/bou2_4p.shp'</span></span><br><span class="line">desc = arcpy.Describe(input_fc)</span><br><span class="line">catalogPath = os.path.dirname(desc.catalogPath)</span><br><span class="line">dataType=arcpy.Describe(catalogPath).dataType</span><br><span class="line">dataType2=desc.dataType</span><br></pre></td></tr></table></figure><p>现在我们把pycharm断点打开，一一窥探该函数会给我们带来什么样的信息。具体如下图所示。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1552917456413.png" alt="1552917456413"></p><p>好了，关于describe的学习就到处为此了。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIS; arcpy; python; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myFirstBlog</title>
      <link href="/2019/03/13/myFirstBlog/"/>
      <url>/2019/03/13/myFirstBlog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一则列表去重的思考</title>
      <link href="/2018/09/05/%E4%B8%80%E5%88%99%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/09/05/%E4%B8%80%E5%88%99%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<pre><code>今天偶得休息,闲来无事悄悄代码,收到了一个这样的问题:</code></pre><p>用两种或更多的方法实现对列表list1 = [1,1,2,3,3,5]进行去重。<br>时间紧任务急,博主现只写出了如下四种实现方式供大家参考,后续想到<br>更好的算法了再给大家分享,话不多说上代码,:</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>list1 = [1,1,2,3,3,5]</p><p>set1 = list(set(list1))</p><p>print(set1)</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>list2 = []</p><p>for i in range(len(list1)):<br>    if list1.index(list1[i]) == i:<br>        list2.append(list1[i])</p><p>print(list2)</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>list3 = [1,1,2,3,3,5]<br>for i in list3:<br>    if list3.count(i) 1:<br>        list3.pop(list3.index(i))</p><p>print(list3)</p><h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>list4 = []</p><p>for i in list1:<br>    if i not in list4:<br>        list4.append(i)</p><p>print(list4)</p><p>乍一看不觉这题难,对于接触过python的朋友来说,随手写出一两个不成问题,<br>但通过此事也意识到了,前面学过的知识还是要勤加复习避免遗忘,不说了博主要去复习了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 命令操作总结</title>
      <link href="/2018/08/17/git%20%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/17/git%20%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><ul><li><p>sudo apt-get intall git</p><blockquote><p>终端输入git 如果有提示证明安装成功</p></blockquote></li></ul><h3 id="2-git单人操作"><a href="#2-git单人操作" class="headerlink" title="2.git单人操作"></a>2.git单人操作</h3><ul><li><p>2.1 创建空的git仓库: git init</p><blockquote><p>提示: git仓库和项目的根路径在一起,用来管理项目</p></blockquote></li><li><p>2.2 配置git提交的用户名,邮箱</p><p>例如: git config user.name ‘zhangsan’</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; git config user.email <a href="mailto:&#39;111@qq.com" target="_blank" rel="noopener">&#39;111@qq.com</a>‘</p><blockquote><p>如果没有配置,默认使用的: home/.gitconfig  根目录下的用户信息</p></blockquote></li><li><p>2.3 查看文件状态: git status</p><blockquote><p>红色: 表示新建文件, 或者新修改了文件,目前位于工作区中</p><p>绿色: 表示文件在暂存区</p></blockquote></li><li><p>2.4将工作区代码, 添加到暂存区(工作区–&gt;暂存区)</p></li><li><p>例如: git add .  </p><p> &nbsp; &nbsp; &nbsp; git add xxx.py</p><blockquote><p>点表示添加所有变动,  xxx.py表示指定文件</p></blockquote></li><li><p>2.5将工作区代码,添加到仓库区(工作区—&gt;仓库区)</p></li><li><p>例如: git commit -m ‘注释’</p></li><li><p>2.6将工作区,直接添加到仓库区(工作区–&gt;暂存区—&gt;仓库区)</p></li><li><p>例如: git commit -am ‘注释信息’</p></li><li><p>2.7查看版本历史</p><p>例如: git log</p><p> &nbsp; &nbsp; &nbsp;  git reflog</p><blockquote><p>log查看详细信息, reflog查看简要信息</p></blockquote></li><li><p>2.8回退版本</p><p>例如: git reset –hard HEAD</p><p>或者: git reset –hard 版本号</p><blockquote><p>HEAD表示当前最新版本</p><p>HEAD^表示当前最新版本的,  上一个版本</p><p>HEAD^^表示当前最新版本的, 前两个版本, 依次类推</p><p>HEAD~1 表示当前最新版本的,  上一个版本</p><p>HEAD~2 表示当前最新版本的, 前两个版本, 依次类推</p></blockquote></li><li><p>2.9撤销工作区,暂存区修改</p><p>撤销工作区:  git checkout 文件名</p><p>撤销暂存区: </p><p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout HEAD 文件名 (暂存区-工作区)</p><p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout 文件名</p><blockquote><p>仓库区代码不能撤销</p></blockquote></li><li><p>2.10 版本对比</p><p>例如: git diff HEAD HEAD^ – xxx.py</p><blockquote><p>HEAD表示当前版本,   HEAD^表示上个版本, xxx.py对比的文件</p></blockquote></li><li><p>2.11误删除文件,恢复</p><p>格式1: rm 文件名</p><p>恢复1: git checkout – 文件名</p><p>格式2: git rm 文件名</p><p>恢复2: git reset –hard HEAD^</p></li></ul><h3 id="3-git多人操作"><a href="#3-git多人操作" class="headerlink" title="3.git多人操作"></a>3.git多人操作</h3><ul><li><p>3.1 clone项目到本地</p><p>例如: git clone 项目地址</p></li><li><p>3.2 推送项目到远程仓库</p><p>例如: git push</p><blockquote><p>第一次推送会提示输入账号, 密码</p></blockquote></li><li><p>3.3 配置是否输入登陆密码信息</p><blockquote><p>git config –global  credential.helper cache 十五分钟有效期</p><p>git config  credential.helper ‘cache –timeout==3600’ 一个小时有效期</p><p>git config –global credential.helper store 长期有效</p></blockquote></li><li><p>3.4 拉取远程最新代码到本地</p><p>例如: git pull</p></li></ul><h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4.标签"></a>4.标签</h3><ul><li><p>4.1 设置本地标签</p><p>例如: git tag -a  标签名 -m ‘标签描述’</p></li><li><p>4.2 推送本地标签到远程</p><p>例如: git push origin 标签名</p></li><li><p>4.3 删除本地标签</p><p>例如: git tag -d 标签名</p></li><li><p>4.4 删除远程标签</p><p>例如: git push origin –delete tag 标签名</p></li></ul><h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h3><ul><li><p>5.1查看当前分支</p><p>例如: git branch</p></li><li><p>5.2创建本地分支,并切换到指定分支</p><p>例如: git checkout -b 分支名</p></li><li><p>5.3推送本地分支,到远程</p><p>例如: git push -u origin 分支名</p></li><li><p>5.4切换分支</p><p>例如: git checkout master / dev</p><blockquote><p>切换到主分支,或者是其他分支</p><p>其他用户第一次pull代码后,切换切换后才能使用git branch查看</p></blockquote></li><li><p>5.5合并子分支到主分支</p><p>例如: git merge 分支</p><blockquote><p>需要在master分支下操作改命令</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git; 版本库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LivePreview无法正常工作</title>
      <link href="/2018/07/26/LivePreview%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/"/>
      <url>/2018/07/26/LivePreview%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>2018/7/26 22:28:25</p><p>自从搭建了个人博客,一直以来都是使用 MarkdownPad 2 来写Blog。近日由于重新安装了系统,想着把MarkdownPad 2再重新安装下,安装后却发现提示无法开启渲染预览,这能难道程序员吗?于是开始了bug查找,发现了如下提示:</p><pre><code>LivePreview is not working - it displays an error message stating This view has crashed!This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.To fix this issue, please try installing the Awesomium 1.6.6 SDK.If you continue to experience issues, please install Microsoft&apos;s DirectX End-User Runtimes.</code></pre><p>读后发现大概意思是需要下载安装Awesomium 1.6.6 SDK，OK,那就先试试 Awesomium 1.6.6 SDK.点击提示页面的下载链接地址，然后安装之后，重新启动MarkdownPad 2就可以正常使用了。</p><p>附带软件下载地址：</p><blockquote><p>MarkdownPad2破解版本地址：链接: <a href="https://pan.baidu.com/s/1dF6C1MT" target="_blank" rel="noopener">https://pan.baidu.com/s/1dF6C1MT</a> 密码: j3cy</p></blockquote><blockquote><p>awesomium软件下载地址：链接: <a href="https://pan.baidu.com/s/1nvRuNaT" target="_blank" rel="noopener">https://pan.baidu.com/s/1nvRuNaT</a> 密码: e7t2 </p></blockquote><p>很多人不太喜欢试用版,试用版功能不全,下面附带注册码激活使用:</p><p>打开markdownpad2 –&gt; 帮助 –&gt;升级为专业版<br>按照如下输入：<br>​</p><blockquote><p>邮箱地址：<a href="mailto:Soar360@live.com" target="_blank" rel="noopener">Soar360@live.com</a></p></blockquote><blockquote><p>授权秘钥：<br>    GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客出现command not found解决方案</title>
      <link href="/2018/07/26/hexo%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0command-not-found%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/07/26/hexo%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0command-not-found%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>2018/7/26 22:14:17</p><p>自从上次更新了博客后,后来就开始了正式的学习,由于电脑升级的原因考虑到今后需要用到的软件会比较多,现在用的电脑配置有点低了,所以对电脑进行了一次小升级购买了固态后重装了系统,以致于之前的博客文件和配置的环境出现了问题,导致不能正常上传博客文件,后来课程太紧,一拖再拖没有来及解决这个问题.</p><p>今天去网上看了下,发现有很多这样的问题,重装系统后会出现command not found提示,接下来就是一波百度,寻找解决办法,发现个办法都有瑕疵并不能一次完美解决.</p><p>最后决定还是使用最粗暴的办法吧,也避免出现一些环境,插件缺少的问题,于是按照我之前写的教程开始了重新配置,安装完毕之后,首先查看各种工具是否都安装好了，在命令行中输入<code>node -v</code><br>然后再检查<code>npm -v</code>,<br>这些都没有问题的话,接下来检查下环境变量有没有配置,如果发现没有配置的话,可以先去找到这个路径，<code>C:\Users\feng\node_modules\hexo\bin</code>，然后把它添加到环境变量PATH路径的后面。这样基本就配置完成了.</p><p>提示:如果发现安装过程存在,使用淘宝NPM镜像，输入以下命令安装  cnpm, <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>,时出错的情况,可以检查下你的git和node的版本,笔者此前出现过因为版本过高而不能正常安装的问题.希望能给大家提供帮助.</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中if __name__ == &quot;__main__&quot;是什么作用</title>
      <link href="/2018/04/15/Python%E4%B8%ADif-name-name-main/"/>
      <url>/2018/04/15/Python%E4%B8%ADif-name-name-main/</url>
      
        <content type="html"><![CDATA[<p>2018/4/15 22:19:35 </p><hr><ul><li>最近在写毕业论文使用到Python，在查找文献资源中看到了一行代码<br><code>Python中if __name__ == &quot;__main__:&quot;</code>之前练习Python并没有注意这个，也可能太就给忘了，为了搞清这个语句于是开始疯狂百度，各种论坛博客搜索，最终找到了这个语句的作用个人感觉最易懂的解释，分享给大家</li><li>python文件的后缀名是.py，python文件既可以用来直接执行，也可以作为模块被导入。<br>我们在使用python时经常会看到<code>Python中if __name__ == &quot;__main__:&quot;</code>这样一个句子,这是什么呢？<br>其中name是模块的内置属性，而这个内置属性的值取决于这个.py文件的使用方式，即你是作为模块导入还是直接执行。<br>如果你是直接执行，那么这个name的值就是’main’，如果你作为一个模块导入，那么这个内置属性值就取决于这个文件名(不包含路径和文件扩展名)。<br>所以我们在看到一个这样的句子<code>Python中if __name__ == &quot;__main__&quot;:</code>时，就是文件在执行时要执行这个main()函数</li></ul><hr><p>附上一张号称一篇程序覆盖Python基础的代码，基本的结构都涉及到了，看不清的话保存本地放大看吧。<br><img src="https://img-blog.csdn.net/20160511222649275" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用MarkdownX编写博文</title>
      <link href="/2018/04/09/%E7%94%A8MarkdownX%E7%BC%96%E5%86%99%E5%8D%9A%E6%96%87/"/>
      <url>/2018/04/09/%E7%94%A8MarkdownX%E7%BC%96%E5%86%99%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>2018/4/9 22:19:02    </p><hr><ul><li><p>　博客搭建好后，尽管下午没事用手机查询Markdown教程，可是搜了一圈发现网上的教程参差不齐，还不如直接用html编写博文，可是想到Markdown的初衷就是方便编写博文，于是想会不会有些工具使Markdown的编写自动化了，果然搜到了一篇用MarkdownX的于是下载下来试用一番，发现挺容易入手的。</p></li><li><p>　一个优秀的产品就应该这样让人尽量容易上手，不必拘于太多的条条框框，但Markdown毕竟还是有些功能不易实现，所以下一步准备尝试使用html+css制作一些漂亮的静态页面。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
