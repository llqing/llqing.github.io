<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ArcScene三维制作</title>
      <link href="/2019/04/28/ArcScene%E4%B8%89%E7%BB%B4%E5%88%B6%E4%BD%9C/"/>
      <url>/2019/04/28/ArcScene%E4%B8%89%E7%BB%B4%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib中文不显示问题</title>
      <link href="/2019/04/23/Matplotlib%E4%B8%AD%E6%96%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/23/Matplotlib%E4%B8%AD%E6%96%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Matplotlib中中文不显示问题"><a href="#Matplotlib中中文不显示问题" class="headerlink" title="Matplotlib中中文不显示问题"></a>Matplotlib中中文不显示问题</h2><p>我们在使用jupter进行数据分析的时候，会接触到Matplotlib这个库，它是用来进行可视化数据分析的，在一个图中，我们常常会加入一些中文来进行说明。当我们加入中文的时候会出现下图所示的样子：</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126171304928-1982592030.png" alt="img"></p><p>可以看到，中文变成了这种乱码的形式。网上有很多的例子，有很多是错误的，这里我把我测试成功的方法说明一下。</p><p>我使用的电脑系统是Window10，后面的方法也是针对它的，其他的系统应该也差距不大，可以借鉴一下。</p><a id="more"></a><h3 id="1-找一个喜欢的字体"><a href="#1-找一个喜欢的字体" class="headerlink" title="1.找一个喜欢的字体"></a>1.找一个喜欢的字体</h3><p>字体的话，我们可以去网上下载，也可以用系统自带的。我们可以进入到目录：C:\Windows\Fonts中，里面有很多字体，这里我选择了微软雅黑，这里将它复制。</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126172644334-542625206.png" alt="img"></p><h3 id="2-将字体放到默认Matplotlib默认字体目录"><a href="#2-将字体放到默认Matplotlib默认字体目录" class="headerlink" title="2.将字体放到默认Matplotlib默认字体目录"></a>2.将字体放到默认Matplotlib默认字体目录</h3><p>在我电脑中Matplotlib默认字体目录是：D:\Anaconda3\Lib\site-packages\matplotlib\mpl-data\fonts\ttf。我们将复制的微软雅黑字体粘贴到这个目录下，然后双击安装。</p><p>（因为安装的时候我修改了路径，将Anaconda安装到了D盘，如果你安装到C盘或者使用默认目录的话会有一些出入。）</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126172748235-1568497793.png" alt="img"></p><h3 id="3-用下面代码找到Matplotlib的配置文件"><a href="#3-用下面代码找到Matplotlib的配置文件" class="headerlink" title="3.用下面代码找到Matplotlib的配置文件"></a>3.用下面代码找到Matplotlib的配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">print(matplotlib.matplotlib_fname())</span><br></pre></td></tr></table></figure><p> 效果如下图：</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126172004091-1576679331.png" alt="img"></p><h3 id="4-打开步骤3中得到的文件，然后修改"><a href="#4-打开步骤3中得到的文件，然后修改" class="headerlink" title="4.打开步骤3中得到的文件，然后修改"></a>4.打开步骤3中得到的文件，然后修改</h3><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126173224483-1641500168.png" alt="img"></p><p>这里我们顺便解决一下Matplotlib中负号不显示的问题，还是修改这个文件。</p><p><img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126173832737-772380232.png" alt="img"></p><h3 id="5-将Matplotlib中的缓存文件删除"><a href="#5-将Matplotlib中的缓存文件删除" class="headerlink" title="5.将Matplotlib中的缓存文件删除"></a>5.将Matplotlib中的缓存文件删除</h3><p>目录：C:\Users\用户.matplotlib中存放的是Matplotlib的缓存目录，我们只要将这个.matplotlib文件删除即可。</p><h3 id="6-重启jupyter-notebook"><a href="#6-重启jupyter-notebook" class="headerlink" title="6.重启jupyter notebook"></a>6.重启jupyter notebook</h3><p>经过上面的6步，我们的乱码问题解决了。</p><p> <img src="https://img2018.cnblogs.com/blog/1365086/201811/1365086-20181126174308128-811831411.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
            <tag> 中文显示乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora的简单入门(Markdown基本语法)</title>
      <link href="/2019/04/19/typora/"/>
      <url>/2019/04/19/typora/</url>
      
        <content type="html"><![CDATA[<ul><li><ul><li>标题的使用<ul><li><a href>标题的使用格式</a></li><li><a href>标题Typora显示形式是</a></li></ul></li><li>文本居中<ul><li><a href>文本居中使用格式</a></li><li><a href>文本居中在Typora中显示形式是</a></li></ul></li><li>下划线<ul><li><a href>下划线使用格式</a></li><li><a href>下划线在Typora显示形式是</a></li></ul></li><li>删除线<ul><li><a href>删除线使用格式</a></li><li><a href>删除线在Typora显示形式是</a></li></ul></li><li>字体加粗<ul><li><a href>字体加粗使用格式</a></li><li><a href>字体加粗在Typora显示形式是</a></li></ul></li><li>字体倾斜<ul><li><a href>字体倾斜使用格式</a></li><li><a href>字体倾斜在Typora的显示形式</a></li></ul></li><li><a href>图片的插入</a></li><li>超链接<ul><li><a href>超链接使用格式</a></li><li><a href>超链接在Typora显示形式是必须以http开头</a></li></ul></li><li>代码区域<ul><li><a href>代码区域的使用格式</a></li><li><a href>代码区域在typora中显示形式</a></li></ul></li><li>表格的使用<ul><li><a href>表格的二种使用格式</a></li><li><a href>表格在typora中显示形式</a></li></ul></li><li>任务列表<ul><li><a href>任务列表使用格式</a></li><li><a href>任务列表在typora中的显示形式</a></li></ul></li><li>列表<ul><li><a href>列表的使用格式</a></li><li><a href>列表在typora中的显示形式</a></li></ul></li><li><a href>数学表达式</a></li><li>水平分割线<ul><li><a href>水平分割线的使用格式</a></li><li><a href>水平分割线在typora中显示形式</a></li></ul></li><li>引用<ul><li><a href>引用的使用格式</a></li><li><a href>引用在typora中的显示形式</a></li></ul></li><li>注释<ul><li><a href>注释的使用格式</a></li><li><a href>注释在typora中显示形式</a></li></ul></li><li>表情<ul><li><a href>表情的使用格式</a></li><li><a href>表情在typora中的显示形式</a></li></ul></li><li><a href>Typora快捷键</a></li></ul></li></ul><p>Typora可以根据当前文档的标题层级，自动生成并显示大纲，窗口的右下角并有字数显示。</p><h2 id="标题的使用"><a href="#标题的使用" class="headerlink" title="标题的使用"></a>标题的使用</h2><h3 id="标题的使用格式"><a href="#标题的使用格式" class="headerlink" title="标题的使用格式"></a>标题的使用格式</h3><p># 一阶标题 或者快捷键Ctrl+1</p><p>##二阶标题 或者快捷键Ctrl+2</p><p>###三阶标题 或者快捷键Ctrl+3</p><p>####四阶标题 或者快捷键Ctrl+4</p><p>#####五阶标题 或者快捷键Ctrl+5</p><p>######六阶标题 或者快捷键Ctrl+6</p><h3 id="标题Typora显示形式是"><a href="#标题Typora显示形式是" class="headerlink" title="标题Typora显示形式是"></a>标题Typora显示形式是</h3><p><img src="https://img-blog.csdn.net/20180108112546034?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h2><h3 id="文本居中使用格式"><a href="#文本居中使用格式" class="headerlink" title="文本居中使用格式"></a>文本居中使用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&lt;center\&gt;这是要居中的文本内容\&lt;/center\&gt;1</span><br></pre></td></tr></table></figure><h3 id="文本居中在Typora中显示形式是"><a href="#文本居中在Typora中显示形式是" class="headerlink" title="文本居中在Typora中显示形式是"></a>文本居中在Typora中显示形式是</h3><p>这是要居中的文本</p><p>注：Typora目前并不会直接预览居中效果——相应的效果只有输出文本的时候才会显现。</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><h3 id="下划线使用格式"><a href="#下划线使用格式" class="headerlink" title="下划线使用格式"></a>下划线使用格式</h3><p>\下划线的内容\&lt;\u&gt; 或者快捷键Ctrl+U</p><h3 id="下划线在Typora显示形式是"><a href="#下划线在Typora显示形式是" class="headerlink" title="下划线在Typora显示形式是"></a>下划线在Typora显示形式是</h3><p>这就是我亲测的下划线</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><h3 id="删除线使用格式"><a href="#删除线使用格式" class="headerlink" title="删除线使用格式"></a>删除线使用格式</h3><p>~~删除线的内容~~</p><h3 id="删除线在Typora显示形式是"><a href="#删除线在Typora显示形式是" class="headerlink" title="删除线在Typora显示形式是"></a>删除线在Typora显示形式是</h3><p><del>这是删除线的内容</del></p><h2 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h2><h3 id="字体加粗使用格式"><a href="#字体加粗使用格式" class="headerlink" title="字体加粗使用格式"></a>字体加粗使用格式</h3><p><strong>加粗字体</strong> 或者快捷键Ctrl+B</p><h3 id="字体加粗在Typora显示形式是"><a href="#字体加粗在Typora显示形式是" class="headerlink" title="字体加粗在Typora显示形式是"></a>字体加粗在Typora显示形式是</h3><p><strong>加粗字体 This is a bold font</strong></p><h2 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h2><h3 id="字体倾斜使用格式"><a href="#字体倾斜使用格式" class="headerlink" title="字体倾斜使用格式"></a>字体倾斜使用格式</h3><p><em>字体倾斜了</em> 或者快捷键Ctrl+I</p><h3 id="字体倾斜在Typora的显示形式"><a href="#字体倾斜在Typora的显示形式" class="headerlink" title="字体倾斜在Typora的显示形式"></a>字体倾斜在Typora的显示形式</h3><p><em>字体倾斜了 This is a alanted font</em></p><h2 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h2><p>最简单粗暴的图片插入方式如图：</p><p><img src="https://img-blog.csdn.net/20180108113042939?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>图片来源<a href="http://support.typora.io/Images" target="_blank" rel="noopener">http://support.typora.io/Images</a></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><h3 id="超链接使用格式"><a href="#超链接使用格式" class="headerlink" title="超链接使用格式"></a>超链接使用格式</h3><p>第一种：[<a href="http://www.simba.com\](http://www.simba.com/)" target="_blank" rel="noopener">http://www.simba.com\](http://www.simba.com/)</a></p><p>第二种：快捷键Ctrl+K</p><p><a href="超链接地址">自定义内容</a> 例如：<a href="www.baidu.com">百度一下</a></p><h3 id="超链接在Typora显示形式是：（必须以http开头）"><a href="#超链接在Typora显示形式是：（必须以http开头）" class="headerlink" title="超链接在Typora显示形式是：（必须以http开头）"></a>超链接在Typora显示形式是：（必须以http开头）</h3><p>第一种：<a href="http://www.simba.com/" target="_blank" rel="noopener">http://www.simba.com</a></p><p>第二种：<a href="https://blog.csdn.net/SIMBA1949/article/details/www.baidu.com" target="_blank" rel="noopener">百度一下</a></p><p>按住Ctrl键+点击上面链接就可以直接访问该链接</p><h2 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h2><p>Typora支持对多种语言的代码区域进行<strong>语法高亮</strong>。这些语言可以说是<strong>涵盖了绝大部分经常使用的编程语言</strong>，包括C++，Python，MATLAB，甚至包含spreadsheet（也就是Excel电子表格）。用Typora记编程笔记，看起来一清二楚。如果设置代码语言为flow，那么可以直接画出一个流程图；还可以使用相应的方法画出时序图等图表。</p><h3 id="代码区域的使用格式"><a href="#代码区域的使用格式" class="headerlink" title="代码区域的使用格式"></a>代码区域的使用格式</h3><p><code></code> <code>+编程语言：例如java代码：</code> <code></code>java</p><h3 id="代码区域在typora中显示形式"><a href="#代码区域在typora中显示形式" class="headerlink" title="代码区域在typora中显示形式"></a>代码区域在typora中显示形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">simba</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我爱你，中国"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="表格的使用"><a href="#表格的使用" class="headerlink" title="表格的使用"></a>表格的使用</h2><h3 id="表格的二种使用格式"><a href="#表格的二种使用格式" class="headerlink" title="表格的二种使用格式"></a>表格的二种使用格式</h3><p>第一种：快捷键<strong>Ctrl+T</strong>，会自动跳出设置行和列的设置框，如下图</p><p><img src="https://img-blog.csdn.net/20180108113324218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>第二种：</p><p>|国籍|省份|市区|</p><h3 id="表格在typora中显示形式"><a href="#表格在typora中显示形式" class="headerlink" title="表格在typora中显示形式"></a>表格在typora中显示形式</h3><p>第一种：</p><table><thead><tr><th>国籍</th><th>省份</th><th>市区</th></tr></thead><tbody><tr><td>中国</td><td>北京</td><td>东城区</td></tr></tbody></table><p>第二种：</p><table><thead><tr><th>国籍</th><th>省份</th><th>市区</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><h3 id="任务列表使用格式"><a href="#任务列表使用格式" class="headerlink" title="任务列表使用格式"></a>任务列表使用格式</h3><p>- [ ] 文字 （注：注意用空格隔开）</p><h3 id="任务列表在typora中的显示形式"><a href="#任务列表在typora中的显示形式" class="headerlink" title="任务列表在typora中的显示形式"></a>任务列表在typora中的显示形式</h3><ul><li style="list-style: none"><input type="checkbox" checked> JAVA</li><li style="list-style: none"><input type="checkbox"> C</li><li style="list-style: none"><input type="checkbox"> C++</li><li style="list-style: none"><input type="checkbox"> Python</li></ul><p>（注意：在CSDN博客上未显示，但是在Typora上显示如下图：<br><img src="https://img-blog.csdn.net/20180108114342465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="列表的使用格式"><a href="#列表的使用格式" class="headerlink" title="列表的使用格式"></a>列表的使用格式</h3><p>+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表</p><h3 id="列表在typora中的显示形式"><a href="#列表在typora中的显示形式" class="headerlink" title="列表在typora中的显示形式"></a>列表在typora中的显示形式</h3><ul><li>java</li><li>C</li><li>C++</li><li>Python</li></ul><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>Typora支持加入用LaTeX写成的数学公式，并且在软件界面下用MathJax直接渲染。</p><p>数学公式分为两种：</p><p>一种是行内公式(inline math，可以在偏好设置中单独打开，由一个美元符号$将公式围起来；</p><p>一种是行外公式，直接 按<strong>Ctrl+Shift+M</strong>；</p><p>注：上标和下标可以使用数学表达式来获取</p><h2 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h2><h3 id="水平分割线的使用格式"><a href="#水平分割线的使用格式" class="headerlink" title="水平分割线的使用格式"></a>水平分割线的使用格式</h3><p>***或者- - -</p><h3 id="水平分割线在typora中显示形式"><a href="#水平分割线在typora中显示形式" class="headerlink" title="水平分割线在typora中显示形式"></a>水平分割线在typora中显示形式</h3><hr><hr><p>（注意：在CSDN博客上未显示，但是在Typora上显示如下图：<br><img src="https://img-blog.csdn.net/20180108114442472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>）</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的使用格式"><a href="#引用的使用格式" class="headerlink" title="引用的使用格式"></a>引用的使用格式</h3><p>>+空格</p><h3 id="引用在typora中的显示形式"><a href="#引用在typora中的显示形式" class="headerlink" title="引用在typora中的显示形式"></a>引用在typora中的显示形式</h3><blockquote><p>与天奋斗，其乐无穷！与地奋斗，其乐无穷！与人奋斗，其乐无穷！</p><p> ———— 《毛泽东选集》之《奋斗自勉》（毛泽东1917年）</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="注释的使用格式"><a href="#注释的使用格式" class="headerlink" title="注释的使用格式"></a>注释的使用格式</h3><p>要添加注释的文字[1](<a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fn:" target="_blank" rel="noopener">https://blog.csdn.net/SIMBA1949/article/details/79001226#fn:</a>)</p><h3 id="注释在typora中显示形式"><a href="#注释在typora中显示形式" class="headerlink" title="注释在typora中显示形式"></a>注释在typora中显示形式</h3><p>中国<a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fn:" target="_blank" rel="noopener">2</a></p><h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><h3 id="表情的使用格式"><a href="#表情的使用格式" class="headerlink" title="表情的使用格式"></a>表情的使用格式</h3><p>:单词</p><h3 id="表情在typora中的显示形式"><a href="#表情在typora中的显示形式" class="headerlink" title="表情在typora中的显示形式"></a>表情在typora中的显示形式</h3><p>:smiley:<br>（注意：在CSDN博客上未显示，但是在Typora上显示如下图：<br><img src="https://img-blog.csdn.net/20180108114531939?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU0lNQkExOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>）</p><h2 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+1</td><td>一阶标题</td><td>Ctrl+B</td><td>字体加粗</td></tr><tr><td>Ctrl+2</td><td>二阶标题</td><td>Ctrl+I</td><td>字体倾斜</td></tr><tr><td>Ctrl+3</td><td>三阶标题</td><td>Ctrl+U</td><td>下划线</td></tr><tr><td>Ctrl+4</td><td>四阶标题</td><td>Ctrl+Home</td><td>返回Typora顶部</td></tr><tr><td>Ctrl+5</td><td>五阶标题</td><td>Ctrl+End</td><td>返回Typora底部</td></tr><tr><td>Ctrl+6</td><td>六阶标题</td><td>Ctrl+T</td><td>创建表格</td></tr><tr><td>Ctrl+L</td><td>选中某句话</td><td>Ctrl+K</td><td>创建超链接</td></tr><tr><td>Ctrl+D</td><td>选中某个单词</td><td>Ctrl+F</td><td>搜索</td></tr><tr><td>Ctrl+E</td><td>选中相同格式的文字</td><td>Ctrl+H</td><td>搜索并替换</td></tr><tr><td>Alt+Shift+5</td><td>删除线</td><td>Ctrl+Shift+I</td><td>插入图片</td></tr></tbody></table><p>注：一些实体符号需要在实体符号之前加”\”才能够显示</p><hr><ol><li>伟大的中华人民共和国万岁 <a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fnref:" target="_blank" rel="noopener">↩</a></li><li>伟大的中华人民共和国万岁 <a href="https://blog.csdn.net/SIMBA1949/article/details/79001226#fnref:" target="_blank" rel="noopener">↩</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python来撩妹吧-实时掌控她的小情绪</title>
      <link href="/2019/04/19/%E7%94%A8Python%E6%9D%A5%E6%92%A9%E5%A6%B9%E5%90%A7(1)-%E5%AE%9E%E6%97%B6%E6%8E%8C%E6%8E%A7%E5%A5%B9%E7%9A%84%E5%B0%8F%E6%83%85%E7%BB%AA/"/>
      <url>/2019/04/19/%E7%94%A8Python%E6%9D%A5%E6%92%A9%E5%A6%B9%E5%90%A7(1)-%E5%AE%9E%E6%97%B6%E6%8E%8C%E6%8E%A7%E5%A5%B9%E7%9A%84%E5%B0%8F%E6%83%85%E7%BB%AA/</url>
      
        <content type="html"><![CDATA[<p>好不容易有了女朋友，可相处起来总是磕磕碰碰。</p><p>有时候，你很想关心她，但是你太忙了，以至于她一直抱怨，觉得你不够关心她。你暗自下决心，下次一定要准时发消息给她，哪怕是几句话，可是你又忘记了。你觉得自己很委屈😭，但是她又觉得你不负责。</p><p>现在，再不用担心了，用python就可以给女友定时发提示消息了，而且不会漏过每一个关键时刻，每天早上起床、中午吃饭、晚上吃饭、晚上睡觉，都会准时发消息给她了，而且还可以让她学习英语单词哦！</p><p>在生日来临之时，自动发祝福语。在节日来临之时，比如三八妇女节、女神节、情人节、春节、圣诞节，自动发问候语哦，再也不用担心他说你没有仪式感了😀</p><p>最重要的是，可以实时知道女友的情感情绪指数，再也不用担心女友莫名其妙生气了。</p><h2 id="编写思路"><a href="#编写思路" class="headerlink" title="编写思路"></a>编写思路</h2><p>为了方便快速开发，我们使用python中的wxpy模块完成微信的基本操作。</p><p>首先，我们设置一个config.ini配置文件，并从这个配置文件开始读取信息。这些参数一看就懂，所以无需多言。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cf</span> = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">cf.read("./config.ini",encoding='UTF-8')</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友的微信名称，记住，不是微信ID也不是微信备注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你女友的微信名称，记住，不是微信ID也不是微信备注</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my_lady_wechat_name</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"my_lady_wechat_name"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_morning</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_morning"</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_lunch</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_lunch"</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dinner</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_dinner"</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dream</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"say_good_dream"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友生日信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几月，注意补全数字，为两位数，比如6月必须写成06</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_month</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"birthday_month"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 几号，注意补全数字，为两位数，比如6号必须写成08</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_day</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"birthday_day"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间的随机提示语</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般这里的代码不要改动，需要增加提示语可以自己打开对应的文件修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#早上起床问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_morning</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_morning.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_morning = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_morning)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#中午吃饭问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_lunch</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_lunch.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_lunch = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_lunch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#晚上吃饭问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_dinner</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_dinner.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_dinner = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_dinner)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#晚上睡觉问候语列表，数据来源于新浪微博</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_good_dream</span> = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">with open("./remind_sentence/sentence_good_dream.txt", "r",encoding='UTF-8') as f:</span><br><span class="line"></span><br><span class="line">    str_list_good_dream = f.readlines()</span><br><span class="line"></span><br><span class="line">print(str_list_good_dream)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置晚上睡觉问候语是否在原来的基础上再加上每日学英语精句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># False表示否 True表示是</span></span><br><span class="line"></span><br><span class="line">if((cf.get("configuration", "flag_learn_english")) == '1'):</span><br><span class="line"></span><br><span class="line">    flag_learn_english = True</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line"></span><br><span class="line">    flag_learn_english = False</span><br><span class="line"></span><br><span class="line">print(flag_learn_english)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置所有问候语结束是否加上表情符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># False表示否 True表示是</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_emoj</span> = <span class="string">"(•‾̑⌣‾̑•)✧˖°----(๑´ڡ`๑)----(๑¯ิε ¯ิ๑)----(๑•́ ₃ •̀๑)----( ∙̆ .̯ ∙̆ )----(๑˘ ˘๑)----(●′ω`●)----(●･̆⍛･̆●)----ಥ_ಥ----_(:qゝ∠)----(´；ω；`)----( `)3')----Σ((( つ•̀ω•́)つ----╰(*´︶`*)╯----( ´´ิ∀´ิ` )----(´∩｀。)----( ื▿ ื)----(｡ŏ_ŏ)----( •ิ _ •ิ )----ヽ(*΄◞ิ౪◟ิ‵ *)----( ˘ ³˘)----(; ´_ゝ`)----(*ˉ﹃ˉ)----(◍'౪`◍)ﾉﾞ----(｡◝‿◜｡)----(ಠ .̫.̫ ಠ)----(´◞⊖◟`)----(。≖ˇェˇ≖｡)----(◕ܫ◕)----(｀◕‸◕´+)----(▼ _ ▼)----( ◉ืൠ◉ื)----ㄟ(◑‿◐ )ㄏ----(●'◡'●)ﾉ♥----(｡◕ˇ∀ˇ◕）----( ◔ ڼ ◔ )----( ´◔ ‸◔`)----(☍﹏⁰)----(♥◠‿◠)----ლ(╹◡╹ლ )----(๑꒪◞౪◟꒪๑)"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_list_emoj</span> = str_emoj.split(<span class="string">'----'</span>)</span><br><span class="line"></span><br><span class="line">if ((cf.get("configuration", "flag_wx_emoj")) == '1'):</span><br><span class="line"></span><br><span class="line">    flag_wx_emoj = True</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line"></span><br><span class="line">    flag_wx_emoj = False</span><br><span class="line"></span><br><span class="line">print(str_list_emoj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置节日祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情人节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Valentine</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Valentine"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Valentine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三八妇女节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Women</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Women"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Women)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平安夜祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas_Eve</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Christmas_Eve"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Christmas_Eve)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圣诞节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_Christmas"</span>)</span><br><span class="line"></span><br><span class="line">print(str_Christmas)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 她生日的时候的祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_birthday</span> = cf.get(<span class="string">"configuration"</span>, <span class="string">"str_birthday"</span>)</span><br><span class="line"></span><br><span class="line">print(str_birthday)</span><br></pre></td></tr></table></figure><p>如果你愿意，可以在上面对时间的判断中，加入一些其他你想要的，这样你女友就更开心啦！后期如果有时间，我将会加上以上节日问候功能。😀</p><p>接着，开启微信机器人，为了程序的健壮性，自动判断一下操作系统，根据不同操作系统执行不同指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动微信机器人，自动根据操作系统执行不同的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows系统或macOS Sierra系统使用bot = Bot()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linux系统或macOS Terminal系统使用bot = Bot(console_qr=2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'Windows'</span> <span class="keyword">in</span> platform.system()):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Windows</span></span><br><span class="line"></span><br><span class="line">    bot = Bot()</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>(<span class="string">'Darwin'</span> <span class="keyword">in</span> platform.system()):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># MacOSX</span></span><br><span class="line"></span><br><span class="line">    bot = Bot()</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span>(<span class="string">'Linux'</span> <span class="keyword">in</span> platform.system()):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Linux</span></span><br><span class="line"></span><br><span class="line">    bot = Bot(console_qr=<span class="number">2</span>,cache_path=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自行确定</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"无法识别你的操作系统类型，请自己设置"</span>)</span><br></pre></td></tr></table></figure><p>设置完相关参数以后，我们再来学习一下，如何每天教女友学英语：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取每日励志精句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_message</span><span class="params">()</span>:</span></span><br><span class="line">    r = requests.get(<span class="string">"http://open.iciba.com/dsapi/"</span>)</span><br><span class="line">    note = r.json()[<span class="string">'note'</span>]</span><br><span class="line">    content = r.json()[<span class="string">'content'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> note, content</span><br></pre></td></tr></table></figure><p>只有每天的问候和节日问候是仅仅不够的，我们必须时刻知道她的情绪指数，这里可以使用snowNlp或者jieba来做分析，但是为了能够在打包成exe可执行文件时使得程序尽可能小，我们采取直接调用接口的方式来做。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收女友消息监听器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 女友微信名</span></span><br><span class="line"></span><br><span class="line">my_girl_friend = bot.friends().search(my_lady_wechat_name)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># chats=my_girl_friend 表示接收消息的对象，也就是女友</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># except_self=False 表示同时也接收自己发的消息，不需要接收自己消息的可以去掉</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@bot.register(chats=my_girl_friend, except_self=False)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_others</span><span class="params">(msg)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出聊天内容</span></span><br><span class="line"></span><br><span class="line">    print(msg.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 做极其简单的情感分析</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果仅供参考，请勿完全相信</span></span><br><span class="line"></span><br><span class="line">    postData = &#123;<span class="string">'data'</span>:msg.text&#125;</span><br><span class="line"></span><br><span class="line">    response = post(<span class="string">'https://bosonnlp.com/analysis/sentiment?analysisType='</span>,data=postData)</span><br><span class="line"></span><br><span class="line">    data = response.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 情感评分指数(越接近1表示心情越好，越接近0表示心情越差)</span></span><br><span class="line"></span><br><span class="line">    now_mod_rank = (data.split(<span class="string">','</span>)[<span class="number">0</span>]).replace(<span class="string">'[['</span>,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">   print(<span class="string">"来自女友的消息:%s\n当前情感得分:%s\n越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！\n\n"</span> % (msg.text, now_mod_rank))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送信息到文件传输助手</span></span><br><span class="line"></span><br><span class="line">   mood_message = <span class="string">u"来自女友的消息:"</span> + msg.text + <span class="string">"\n当前情感得分:"</span> + now_mod_rank + <span class="string">"\n越接近1表示心情越好，越接近0表示心情越差，情感结果仅供参考，请勿完全相信！\n\n"</span></span><br><span class="line"></span><br><span class="line">    bot.file_helper.send(mood_message)</span><br></pre></td></tr></table></figure><p>教完女友学英语后，开始把我们的关心语发给她。这里涉及到wxpy模块的相关操作，很简单，看我的例子就会了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送消息给她</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(your_message)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对方的微信名称</span></span><br><span class="line"></span><br><span class="line">        my_friend = bot.friends().search(my_lady_wechat_name)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送消息给对方</span></span><br><span class="line"></span><br><span class="line">        my_friend.send(your_message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 出问题时，发送信息到文件传输助手</span></span><br><span class="line"></span><br><span class="line">        bot.file_helper.send(<span class="string">u"守护女友出问题了，赶紧去看看咋回事~"</span>)</span><br></pre></td></tr></table></figure><p>最后，就是如何每天定时发关心语给女友的问题了。首先来个while循环，365天无限关心😀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来个死循环，24小时关心她</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 提示</span></span><br><span class="line"></span><br><span class="line">       print(<span class="string">"守护中，时间:%s"</span>% time.ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 每天定时问候，早上起床，中午吃饭，晚上吃饭，晚上睡觉</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 获取时间，只获取时和分，对应的位置为倒数第13位到倒数第8位</span></span><br><span class="line"></span><br><span class="line">       now_time = time.ctime()[<span class="number">-13</span>:<span class="number">-8</span>]</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (now_time == say_good_morning):</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 随机取一句问候语</span></span><br><span class="line"></span><br><span class="line">           message = choice(str_list_good_morning)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment"># 是否加上随机表情</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(flag_wx_emoj):</span><br><span class="line"></span><br><span class="line">               message = message + choice(str_list_emoj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           send_message(message)</span><br><span class="line"></span><br><span class="line">           print(<span class="string">"提醒女友早上起床:%s"</span> % time.ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># …………这下面还有很多代码，我就不列出来了…………</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 延时60秒</span></span><br><span class="line"></span><br><span class="line">       time.sleep(<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>最后，输入以下代码开始守护女友模式吧~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始守护女友</span></span><br><span class="line"></span><br><span class="line">   t = Thread(target=start_care, name=<span class="string">'start_care'</span>)</span><br><span class="line"></span><br><span class="line">   t.start()</span><br></pre></td></tr></table></figure><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p><strong>pip安装下列包：</strong></p><ul><li style="list-style: none"><input type="checkbox" checked> pip install wxpy</li><li style="list-style: none"><input type="checkbox" checked> pip install requests</li></ul><p><strong>设置以下内容：</strong></p><p>config.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[configuration]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友的微信名称，记住，不是微信ID也不是微信备注</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my_lady_wechat_name</span> = 小强子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置女友生日信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若某一项月份或者日期不想设置，请输入99，不能留空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几月，注意补全数字，为两位数，比如6月必须写成06</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_month</span> = <span class="number">03</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几号，注意补全数字，为两位数，比如6号必须写成08</span></span><br><span class="line"></span><br><span class="line"><span class="attr">birthday_day</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若某一项时间不想设置，请输入99:00，不能留空</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_morning</span> = <span class="number">03</span>:<span class="number">09</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_lunch</span> = <span class="number">03</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dinner</span> = <span class="number">03</span>:<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_good_dream</span> = <span class="number">03</span>:<span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置晚上睡觉问候语是否在原来的基础上再加上每日学英语精句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1表示是，0表示否</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flag_learn_english</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置所有问候语结束是否加上表情符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1表示是，0表示否</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flag_wx_emoj</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置节日祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情人节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Valentine</span> = 亲爱的，情人节快乐！我想和你一起分享生命中的每一天，直到永远。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三八妇女节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Women</span> = 嘿，女神节到了，祝我的女神开心快乐！你每天都是那么好看^_^</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平安夜祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas_Eve</span> = 宝贝，平安夜快乐，你吃苹果了吗？n(*≧▽≦*)n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 圣诞节祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_Christmas</span> = 小仙女，圣诞节快乐哦！（づ￣<span class="number">3</span>￣）づ╭❤～</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 她生日的时候的祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str_birthday</span> = 亲爱的，生日快乐，我已经给你准备好了礼物哦，明天你就能看到啦！(*@ο@*) 哇～</span><br></pre></td></tr></table></figure><h2 id="完整代码下载"><a href="#完整代码下载" class="headerlink" title="完整代码下载:"></a>完整代码下载:</h2><p><a href="https://github.com/llqing/Guardian-of-girlfriend.git" target="_blank" rel="noopener">https://github.com/llqing/Guardian-of-girlfriend.git</a></p><h2 id="演示图片"><a href="#演示图片" class="headerlink" title="演示图片"></a>演示图片</h2><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095634fescbfaccax777aa.jpg" weight="620" height="993"></p><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095635mgnnooldeqlqkshd.jpg" weight="620" height="993"></p><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095636u1vkrnkkkyjzgo2m.jpg" alt></p><p><img src="http://attachbak.dataguru.cn/attachments/portal/201904/04/095637jovs995vwj7lvsvs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 好玩的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 撩妹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/04/14/Redis/"/>
      <url>/2019/04/14/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="一-是什么"><a href="#一-是什么" class="headerlink" title="一. 是什么?"></a>一. 是什么?</h2><blockquote><p>redis是一款优秀的nosql（非关系型），key-vlaue,内存级别的数据库！redis是单线程,操作是安全的！<br>关系型:用一张二维表格来表示和存储现实生活中对象的这一类数据库。 oracle ，mysql<br>非关系型（nosql）:不用二维表格，比如key-value ,文档等数据.Redis,MongoDB ,Hadoop</p></blockquote><h2 id="二-特点"><a href="#二-特点" class="headerlink" title="二. 特点"></a>二. 特点</h2><blockquote><p>1.Redis支持数据的持久化，会根据一定的策略持久化到磁盘,即使断电也不会丢失数据.<br>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>3.Redis支持数据的备份，即master-slave模式的数据备份。</p></blockquote><h2 id="三-数据及应用场景"><a href="#三-数据及应用场景" class="headerlink" title="三. 数据及应用场景"></a>三. 数据及应用场景</h2><blockquote><p>1.String : string是redis最基本的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如图片或者序列化的对象。String类型是Redis最基本的数据类型，一个键最大能存储512MB。<br>常用命令:<br>① get、获取存储在指定键中的值<br>② set、设置存储在指定键中的值<br>③ del、删除存储在指定键中的值（这个命令可以用于所有的类型）<br>使用场景:利用incr生成id,decr减库存, 缓存–过期时间设置，模拟session</p></blockquote><p>-</p><blockquote><p>2.list: Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>常用命令：<br>① rpush、将给定值推入列表的右端<br>② lrange、获取列表在指定范围上的所有值<br>③ lindex、获取列表在指定范围上的单个元素<br>使用场景: 多任务调度队列</p></blockquote><p>-</p><blockquote><p>3.set: Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。<br>常用命令：<br>①sadd、将给定元素添加到集合<br>②smembers、返回集合包含的所有元素<br>③sismember、检查指定元素是否存在于集合中<br>使用场景: 微博关注数</p></blockquote><p>-</p><blockquote><p>4.hash : Redis hash 是一个键值(key=&gt;value)对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>常用命令：<br>①hset、在散列里面关联起指定的键值对<br>②hget、获取指定散列键的值<br>③hgetall、获取散列包含的所有键值对<br>④hdel、如果给定键存在于散列里面，那么移除这个键<br>使用场景:购物车</p></blockquote><p>-</p><blockquote><p>5.zset: Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。<br>常用命令：<br>①zadd、将一个带有给定分值的成员添加到有序集合里面<br>②zrange、根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>③zrangebyscore、获取有序集合在给定分值范围内的所有元素 ④zrem、如果指定成员存在于有序集合中，那么移除这个成员<br>使用场景:排行榜</p></blockquote><h2 id="四-持久化"><a href="#四-持久化" class="headerlink" title="四:持久化"></a>四:持久化</h2><blockquote><ol><li>rdb 快照:默认redis是会以快照的形式将数据持久化到磁盘的（一个二进制文件，dump.rdb，这个文件名字可以指定），在配置文件(redis.conf)中的格式是：save<br>N M表示在N秒之内，redis至少发生M次修改则redis抓快照到磁盘。当然我们也可以手动执行save或者bgsave（异步）做快照。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  #################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Save the DB on disk:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment">#   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Note: you can disable saving at all commenting all the "save" lines.</span></span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">1000012345678910111213141516171819</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>aof 命令副本: AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li></ol></blockquote><h2 id="五-优点"><a href="#五-优点" class="headerlink" title="五. 优点"></a>五. 优点</h2><blockquote><p>1.性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br>2.丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br>3.原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。<br>4.丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p></blockquote><h2 id="六-访问"><a href="#六-访问" class="headerlink" title="六.访问"></a>六.访问</h2><p>Java访问redis:</p><blockquote><p>1.使用jedisjava客户端来访问redis服务器,优点类似jdbc访问db一样<br>2.如果是spring进行集成时,可以使用springDataRedis来访问redis , springDataRedis 只是对jedis的二次封装</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法（1）——冒泡排序算法详解</title>
      <link href="/2019/04/14/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/14/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>基本思想</strong></li></ol><p>冒泡排序的基本思想就是：从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。</p><p>算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。</p><ol start="2"><li><strong>运行过程</strong></li></ol><p>冒泡排序算法的运作如下：</p><p>1、比较相邻的元素。如果第一个比第二个大（小），就交换他们两个。</p><p>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大（小）的数。</p><p>3、针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。</p><p>4、持续每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序。</p><p><img src="https://img-blog.csdn.net/20160316103848750" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):  <span class="comment"># 这个循环负责设置冒泡排序进行的次数</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums) - i - <span class="number">1</span>):  <span class="comment"># j为列表下标</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">print(bubble_sort([<span class="number">45</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">97</span>]))</span><br><span class="line"><span class="comment"># 输出：[8, 12, 19, 22, 32, 33, 45, 97]</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>算法变种</strong></li></ol><p>鸡尾酒排序又叫定向冒泡排序，搅拌排序、来回排序等，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p><p>鸡尾酒排序在于排序过程是先从低到高，然后从高到低；而冒泡排序则仅从低到高去比较序列里的每个元素。它可以得到比冒泡排序稍微好一点的效能，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环只移动一个项目。</p><p>以序列(2,3,4,5,1)为例，鸡尾酒排序只需要从低到高，然后从高到低就可以完成排序，但如果使用冒泡排序则需要四次。</p><p>但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cocktail_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = left; j &lt; right; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">for</span> (j = right; j &gt; left; j--)</span><br><span class="line"><span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">swap(arr[j - <span class="number">1</span>], arr[j]);</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>性能分析</strong></li></ol><ul><li><p>时间复杂度</p><p>在设置标志变量之后：</p><p>当原始序列“正序”排列时，冒泡排序总的比较次数为n-1，移动次数为0，也就是说冒泡排序在最好情况下的时间复杂度为O(n)；</p><p>当原始序列“逆序”排序时，冒泡排序总的比较次数为n(n-1)/2，移动次数为3n(n-1)/2次，所以冒泡排序在最坏情况下的时间复杂度为O(n^2)；</p><p>当原始序列杂乱无序时，冒泡排序的平均时间复杂度为O(n^2)。</p></li><li><p>空间复杂度</p><p>冒泡排序排序过程中需要一个临时变量进行两两交换，所需要的额外空间为1，因此空间复杂度为O(1)。</p></li><li><p>稳定性</p><p>冒泡排序在排序过程中，元素两两交换时，相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python：类属性，实例属性，私有属性与静态方法，类方法，实例方法</title>
      <link href="/2019/04/14/python%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/14/python%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Python：类属性，实例属性，私有属性与静态方法，类方法，实例方法 </span><br><span class="line">属性分为实例属性与类属性</span><br><span class="line"></span><br><span class="line">方法分为普通方法，类方法，静态方法</span><br><span class="line"></span><br><span class="line">一：属性：</span><br><span class="line"></span><br><span class="line">　　尽量把需要用户传入的属性作为实例属性，而把同类都一样的属性作为类属性。实例属性在每创造一个实例时都会初始化一遍，不同的实例的实例属性可能不同，不同实例的类属性都相同。从而减少内存。</span><br><span class="line"></span><br><span class="line">　　<span class="number">1</span>：实例属性：</span><br><span class="line"></span><br><span class="line">　　　　最好在init(self,…)中初始化</span><br><span class="line"></span><br><span class="line">　　　　内部调用时都需要加上self.</span><br><span class="line"></span><br><span class="line">　　　　外部调用时用instancename.propertyname</span><br><span class="line"></span><br><span class="line">　　<span class="number">2</span>:类属性：</span><br><span class="line"></span><br><span class="line">　　　　在init()外初始化</span><br><span class="line"></span><br><span class="line">　　　　在内部用classname.类属性名调用</span><br><span class="line"></span><br><span class="line">　　　　外部既可以用classname.类属性名又可以用instancename.类属性名来调用</span><br><span class="line"></span><br><span class="line">　　<span class="number">3</span>：私有属性：</span><br><span class="line"></span><br><span class="line">　　　　<span class="number">1</span>）：单下划线_开头：只是告诉别人这是私有属性，外部依然可以访问更改</span><br><span class="line"></span><br><span class="line">　　　　<span class="number">2</span>）：双下划线__开头：外部不可通过instancename.propertyname来访问或者更改</span><br><span class="line"></span><br><span class="line">　　　　　　实际将其转化为了_classname__propertyname</span><br><span class="line"></span><br><span class="line">二：方法</span><br><span class="line"></span><br><span class="line">　　<span class="number">1</span>：普通类方法：</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">def</span> <span class="title">fun_name</span><span class="params">(self,…)</span>:</span></span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">　　　　外部用实例调用</span><br><span class="line"></span><br><span class="line">　　<span class="number">2</span>：静态方法：@staticmethod</span><br><span class="line"></span><br><span class="line">　　　　　　不能访问实例属性！！！ 参数不能传入self！！！</span><br><span class="line"></span><br><span class="line">　　　　　　与类相关但是不依赖类与实例的方法！！</span><br><span class="line"></span><br><span class="line">　　<span class="number">3</span>:类方法：@classmethod</span><br><span class="line"></span><br><span class="line">　　　　　　不能访问实例属性！！！ 参数必须传入cls！！！</span><br><span class="line"></span><br><span class="line">　　　　　　必须传入cls参数（即代表了此类对象—–区别——self代表实例对象），并且用此来调用类属性：cls.类属性名</span><br><span class="line"></span><br><span class="line">　　*静态方法与类方法都可以通过类或者实例来调用。其两个的特点都是不能够调用实例属性</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 属性 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArcGIS API for JavaScript 入门教程(3)-你看得到：数据与视图分离</title>
      <link href="/2019/04/13/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-3-%E4%BD%A0%E7%9C%8B%E5%BE%97%E5%88%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%86%E5%9B%BE%E5%88%86%E7%A6%BB/"/>
      <url>/2019/04/13/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-3-%E4%BD%A0%E7%9C%8B%E5%BE%97%E5%88%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%86%E5%9B%BE%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇开始正式讲API。</p><p>数据和视图分离不是什么奇怪的事情了，这是一个著名的设计——数据与视图分开。</p></blockquote><p>请跟我做，把以下折叠的代码复制到新建的html文件中，并双击打开。</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;</span><br><span class="line">  &lt;title&gt;Intro to MapView - Create a 2D map - 4.7&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    html,</span><br><span class="line">    body,</span><br><span class="line">    #viewDiv &#123;</span><br><span class="line">      padding: 0; margin: 0;</span><br><span class="line">      height: 100%; width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.7/esri/css/main.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://js.arcgis.com/4.7/&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    require([</span><br><span class="line">      &quot;esri/Map&quot;,&quot;esri/views/MapView&quot;,&quot;dojo/domReady!&quot;</span><br><span class="line">    ], function(Map, MapView) &#123;</span><br><span class="line"></span><br><span class="line">      var map = new Map(&#123;</span><br><span class="line">        basemap: &quot;streets&quot;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      var view = new MapView(&#123;</span><br><span class="line">        container: &quot;viewDiv&quot;,</span><br><span class="line">        map: map,</span><br><span class="line">        zoom: 4,</span><br><span class="line">        center: [15, 65] // longitude, latitude</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;viewDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>大概是这样：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180523235618331-1247825520.png" alt="img"></p><p>打开后是这样的：</p><p>（环境说明：Chrome 65浏览器）</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180523235659575-1878304213.png" alt="img"></p><p>那我们再复制另一个代码：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;</span><br><span class="line">  &lt;title&gt;Intro to SceneView - Create a 3D map - 4.7&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    html,</span><br><span class="line">    body,</span><br><span class="line">    #viewDiv &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.7/esri/css/main.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://js.arcgis.com/4.7/&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    require([</span><br><span class="line">      &quot;esri/Map&quot;,</span><br><span class="line">      &quot;esri/views/SceneView&quot;,</span><br><span class="line">      &quot;dojo/domReady!&quot;</span><br><span class="line">    ], function(Map, SceneView) &#123;</span><br><span class="line"></span><br><span class="line">      var map = new Map(&#123;</span><br><span class="line">        basemap: &quot;streets&quot;,</span><br><span class="line">        ground: &quot;world-elevation&quot;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      var view = new SceneView(&#123;</span><br><span class="line">        container: &quot;viewDiv&quot;,</span><br><span class="line">        map: map,</span><br><span class="line">        scale: 50000000,</span><br><span class="line">        center: [-101.17, 21.78]</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;viewDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>得到的结果是：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180523235927632-1266833964.png" alt="img"></p><h1 id="1-解释"><a href="#1-解释" class="headerlink" title="1. 解释"></a>1. 解释</h1><p>本着能不解释代码就不解释代码的精神，我先给大家讲一下我讲这个JsAPI的思路。</p><p>它分五个主要学习的部分：</p><ul><li>数据</li><li>视图</li><li>空间分析</li><li>符号渲染</li><li>小部件</li></ul><p>其他不说不代表不会用到，但是相对于入门而言，这五个部分足够了。其重点讲解前三部分。</p><p>如果看文字不舒服，那么上个结构图：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524193502413-859382166.png" alt="img"></p><p>而上面两个案例，拿同一份数据结合二三维视图作了展示。</p><p>抛开代码细节（如入口、引用、页面组织、样式等）不谈，我首先把代码中用于表示“数据”和“视图”的Js代码抽取出来：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524194308611-2083837347.png" alt="img"></p><p>左边是二维的，右边是三维的。</p><p>分别用两个对象来描述“数据”和“视图”，</p><p><strong>用Map类实例出来的【map对象】以描述数据；用MapView类、SceneView类实例出来的【view对象】以描述视图</strong>。</p><p>那么你可能会问了，倘若已经在代码里做出来了数据与视图，有什么桥梁可以连接它们呢？我们把view的代码展开。</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524194641686-280020319.png" alt="img"></p><p>我们知道，在Js中通过new关键字实例化一个类，SceneView类的构造函数指定了一个Js中的Object对象作为参数，这个Object对象是这样的：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    container: &quot;viewDiv&quot;,</span><br><span class="line">    map: map,</span><br><span class="line">    scale: 50000000,</span><br><span class="line">    center: [-101.17, 21.78]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>其中，就有一个Map类型的属性叫map，将上面实例化的map对象赋予给它就实现了视图（SceneView、MapView）与数据（Map）的连接。</p><p>其他的属性我们暂且不管，至少，在Js代码中，我们知道了哪些代码用于构造地理数据——用Map类、我们知道了哪些代码用于构造视图——View类。</p><blockquote><p>哦对了，SceneView和MapView都继承自View类。虽然我们知道Js是弱类型的语言，但是Dojo帮我们做了一些面向对象的工作。</p><p>在这里，我沿用更广泛的说法，那就是用“类”这个称呼去替代官方的“模块”这个称呼，其实MapView、Map、SceneView都是模块，它们存在于js包里面。</p></blockquote><h1 id="2-补充"><a href="#2-补充" class="headerlink" title="2. 补充"></a>2. 补充</h1><p>如果上面看得懂，这里可以作为补充材料来阅读。</p><h2 id="2-1-数据如何组织"><a href="#2-1-数据如何组织" class="headerlink" title="2.1 数据如何组织"></a>2.1 数据如何组织</h2><p>相信肯定有筒子开始疑问Map对象的构造参数中应该如何组织属性了吧，这个时候就需要去查示例代码和官方API参考了。</p><p>我可以简单说一说。先看一下这个类的继承关系图：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524200353650-538894986.png" alt="img"></p><p>清晰看到Map类的位置。</p><p>有趣的是，Map有WebMap和WebScene两个子类，由于继承和多态的特征，说明视图中map属性也可以设为WebMap和WebScene。</p><p>这有什么区别呢？暂且不说后期展开。</p><p>再展开Map类的属性：</p><p><img src="https://images2018.cnblogs.com/blog/1097074/201805/1097074-20180524205007659-924807109.png" alt="img"></p><p>常用的有三个属性，底图、可操作图层集合、地形图层。</p><ol><li>basemap属性可使用预置的底图，也可以使用自定义的Basemap对象；</li><li><strong>[★]</strong>layers属性是<strong>可操作的Layer对象</strong>的集合，Layer类有很多子类，如几何图层、地图图层、要素图层等，这些到以后会讲，这些<strong>都是赤果果的数据组成啊</strong>！</li><li>ground属性表示地图高程，可以用预置的世界高程数据，也可以自定义高程图层，后期会讲。</li></ol><p>哦对了，对<strong>数据的在线简单编辑、绘制</strong>，也是由数据部分组织的，后面展开。</p><h2 id="2-2-视图有什么用"><a href="#2-2-视图有什么用" class="headerlink" title="2.2 视图有什么用"></a>2.2 视图有什么用</h2><p>视图是管理“看得到”的东西的。</p><p>其一，我们看得到的二三维地图、场景都是由它渲染的；</p><p>其二，我们需要对数据进行展示时，是由它进行弹窗（Popup）展示的；</p><p>这些业务和数据无关，任何一份数据都可以由视图进行前端渲染、数据展示，所以被抽取出来了，做到了高内聚低耦合、数据视图分离。</p><hr><p>好啦，到这里，“数据”与“视图”已经有了个大概的了解了，下一篇将开始讲解如何代码入门，可以学一下Dojo用于预习，尤其是Dojo的模块化。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcGIS </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArcGIS API for JavaScript 入门教程(2)-授人以渔</title>
      <link href="/2019/04/09/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-2-%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94/"/>
      <url>/2019/04/09/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-2-%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94/</url>
      
        <content type="html"><![CDATA[<p>这篇仍然不讲怎么做，但是我要告诉你如何获取资源。</p><h1 id="1-官方在线帮助、示例代码及入门导航"><a href="#1-官方在线帮助、示例代码及入门导航" class="headerlink" title="1. 官方在线帮助、示例代码及入门导航"></a>1. 官方在线帮助、示例代码及入门导航</h1><p>JsAPI最新版首页：<a href="https://developers.arcgis.com/javascript/" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/</a></p><p>JsAPI最新版在线帮助（模块查询）：<a href="https://developers.arcgis.com/javascript/latest/api-reference/index.html" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/latest/api-reference/index.html</a></p><p>JsAPI最新版示例代码：<a href="https://developers.arcgis.com/javascript/latest/sample-code/index.html" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/latest/sample-code/index.html</a></p><p>JsAPI最新版入门导航：<a href="https://developers.arcgis.com/javascript/latest/guide/index.html" target="_blank" rel="noopener">https://developers.arcgis.com/javascript/latest/guide/index.html</a></p><h1 id="2-ArcGIS-Runtime-SDKs家族"><a href="#2-ArcGIS-Runtime-SDKs家族" class="headerlink" title="2. ArcGIS Runtime SDKs家族"></a>2. ArcGIS Runtime SDKs家族</h1><p>地址：<a href="https://developers.arcgis.com/" target="_blank" rel="noopener">https://developer.arcgis.com</a></p><p>文档：<a href="https://developers.arcgis.com/documentation/" target="_blank" rel="noopener">https://developers.arcgis.com/documentation/</a></p><p>Github地址：<a href="http://esri.github.io/" target="_blank" rel="noopener">http://esri.github.io/</a></p><p>文档处也有很多好东西，有机会也要做翻译。</p><h1 id="3-获取API和SDK"><a href="#3-获取API和SDK" class="headerlink" title="3. 获取API和SDK"></a>3. 获取API和SDK</h1><p>Runtime SDK家族API和SDK和文档：<a href="https://developers.arcgis.com/downloads/apis-and-sdks" target="_blank" rel="noopener">https://developers.arcgis.com/downloads/apis-and-sdks</a></p><h1 id="4-善用搜索引擎"><a href="#4-善用搜索引擎" class="headerlink" title="4. 善用搜索引擎"></a>4. 善用搜索引擎</h1><p>如果百度/必应不到，请用谷歌，总有你需要的。</p><p>——————————————————————————</p><p>最后说个事，教程和笔记</p><p>好多人混淆了教程和笔记。教程是力求别人能看懂，尽可能抓重点和抓主干讲，无关痛痒的不要讲太多。所以，此入门教程，我打算10来篇博客讲完，细致的可以自己慢慢学的，毕竟更新如此之快，我自己也在不断学习。</p><p>而笔记，自己看得懂就行了，好多人挂着教程写的笔记哦…笔记是自己反复琢磨用的。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcGIS </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArcGIS API for JavaScript入门教程(1)-前戏</title>
      <link href="/2019/04/07/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-1-%E5%89%8D%E6%88%8F/"/>
      <url>/2019/04/07/ArcGIS-API-for-JavaScript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-1-%E5%89%8D%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>-&gt;对于萌新，你可能需要了解一下这个东西是什么</li><li>-&gt;对于已经知道要用这个东西的开发者，你可能需要了解一下它的底层机制</li><li>不针对大牛。龟速更新ing.</li></ul></blockquote><h1 id="1-是什么【萌新别跳这一步】"><a href="#1-是什么【萌新别跳这一步】" class="headerlink" title="1. 是什么【萌新别跳这一步】"></a>1. 是什么【萌新别跳这一步】</h1><p><em>如果非萌新，可以跳过这一段文字。</em></p><p>想要知道ArcGIS API for JavaScript是什么，我大概用以下几条条目描述：</p><ul><li>是一个WebGIS二次开发（如果不知道什么是WebGIS请用搜索引擎···）的前端开发包，使用JavaScript语言</li><li>出自美国Esri公司</li><li>是Esri的ArcGIS Runtime SDK家族中的一员</li><li>它不是纯Js写的库</li></ul><p>能说明什么呢？</p><ol><li>它能制作在线地理信息系统平台，能做数据分析、空间分析、数据展示等；</li><li>歪果仁写的，英文资料多，虽然中文也有一定数量的资料（博客、书籍等），但是呢，由于Esri更新贼快，一年三四更的，中文资料不一定跟得上速度；</li><li>你可能需要学很多附属的东西，这个API很庞大、很笨重，入门门槛其实不高，但是深入难，前端上，你得知道造这个API的基础——Dojo框架，而Dojo框架由于历史渊源，又来自从属AMD（异步模块定义）规范的RequireJs，要想了解AMD，又不得不去看一些前端和后端的发展史，甚至不可避免要学一些基础的后端。</li></ol><p>如果你做好了这些准备，继续。</p><p>哦对了，这个API当前有两个大支线，一个是3.x版本，一个是4.x版本；</p><p>3.x版本已经很成熟，用于2D的WebGIS二次开发很完美，如果你用的是ArcGIS整套产品；</p><p>我重点讲一下类和模块经过重新构造、较为简单的4.x版本，因为它最大的特征是数据视图分离、支持3D，旗帜鲜明对接ArcGIS Pro.</p><h1 id="2-我必须学它吗？"><a href="#2-我必须学它吗？" class="headerlink" title="2. 我必须学它吗？"></a>2. 我必须学它吗？</h1><p>如果你的项目需求很大，大量用到空间分析、三维展示，频繁交互ArcGIS家族的产品（Server、ArcGIS Desktop等），请学；</p><p>如果你的项目需求比较小，也可以学，当然也可以有别的选择：</p><ul><li>开源解决方案：Openlayers/Leaflets替代JsAPI。</li></ul><p>Openlayers和Leaflets同样是WebGIS二次开发工具包，排名很靠前，二者区别是ol自己提供了封装好的功能模块，而lf则支持插件式，它的插件很多。他们都支持npm方式引入。</p><ul><li>当然，为了实现简单的三维GIS，Cesium了解一下；</li><li>如果只是3D数据展示，ThreeJs了解一下；</li><li>如果数据源缺乏，不想自己做数据服务，对WebGIS标准缺少耐心，可以试试高德地图API、百度地图API等。</li><li>如果想全开源，就目前而言3DGIS还是ArcGIS最强外，传统二维WebGIS可以用QGIS代替ArcGIS Desktop、用PostgreSQL代替Geodatabase、用GeoServer代替ArcGIS for Server。</li></ul><p>使用JsAPI最强大的特征就是真三维空间分析+无比强大的ArcTools工具箱了。</p><h1 id="3-学习此API需要些什么"><a href="#3-学习此API需要些什么" class="headerlink" title="3. 学习此API需要些什么"></a>3. 学习此API需要些什么</h1><p>熟练HTML 5的学习方式、熟练CSS 3的学习方式、能自我学习JavaScript，最好有一定的GIS基础知识、一定的数学知识。</p><p>我们在这里约定</p><p>ArcGIS API for JavaScript = jsapi/JsAPI/jsAPI…</p><p>你可能还要学习的是：</p><ul><li>NodeJs与npm（在4.7及3.24版本后可能要用npm下载）——作备选项，不学也无所谓</li><li>webpack——上面那俩如果你学了，这个肯定要学了。</li><li>英语</li></ul><p>对了，你不需要学怎么配置本地环境（就是说用官方的在线API进行学习就好了），我觉得那些东西网上太多了，查一下就行。有可能遇到跨域的问题，你也可以问搜索引擎，这里更关注的是“入门”而不是全面、细节，我需要把你快速带入门，之后看你的造化。</p><h1 id="4-它怎么来的"><a href="#4-它怎么来的" class="headerlink" title="4. 它怎么来的"></a>4. 它怎么来的</h1><p>它基于一个更复杂的前端框架，Dojo.js。</p><p>除了当前两条支线3.x和4.x，其实早些年还有过ArcGIS API for Sliverlight和ArcGIS API for Flex，当然他们已经退休了。</p><p>JavaScript那么火热，自然而然选他啦。</p><p>由于GIS数据模型的复杂性，和普通的Web信息系统不同，面向对象的机制更合适去描述GIS数据和GIS分析。当时，没有别的好选择，只能选Dojo，因为它支持许多符合WebGIS的特性，如异步操作、面向对象等。</p><p>现如今，基于Node的包管理模式的前端开发早已不是什么难事，甚至还冒出了MVVM框架的一大堆火热框架。老迈的Dojo框架不能很好地融入其中，这让人很无奈。</p><p>在JsAPI中，地图可以是一个模块，图层可以是一个模块，一个用于空间分析的“东西”也可以是一个模块。类似于桌面编程中的类、继承机制，AMD规范下的RequireJs就产生了。Dojo基于此，定制了一大批的有用模块，能做图表，能做页面，能读写DOM，能做动画，当然是你需要什么模块就调用什么模块，并不需要一次性全部加载。JsAPI基于Dojo，定制了各个方面的模块，从而向开发者提供了一套强大的WebGIS二次开发包。</p><p>——————————</p><p>好了，可以开始讲了。</p><p>哦对了，我学的也不深，请不要用教程二字绑架我，认为我什么都会，我也在学习，希望一起交流，一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArcGIS </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何重装系统</title>
      <link href="/2019/04/06/%E5%A6%82%E4%BD%95%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/04/06/%E5%A6%82%E4%BD%95%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来我是不想写这篇文章的<del>因为懒</del>。</p><p>但是有鉴于最近<strong>找我装系统的人太多</strong>了，再加上看见小白被无良商家骗于心不忍，就写篇教程吧-_-。</p><p>我会把装机的主要几个阶段讲一下，但是任何跟着提示稍微理解下就可以无风险走的小步骤就不讲了。</p><h2 id="装系统之前的准备"><a href="#装系统之前的准备" class="headerlink" title="装系统之前的准备"></a>装系统之前的准备</h2><p>首先要有个概念 <code>装系统是一件很简单的事</code>。电脑是一件给人用的 <strong>工具</strong> ，厂商没有理由设置门槛。装机是很简单的，<strong>但是最好不要随意重装系统，文件、软件重新安置太麻烦了</strong>。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ul><li>物理准备<ul><li>一只8G以上U盘</li></ul></li><li>心理准备<ul><li>一小时不到的时间</li><li>一定的理解能力</li></ul></li></ul><h2 id="装机阶段"><a href="#装机阶段" class="headerlink" title="装机阶段"></a>装机阶段</h2><ol><li><p>找到你所用电脑的<strong>主板</strong>厂商（<em>不需要拆机箱，直接用aida64或者别的软件看</em>）以及<strong>型号</strong>，如果是笔记本就直接使用<strong>电脑型号</strong>。</p></li><li><p>搜索 xxxx（<em>你的主板型号</em>） 进入bios的<strong>快捷键</strong>，并记住它。</p></li><li><p>在<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">msdn 我告诉你</a>，这个网站上找到你要装的系统的 <strong>64位</strong> <strong>最新版本</strong>。</p></li><li><p>下载它。</p></li><li><p><strong>格式化</strong>U盘。</p></li><li><p>把下载的镜像文件用解压软件<strong>解压到U盘</strong>。</p></li><li><p><strong>备份c盘里的文件</strong>，其它盘看你想不想顺便格式化。</p></li><li><p>重启，并在开机的过程中<strong>狂按</strong>你记住的<strong>快捷键</strong>。</p></li><li><p>你将会进入一个蓝蓝白白的界面（bios），请动用你的英语水平进行翻译后使用。</p></li><li><p>你有两个选择</p><ul><li>UEFI路线<ol><li>找到<strong>boot</strong>里面的<strong>UEFI</strong>设置为<strong>ENABLE</strong></li><li><strong>重启</strong>，开机过程中<strong>狂按</strong>快捷键</li><li>会看见弹出一个<strong>对话框</strong>，选择 <strong>WINDOWS</strong> <strong>BOOT</strong> <strong>MANAGER</strong></li></ol></li><li>传统路线<ol><li>找到<strong>boot</strong>里面的<strong>启动顺序</strong></li><li>按照操作指示，把<strong>U盘</strong>放到最上面</li><li>重启</li></ol></li></ul></li><li><p>在Windows安装指示界面中，按照指示</p><p>操作</p><p>进行操作</p><ul><li>分区格式化请<strong>谨慎</strong></li></ul></li><li><p>开机后联网会<strong>自动</strong>安装驱动</p></li><li><p>在你的显卡的对应官网下载安装<strong>显卡驱动</strong></p></li><li><p>在设备管理器中查看有无设备上有<strong>感叹号标识</strong>，若有，去官网下载驱动。</p></li><li><p>是否安装</p><p>360、驱动大师等软件自行判断</p><ul><li>我推荐ccleaner、火绒</li></ul></li><li><p>重启进入bios，把设置还原为改动之前的</p></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>简单的电脑维护其实很简单(<del>废话</del>)，只要不<strong>先入为主</strong>地认为自己不会，<strong>善用搜索引擎</strong>，不懂的东西<strong>稍微研究</strong>一下，一般都没有问题的。</p><p><strong>如果看完本文仍觉得无从下手的话，可以联系QQ:244675854提供技术支持（收辛苦费20~30呦！），嘻嘻</strong></p><blockquote><p>我不对任何本文后果负责，还请读者们自行判断。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重装系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键激活window &amp; office</title>
      <link href="/2019/04/06/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow-office/"/>
      <url>/2019/04/06/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow-office/</url>
      
        <content type="html"><![CDATA[<h1 id="一键激活windows-amp-office"><a href="#一键激活windows-amp-office" class="headerlink" title="一键激活windows&amp;office"></a>一键激活windows&amp;office</h1><p>自建的激活服务器，可以一键激活VOL版的window和office。</p><p>推荐去<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a> 下载安装正版的window和office。</p><h2 id="单击下载-一键激活window-amp-office-bat"><a href="#单击下载-一键激活window-amp-office-bat" class="headerlink" title="单击下载 一键激活window&amp;office.bat"></a>单击下载 <a href="https://tohot.top/download/%E4%B8%80%E9%94%AE%E6%BF%80%E6%B4%BBwindow&amp;office.bat" target="_blank" rel="noopener">一键激活window&amp;office.bat</a></h2>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何开发一个用户脚本系列——脚本1:视频跳过广告和 VIP 视频解析</title>
      <link href="/2019/04/06/%E8%A7%86%E9%A2%91%E8%B7%B3%E8%BF%87%E5%B9%BF%E5%91%8A%E5%92%8CVIP%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/04/06/%E8%A7%86%E9%A2%91%E8%B7%B3%E8%BF%87%E5%B9%BF%E5%91%8A%E5%92%8CVIP%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在这篇文章中，我们一起学习脚本 <strong>视频跳过广告和 VIP 视频解析</strong> 的开发。这也是本系列文章的最后一篇，希望完成这个系列的学习之后，你能够掌握编写脚本的方法。在正式开始之前，先说一下我认为开发脚本应该遵循的两个准则:</p><ul><li>功能实现。当你决定要开发一个脚本的时候，你肯定清楚你的脚本要实现什么功能，只有你的脚本实现了你所描述的功能，才会有更多的人安装使用，才会有更多的人给你好评；</li><li>样式实现。什么叫样式实现？就是你在目标网站中添加的元素，要尽量与原网站的配色，样式相一致。这一项是非必须的，但我认为是非常重要的。你想想，如果原网站整体是蓝色，而你添加的按钮是红色，那该有多突兀，有多丑，虽然你的按钮确实突出了，但别人一看就是山寨，看着会很不舒服。而如果你的按钮也用它网站的颜色，这样就会跟原网站已有的元素契合，整体特别自然，做到以假乱真的效果。你的脚本让别人用的舒服，别人才更愿意给你好评。</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>我们在日常闲暇时间都会看点视频娱乐一下，而现在各大视频网站都推出了会员体系，一个视频网站的年费会员往往需要 200 块左右。然而我们想看的电视剧，电影，通常都不在一个平台上，导致我们就需要开通各个网站的会员。一个网站还好，但多个网站叠加起来，这笔钱也不少。所以有没有什么方法能够不需要开通各个网站的会员就可以看想看的视频呢？网上现在有一些免费公开的接口提供这种解析服务，只需要将视频播放页面的地址作为参数传给接口，接口就能完成解析，然后播放视频。但我们每次都复制视频播放地址给接口，也会很麻烦，这时候就可以写个脚本，在这些视频网站上添加一个按钮，当用户点击按钮的时候，自动获取到当前页面的播放地址，然后传给接口解析播放。HTML 中有个 <code>iframe</code> 标签，可以用来在当前页面中嵌入其他网页，所以使用 <code>iframe</code> 标签就能够实现在原视频网站站内解析播放视频，体验很好。在某视频网站上的效果如下图:<br><a href="https://mofiter-blog.oss-cn-hangzhou.aliyuncs.com/images/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%84%9A%E6%9C%AC6-1.png" target="_blank" rel="noopener"><img src="https://mofiter-blog.oss-cn-hangzhou.aliyuncs.com/images/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%84%9A%E6%9C%AC6-1.png" alt="img"></a></p><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>视频的解析都是解析接口实现的，脚本本身并不进行视频解析。所以解析接口是否稳定，是否有较高的成功率是很关键的。现在网上有很多解析接口，本文只提供 <a href="https://api.bbbbbb.me/" target="_blank" rel="noopener">思古解析</a>(用于站内解析)和 <a href="http://www.1717yun.com/" target="_blank" rel="noopener">1717yun解析</a>(用于站外解析)作为示例，同时由于视频网站很多，所以本文只选择 <a href="https://v.qq.com/" target="_blank" rel="noopener">腾讯视频</a> 作为运行脚本的示例。腾讯视频某一个视频的具体播放地址形式为 <code>https://v.qq.com/x/cover/xxx</code>，用 <code>@match</code> 匹配。在脚本编写过程中会用到 jQuery，使用 <code>@require</code> 引入 jQuery 库。站外解析需要在新 tab 页中打开链接，所以需要脚本管理器的 <code>GM_openInTab()</code> 函数，我们用 <code>@grant</code> 声明(为了兼容 Greasemonkey，我们还要声明它的函数 <code>GM.openInTab</code>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy// @require           https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js</span><br><span class="line">// @match             *://v.qq.com/x/cover/*</span><br><span class="line">// @grant             GM_openInTab</span><br><span class="line">// @grant             GM.openInTab</span><br></pre></td></tr></table></figure><p>通过观察原网站可知，功能菜单都是在视频播放窗口下面，当鼠标放在功能按钮上面时，会显示功能面板，当鼠标移出功能按钮时，功能面板隐藏。所以我们将解析按钮加到功能菜单里面，将各个接口添加到功能面板，这样就可以选择不同的接口进行解析，同时使用原网站的样式风格。我们使用一个数组保存接口信息，这样方便遍历添加。由于安全问题，以 https 开头的视频网站内部不能使用 http 开头的接口，所以我们利用接口类型字段来标识接口是用来进行站内解析还是站外解析，如果是站内解析，它应该以 https 开头，如果接口以 http 开头，只能用来站外解析。我们希望将所有的接口以一个列表的形式呈现，所以我们把它放在一个 <code>&lt;ul&gt;</code> 标签里，然后每一个接口放在一个 <code>&lt;li&gt;</code> 标签里面。我们创建一个 <code>&lt;div&gt;</code> 标签，在里面添加一个 <code>&lt;iframe&gt;</code> 标签，用来加载解析结果的网页。在后面进行站内解析的时候，我们用这个 <code>&lt;div&gt;</code> 替换原视频网站播放窗口里面的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copyvar originalInterfaceList = [&#123;&quot;name&quot;:&quot;思古解析&quot;,&quot;type&quot;:&quot;站内&quot;,&quot;url&quot;:&quot;https://api.bbbbbb.me/jx/?url=&quot;&#125;,</span><br><span class="line">                             &#123;&quot;name&quot;:&quot;1717yun解析&quot;,&quot;type&quot;:&quot;站外&quot;,&quot;url&quot;:&quot;http://www.1717yun.com/jx/ty.php?url=&quot;&#125;];</span><br><span class="line">    var parseList = &quot;&lt;ul&gt;&quot;;</span><br><span class="line">    parseInterfaceList.forEach((item,index)=&gt;&#123;</span><br><span class="line">        parseList += &quot;&lt;li&gt;&quot; + item.name + &quot;(&quot; + item.type + &quot;)&lt;/li&gt;&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    parseList += &quot;&lt;/ul&gt;&quot;;</span><br><span class="line">    var videoPlayer = $(&quot;&lt;div id=&apos;iframe-div&apos; style=&apos;width:100%;height:100%;z-index:2147483647;&apos;&gt;&lt;iframe id=&apos;iframe-player&apos; frameborder=&apos;0&apos; allowfullscreen=&apos;true&apos; width=&apos;100%&apos; height=&apos;100%&apos;&gt;&lt;/iframe&gt;&lt;/div&gt;&quot;);</span><br></pre></td></tr></table></figure><p>准备好解析接口和要替换的内容之后，我们就要去原网站添加解析按钮，并添加点击事件，在点击事件里面，替换播放窗口的内容。通过 <code>location.href</code> 能拿到当前页面的 url，我们使用 <code>indexOf()</code> 方法查看 <code>v.qq.com</code> 的索引值，如果索引值大于 -1 说明当前匹配的网站是腾讯视频，我们再进行处理。我们使用 jQuery 获取到功能菜单的父元素，然后创建解析按钮元素，将解析按钮添加到功能菜单父元素。给解析按钮添加鼠标移入移出操作，来显示和隐藏接口列表的功能面板。在每一个解析接口上面添加点击操作，判断被点击的 <code>&lt;li&gt;</code> 标签的接口类型，如果是站内解析，则替换播放窗口的内容，如果是站外解析，则打开一个新的页面显示解析链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copyif(location.href.indexOf(&quot;v.qq.com&quot;) &gt; -1)&#123;</span><br><span class="line">        var action_wrap = $(&quot;.action_wrap&quot;);</span><br><span class="line">        var qq_jiexi = $(&quot;&lt;div id=&apos;qq-jiexi-btn&apos; class=&apos;action_item action_jiexi&apos; style=&apos;position:relative;&apos;&gt;&lt;a class=&apos;action_title fn-qq-jiexi-text&apos;&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/a&gt;&lt;div class=&apos;mod_pop_action fn-qq-jiexi&apos; style=&apos;background-color:#fff;width:120px;left:-50px;text-align:center;line-height:25px;&apos;&gt;&quot; + parseList + &quot;&lt;/div&gt;&lt;/div&gt;&quot;);</span><br><span class="line">        action_wrap.append(qq_jiexi);</span><br><span class="line">        document.getElementById(&quot;qq-jiexi-btn&quot;).addEventListener(&quot;mouseover&quot;,()=&gt;&#123;</span><br><span class="line">            $(&quot;.action_jiexi&quot;).toggleClass(&quot;open&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        document.getElementById(&quot;qq-jiexi-btn&quot;).addEventListener(&quot;mouseout&quot;,()=&gt;&#123;</span><br><span class="line">            $(&quot;.action_jiexi&quot;).toggleClass(&quot;open&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        $(&quot;.fn-qq-jiexi li&quot;).each((index,item)=&gt;&#123;</span><br><span class="line">            item.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">                if(parseInterfaceList[index].type == &quot;站内&quot;)&#123;</span><br><span class="line">                    if(document.getElementById(&quot;iframe-player&quot;) == null)&#123;</span><br><span class="line">                        var txp_ad_skip_text = $(&quot;.txp_ad_inner .txp_ad_skip_text&quot;);</span><br><span class="line">                        if(txp_ad_skip_text.text() === &quot;VIP可关闭广告&quot;)&#123;</span><br><span class="line">                            txp_ad_skip_text.click();</span><br><span class="line">                            mod_player = $(&quot;#mod_player&quot;);</span><br><span class="line">                            mod_player.empty();</span><br><span class="line">                            mod_player.append(videoPlayer);</span><br><span class="line">                        &#125;else if(txp_ad_skip_text.text() === &quot;关闭广告&quot;)&#123;</span><br><span class="line">                            txp_ad_skip_text.click();</span><br><span class="line">                        &#125;else if(vipPage === true)&#123;</span><br><span class="line">                            var txp_btn_play = $(&quot;.txp_left_controls .txp_btn_play&quot;);</span><br><span class="line">                            if(txp_btn_play.attr(&quot;data-status&quot;) === &quot;pause&quot;)&#123;</span><br><span class="line">                                txp_btn_play.click();</span><br><span class="line">                            &#125;</span><br><span class="line">                            mod_player = $(&quot;#mod_player&quot;);</span><br><span class="line">                            mod_player.empty();</span><br><span class="line">                            mod_player.append(videoPlayer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    innerParse(parseInterfaceList[index].url + location.href);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    GMopenInTab(parseInterfaceList[index].url + location.href,false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function innerParse(url)&#123; // 站内解析</span><br><span class="line">    $(&quot;#iframe-player&quot;).attr(&quot;src&quot;,url);</span><br><span class="line">&#125;</span><br><span class="line">function GMopenInTab(url,open_in_background)&#123; //站外解析</span><br><span class="line">    if(typeof GM_openInTab === &quot;function&quot;)&#123; // Tampermonkey 和 Violentmonkey 调用 GM_openInTab</span><br><span class="line">        GM_openInTab(url,open_in_background);</span><br><span class="line">    &#125;else&#123; // Greasemonkey GM.openInTab</span><br><span class="line">        GM.openInTab(url,open_in_background);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此腾讯视频的解析差不多就完成了，还有些细节和用户体验方面的东西代码里面有写，这里就不再赘述了。其他视频网站的处理和腾讯视频的原理是一样的，都是添加解析按钮，然后给解析按钮添加点击事件，进行站内或站外解析。</p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何开发用户脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/06/hello-world/"/>
      <url>/2019/04/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>极限与导数</title>
      <link href="/2019/04/03/%E6%9E%81%E9%99%90%E4%B8%8E%E5%AF%BC%E6%95%B0/"/>
      <url>/2019/04/03/%E6%9E%81%E9%99%90%E4%B8%8E%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>最近学了一些基础微积分，这里稍微记录一下。</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>极限可以当做是一个函数f(x)f(x)的xx无限趋近于某一个常数或无穷远处时，函数数值所逼近的一个值。 例如，对于函数<br>$$<br>f(x)=2xx+1f(x)=2xx+1<br>$$<br>，当xx趋近于无穷大时，f(x)f(x)无限趋近于22。我们将此记成这样子：</p><p>$$<br>limx→∞f(x)=limx→∞2xx+1=2limx→∞f(x)=limx→∞2xx+1=2<br>$$</p><p>求极限需要会一点代数技巧，我反正是老是求不出……</p><p>极限有一些方便的性质：<br>当然，这些等式的左边都是存在极限的。</p><p>$$<br>limx→ca⋅f(x)=a⋅limx→cf(x)limx→ca⋅f(x)=a⋅limx→cf(x)<br>$$</p><p>对于两个函数f(x)f(x)和g(x)g(x)之间极限的关系：（当然f(x)f(x)和g(x)g(x)都要存在极限）</p><p>$$<br>limx→c[f(x)+g(x)]=limx→cf(x)+limx→cg(x)limx→c[f(x)+g(x)]=limx→cf(x)+limx→cg(x)<br>$$</p><p>$$<br>limx→c[f(x)−g(x)]=limx→cf(x)−limx→cg(x)limx→c[f(x)−g(x)]=limx→cf(x)−limx→cg(x)<br>$$</p><p>$$<br>limx→cf(x)⋅g(x)=limx→cf(x)⋅limx→cg(x)limx→cf(x)⋅g(x)=limx→cf(x)⋅limx→cg(x)<br>$$</p><p>$$<br>limx→cf(x)g(x)=limx→cf(x)limx→cg(x)(limx→cg(x)≠0)limx→cf(x)g(x)=limx→cf(x)limx→cg(x)(limx→cg(x)≠0)<br>$$<br>简而言之，极限这东西可以加减乘除。</p><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>对于函数f(x)f(x)而言，它在x0x0处的导数是这么定义的：</p><p>$$<br>limΔx→0f(x0+Δx)−f(x0)ΔxlimΔx→0f(x0+Δx)−f(x0)Δx<br>$$</p><p>从几何意义上讲，这个值可以视为是f(x)f(x)的图像在x0x0处的切线的斜率。 当然不是所有的函数都是可以求导数的，只有在那一段上是连续的函数时，才会有导数。<br>连续的函数f(x)f(x)在其定义域内的每一点上都可以计算导数，意味着每一个xx都会对应一个导数，这样就形成了一个函数关系。我们将这个函数叫作导函数，记作f′(x)f′(x)。</p><p>如何求导函数呢？根据导数的定义，我们将x0x0换为xx，然后求极限就好了。然而说的轻巧，实际上很多都比较难以求出，因此早有先人为我们把各种导函数算好了。</p><p>举一个典型的例子<br>$$<br>f(x)=x2f(x)=x2<br>$$<br>。按照求导数的方法：</p><p>$$<br>f′(x)=limΔx<br>$$<br>$$<br>→0f(x+Δx)−f(x)Δx=limΔx<br>$$<br>$$<br>→0(x+Δx)2−x2Δx=limΔx<br>$$<br>$$<br>→0Δx2+2xΔxΔx=limΔx<br>$$<br>$$<br>→0(Δx+2x)=2xf′(x)=limΔx<br>$$<br>$$<br>→0f(x+Δx)−f(x)Δx=limΔx<br>$$<br>$$<br>→0(x+Δx)2−x2Δx=limΔx<br>$$<br>$$<br>→0Δx2+2xΔxΔx=limΔx<br>$$<br>$$<br>→0(Δx+2x)=2x<br>$$</p><p>事实上，对于幂函数<br>$$<br>f(x)=xαf(x)=xα，其导函数为，其导函数为<br>$$<br>，其导函数为<br>$$<br>f′(x)=αxα−1f′(x)=αxα−1<br>$$<br>。</p><p>导数与导数之间存在运算关系，有了这些运算关系，我们就可以方便地进行求导。<br>类似于线性的性质：<br>$$<br>[a⋅f(x)+b⋅g(x)]′=a⋅f′(x)+b⋅g′(x)[a⋅f(x)+b⋅g(x)]′=a⋅f′(x)+b⋅g′(x)<br>$$</p><p>两个导数相乘：<br>$$<br>[f(x)g(x)]′=f′(x)g(x)+f(x)g′(x)[f(x)g(x)]′=f′(x)g(x)+f(x)g′(x)<br>$$</p><p>两个导数相除：<br>$$<br>[f(x)g(x)]′=f′(x)g(x)−f(x)g′(x)g2(x)(g(x)≠0)[f(x)g(x)]′=f′(x)g(x)−f(x)g′(x)g2(x)(g(x)≠0)<br>$$</p><p>复合函数：<br>$$<br>[f(g(x))]′=f′(g(x))⋅g′(x)[f(g(x))]′=f′(g(x))⋅g′(x)<br>$$</p><p>一些基本函数的导函数就放这里了，当我们要求一个特定函数的导函数时，可以利用上面的规则，然后根据导函数表来计算。下面只有xx是变量。<br>$$<br>c′=0c′=0<br>$$</p><p>$$<br>x′=1x′=1<br>$$</p><p>$$<br>(xα)′=αxα−1(xα)′=αxα−1<br>$$</p><p>$$<br>(ex)′=ex(ex)′=ex<br>$$</p><p>$$<br>(ax)′=axlna(ax)′=axln⁡a<br>$$</p><p>$$<br>(lnx)′=1x(ln⁡x)′=1x<br>$$</p><p>$$<br>(logax)′=1xlna(loga⁡x)′=1xln⁡a<br>$$</p><p>$$<br>sin′x=cosxsin′⁡x=cos⁡x<br>$$</p><p>$$<br>cos′x=−sinxcos′⁡x=−sin⁡x<br>$$</p><p>$$<br>tan′x=1cos2xtan′⁡x=1cos2⁡x<br>$$</p><p>$$<br>cot′x=−1sin2xcot′⁡x=−1sin2⁡x<br>$$</p><h2 id="对数求导法"><a href="#对数求导法" class="headerlink" title="对数求导法"></a>对数求导法</h2><p>上面的求导公式已经能够应对大部分基本函数的求导了，但是对于下面的函数：<br>$$<br>f(x)=x1/xf(x)=x1/x<br>$$<br>该如何求导呢？<br>这就要用到对数来进行求导。</p><p>我们知道，对于一个函数f(x)f(x)：<br>$$<br>[lnf(x)]′=ln′f(x)⋅f′(x)[ln⁡f(x)]′=ln′⁡f(x)⋅f′(x)<br>$$</p><p>换言之：<br>$$<br>f′(x)=[lnf(x)]′ln′f(x)(1)(1)f′(x)=[ln⁡f(x)]′ln′⁡f(x)<br>$$<br>利用这一点，我们就可以对<br>$$<br>f(x)=x1/xf(x)=x1/x<br>$$<br>求导。 首先，为了方便我们设：<br>$$<br>y=x1/xy=x1/x<br>$$<br>由于两者相等，所以两者的对数也应相等：<br>$$<br>lny=lnx1/x=1xlnxln⁡y=ln⁡x1/x=1xln⁡x<br>$$</p><p>将两边对xx求导。注意按照(1)(1)式，左式需要乘上y′y′两者才能相等。<br>$$<br>y′y=1−lnxx2y′y=1−ln⁡xx2<br>$$</p><p>于是我们可以得到：<br>$$<br>y′=1−lnxx2y=1−lnxx2x1/x=f′(x)y′=1−ln⁡xx2y=1−ln⁡xx2x1/x=f′(x)<br>$$</p><p>这样我们就完成了求导。<br>既然都对这个函数求过导了，我们来验证一下它的一个性质。<br>将ee代入导函数：<br>$$<br>f′(e)=1−lnee2e1/e=1−1e2=0f′(e)=1−ln⁡ee2e1/e=1−1e2=0<br>$$</p><p>因此我们发现<br>$$<br>x=ex=e<br>$$<br>是这个函数的极值点。</p>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极限 </tag>
            
            <tag> 导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统结构</title>
      <link href="/2019/04/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/03/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>在 Linux 操作系统, 我们是看不到这些驱动器盘符, 而是文件夹(目录):</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g1poi8yj5tj30ku07ndhn.jpg" alt="Linux文件目录示意图"><br>​                                <strong><em>Linux文件目录示意图</em></strong></p><p>Ubuntu 没有盘符概念, 只有一个根目录 <strong>/</strong>, 所有文件都在它下面.</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g1poizwgvjj30ip0bfaa7.jpg" alt="Linux 目录结构示意图"></p><p>​                                <strong><em>Linux 目录结构示意图</em></strong></p><h3 id="Linux-主要目录速查表"><a href="#Linux-主要目录速查表" class="headerlink" title="Linux 主要目录速查表"></a>Linux 主要目录速查表</h3><ul><li><p>/：根目录，</p><p>一般根目录下只存放目录</p><p>，在 linux 下有且只有一个根目录，所有的东西都是从这里开始</p><ul><li>当在终端里输入 <code>/home</code>，其实是在告诉电脑，先从 <code>/</code>（根目录）开始，再进入到 <code>home</code> 目录</li></ul></li><li><p>/bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等</p></li><li><p>/boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：<code>/boot/vmlinuz</code>，系统引导管理器：<code>/boot/grub</code></p></li><li><p>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom /mnt</code></p></li><li><p>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有</p><ul><li>/etc/inittab</li><li>/etc/fstab</li><li>/etc/init.d</li><li>/etc/X11</li><li>/etc/sysconfig</li><li>/etc/xinetd.d</li></ul></li><li><p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下</p><ul><li><code>~</code> 表示当前用户的家目录</li><li><code>~edu</code> 表示用户 <code>edu</code> 的家目录</li></ul></li><li><p>/lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</p></li><li><p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</p></li><li><p>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载</p></li><li><p>/opt：给主机额外安装软件所摆放的目录</p></li><li><p>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等</p></li><li><p>/root：系统管理员root的家目录</p></li><li><p>/sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用</p></li><li><p>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下</p></li><li><p>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内</p></li><li><p>/usr：应用程序存放目录</p><ul><li>/usr/bin：存放应用程序可执行二进制文件的目录</li><li>/usr/share：存放共享数据</li><li>/usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</li><li>/usr/local：存放软件升级包</li><li>/usr/share/doc：系统说明文件存放目录</li><li>/usr/share/man：程序说明文件存放目录</li></ul></li><li><p>/var：放置系统执行过程中经常变化的文件</p><ul><li>/var/log：随时更改的日志文件</li><li>/var/spool/mail：邮件存放的目录</li><li>/var/run：程序或服务启动后，其 PID 存放在该目录下</li></ul></li></ul><p><strong>重点:</strong> <strong>/home/用户名</strong> 是用户的家目录.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Linux 和 Windows 文件系统的区别<br> 1.1 Linux 文件系统只有一个根目录(<strong>/</strong>)<br> 1.2 Windows 文件系统会有可能会有多个盘符(例如C、D、E…)</li><li><strong>/home/用户名</strong> 是用户的家目录, 是经常使用的目录.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥是人工智能</title>
      <link href="/2019/04/03/%E5%95%A5%E6%98%AF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
      <url>/2019/04/03/%E5%95%A5%E6%98%AF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZukIrsq7161xeGvkFcNun46boShNiatq5JZvqdjX5XjVlR6ToY48GAxQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>作者：武博士、宋知达、袁雪瑶、聂文韬</p></blockquote><p>本节我们会以生动有趣的漫画来介绍关于人工智能（AI）相关的故事，你将会学习到： <strong>人工智能的基本概念</strong></p><p><strong>1.1 啥是人工智能</strong><br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZWzSukZqmRVrdvVemO9siatS9tjtGR81eAGYv7NWSyWITibOOrTf2xK9w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>当有人问我，Dr.Wu 你的研究方向是什么？我回答：人工智能。 接着大约会得到以下四种问题： </p><p><strong>哇，好酷！是不是很难呢？</strong> </p><p><strong>是不是制造机器人帮助我们呢？</strong> </p><p><strong>AI和人工智能有什么区别？</strong> </p><p><strong>究竟啥是人工之智能？</strong> </p><p>接下来，我会带大家一一解惑。</p><p><strong>1.1.1 人的智慧和人工智能</strong></p><p>究竟什么是人工智能，什么是AI，接下来，由我为大家解答。 媒体上几乎每天都有AI和人工智能的词汇，总给人一种深奥神秘的感觉。人工智能顾名思义就是人类制造的智慧，英文叫Artificial Intelligence（AI），所以人工智能=AI。 </p><p>那么问题又来了，智慧究竟是什么？我们要以何种方式去制造智慧？要回答这个问题，就必须从人与人造物的 区别和人的智慧说起。 </p><p>对于人工智能的研究人员来说，目标并不是研究人类智慧的来源，而是以工程技术手段制造出类似人类智慧的 产品。  </p><p>人类和人工智能最大的差异是，肉体的有无。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZSbYzsu8L847X5pXuYGvEiaVvNfatNdYJBwXpzhE2JG29x9wSLnVpRuw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>人类可以通过身体获得外界资讯。透过感觉器官，我们可以感觉到声音、外观、触感、气味等，让我们觉得舒服或者讨厌，进而产生感情。 </p><p>不过人工智能并没有人类的身体，因此无法像人类一样通过肉体感觉器官来积累感觉经验，也无法借此获得知识。 </p><p>人工智能必须依赖人类，将人类通过鼻子、眼睛、嘴巴、皮肤…获得的外界资讯，以某种形式”输入“到人工智能，人工智能才可以加工和处理这些信息。 具体输入方式我们未来讨论。</p><p><strong>1.1.2 图灵测试：哪个一边是人？</strong></p><p>英国数学家，Dr.Wu 认为二十世纪最聪明的人三个人（爱因斯坦、图灵、冯诺依曼）之一，艾伦.图灵（Alan Turing：1912-1954）定义了一种方法，来判断人工智能是否成功，这种方法是：和自己对话的对象是人类还是人工智能？ </p><p>这种方法就是大名鼎鼎的图灵测试。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZZhXpn1212YWcQFkmNibWOfmjIC6gvgJPcb5TL2ykLTs2ykXX2CwRnAw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>只要三成以上的研究员将人工智能误以为是人类，就算通过图灵测试。 </p><p>但是由于计算机很难做到与人类接近的对话，所以很长一段时间都没有任何人工智能通过图灵测试。反而人类在不断学习计算机语言，这就是大量程序员的工作，和计算机对话。 </p><p>图灵测试又叫做模仿游戏‘Imitation Game’，一部描绘图灵一生的自传电影一样也叫模仿游戏，我觉得很好看哦。 Imitation 即为模仿。 </p><p>除了这部电影之外，《黑客帝国》、《终结者》、《全面进化》等描述人工智能的电影中，大多提到人工智能会威胁到人类生活，而不是给人类带来幸福，这让很多人谈到人工智能都会感到恐慌。 </p><p>但是，事实上，目前还没有做出公认通过图灵测试的人工智能。所以大家也不必恐慌哦。</p><p><strong>1.1.3 人工智能会思考吗？</strong></p><p>“思考”，大多数人会想到计算，应该是人工智能的专长。但事实上，要想像人类一样思考其实是一件非常困难的事情。 </p><p>人工智能需要以各种输入数据案例为基础，通过这些数据案例获取经验和知识，然后进行预测和判断。如果输入的案例太少，就无法做出判断。 情况相反，人类即使遇到过去未曾遇到的状况，也可以以弹性的方式面对各种状况。 </p><p>例如，人工智能需要看过上万张猫狗的图片才可以相对准确的识别猫狗图片，但是人类3岁左右的小朋友，只需要见过几次，就可以识别。差距还是巨大的。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZTfZic3rXM0eic33pYlPM6y45wP2gefKMfsysGPAgLShCPIOeqnIKgGGg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>但是，人类对于人类来说很难解决的问题，人工智能却能够迅速解决。例如：训练好的人工智能在图片识别过程中，效率远远高于人类，给他们10万张图片，他们会很快的为人类做好分类工作，无怨无悔，而且在工作过程中，人工智能本来的”智慧”也在提升。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ic1ub2G0IWkFlKxdD4FllSbibV5FvmSBAZic88PlEGsls1K27E2XaOIaylGaP5yicPeRlOIvPtQkwVQmrjFd0lyXbA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><br>我们将在未来的章节提到，目前具有一定“智能”的AI，可以用什么样的方式来解决什么样的问题。明白人工智能的擅长之处与不擅长之处，是未来社会我们能够幸福生活的关键。</p><p>（未完待续…）</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零基础15行python代码搞定网易云热门歌单</title>
      <link href="/2019/03/31/15%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E9%97%A8%E6%AD%8C%E5%8D%95/"/>
      <url>/2019/03/31/15%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E9%97%A8%E6%AD%8C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>健身、吃饭、敲代码；等车、撸猫、下午茶……若能佐以合适的音乐当“配餐”，总是惬意非常。本文就将带你爬一爬网易云的那些热门歌单！</p></blockquote><p>心情好或心情坏，点一首歌抚慰你受伤或躁动的心灵——下面教你用 15 行代码搞定热门歌单！</p><p>本文使用的是 Selenium 模块，它是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作，对于一些 JavaScript 渲染的页面来说，此种抓取方式非常有效。</p><p>采用了 Chrome 浏览器配合 Selenium 工作，本文的 Python 版本是 3.7.2。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h1><ol><li>若你的环境中没有 Selenium 模块，直接使用 pip 安装即可：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><ol start="2"><li><p>打开谷歌浏览器，检查Chrome的版本：在浏览器地址中输入 chrome://settings/help 回车即可看到：</p><p><img src="https://img.vim-cn.com/ac/4ed0c338deb650848bbc8e56ea2c6147b1bf17.png" alt="02.png"></p></li><li><p>打开 ChromeDriver 的官方网站（<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads），寻找与你当前浏览器版本相对应的" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads），寻找与你当前浏览器版本相对应的</a> ChromeDriver 下载：</p><p><img src="https://img.vim-cn.com/05/758873fffa1036762e388ecff28eead7b0be1f.png" alt="03.png"></p></li><li><p>选择你自己的操作系统类型进行下载即可：</p><p><img src="https://img.vim-cn.com/d1/7821da501ffe292bc5e376857e402582d194e0.png" alt="04.png"></p></li><li><p>以 Windows 为例，下载结束后，将 ChromeDriver 放置在 Python 安装目录下的 Scripts 文件夹即可：</p><p><img src="https://img.vim-cn.com/1b/5ca9231635c8c93f78b4c1a051573209cefdf6.png" alt="05.png"></p></li></ol><p>准备工作完成，代码写起来吧~</p><h1 id="迷你爬虫的实现"><a href="#迷你爬虫的实现" class="headerlink" title="迷你爬虫的实现"></a><strong>迷你爬虫的实现</strong></h1><p>我们这次的目标是爬取热门歌单，比如网易云音乐中播放量大于 1000万 的歌单信息（歌单名称、链接）。</p><ol><li><p>先来打开网易云的歌单第一页：    </p><p><a href="https://music.163.com/#/discover/playlist/" target="_blank" rel="noopener">https://music.163.com/#/discover/playlist/</a></p></li><li><p>使用 Chrome 的开发者工具 <f12> 进行分析：</f12></p><p><img src="https://img.vim-cn.com/f8/79c7e9ee5bb3083922c40acec3cf36cf3818ad.png" alt="02-2.png"></p></li></ol><p>我们想要拿的信息全在这里：</p><p>msk，封面 [mask]：有歌单的名称及链接</p><p>nb，播放数 [number broadcast]：135万</p><ol start="3"><li><p>我们还需要遍历所有的页，使用工具继续分析，找到“下一页”的 URL：</p><p><img src="https://img.vim-cn.com/d3/6bef2ed87892bb9d6d86935cc23cab4afb5c87.png" alt="02-3.png"></p></li><li><p>切换至最后一页，拿到最后一页的 URL：</p><p><img src="https://img.vim-cn.com/1f/9ec15c2bd641cce2ea5d1dbba8a3c8de3885c7.png" alt="02-4.png"></p></li><li><p>等我们爬取完所有符合的歌单信息后，将其保存在本地；</p></li><li><p>全部工作结束，最后再通过下面的伪代码回顾下整体思路：</p><p><img src="https://img.vim-cn.com/3f/b955a96ab865b20641f7498479a9a2441e3707.png" alt="02-6.png"></p></li><li><p>爬取的效果如下：</p><p><img src="https://img.vim-cn.com/46/826692648fd04b345d5754c9125e5f1ec9fe60.png" alt="02-7.png"></p></li></ol><p>另附源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网易云音乐歌单列表第一页地址</span></span><br><span class="line">url = <span class="string">'https://music.163.com/#/discover/playlist/?order=hot&amp;cat=%E5%85%A8%E9%83%A8&amp;limit=35&amp;offset=0'</span></span><br><span class="line"><span class="comment"># 用Chrome接口创建一个Selenium的WebDriver</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐页解析，直至歌单列表的最后一页</span></span><br><span class="line"><span class="keyword">while</span> url != <span class="string">'javacript:void(0)'</span>:</span><br><span class="line">    <span class="comment"># 用WebDriver加载页面</span></span><br><span class="line">    browser.get(url)</span><br><span class="line">    <span class="comment"># 切换至内容的iframe</span></span><br><span class="line">    browser.switch_to.frame(<span class="string">"contentFrame"</span>)</span><br><span class="line">    <span class="comment"># 定位歌单标签</span></span><br><span class="line">    data = browser.find_element_by_id(<span class="string">"m-pl-container"</span>).find_elements_by_tag_name(<span class="string">"li"</span>)</span><br><span class="line">    <span class="comment"># 解析当前页中所有的歌单详情</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="comment"># 获取歌单的播放量</span></span><br><span class="line">        num = data[i].find_element_by_class_name(<span class="string">"nb"</span>).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'万'</span> <span class="keyword">in</span> num <span class="keyword">and</span> int(num.split(<span class="string">'万'</span>)[<span class="number">0</span>]) &gt; <span class="number">1000</span>:</span><br><span class="line">            <span class="comment"># 获取播放量大于1000万的歌单封面</span></span><br><span class="line">            msk = data[i].find_element_by_css_selector(<span class="string">"a.msk"</span>)</span><br><span class="line">            <span class="comment"># 把歌单封面中的标题、链接以及播放量，存储在TXT文件中</span></span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"163playlist.txt"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">' '</span>.join([msk.get_attribute(<span class="string">'title'</span>), num, msk.get_attribute(<span class="string">"href"</span>)]) + <span class="string">'\n'</span> + <span class="string">'='</span> * <span class="number">50</span> + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment"># 定位'下一页'的URL</span></span><br><span class="line">    url = browser.find_element_by_css_selector(<span class="string">"a.zbtn.znxt"</span>).get_attribute(<span class="string">"href"</span>) </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结束调用</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
            <tag> 网易 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX初识</title>
      <link href="/2019/03/30/LaTeX%E5%88%9D%E8%AF%86/"/>
      <url>/2019/03/30/LaTeX%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>闲来无事，想起了自己当年的毕业论文，想拿来再次修改修改，看到网上很多专业人士都是使用LaTeX来写论文，似乎很流弊的样子，天呐，想想当年我还是使用的Word，就修改格式都用了大半天的时间，太可怕了，难道这就是专业人士和我们这些业余的区别！老衲怎能轻言放弃，于是乎就一顿Google，百度，看看是何方技能！传播与众人</p><h1 id="LaTeX简介"><a href="#LaTeX简介" class="headerlink" title="LaTeX简介"></a>LaTeX简介</h1><h2 id="什么是TeX"><a href="#什么是TeX" class="headerlink" title="什么是TeX"></a>什么是TeX</h2><p>电子排版系统的出现给印刷出版业带来了一场革命，利用电子计算机及各种辅助设备，可以完成从文稿、图表的录入、编辑、修改、组版，直至得到各种不同 用途、不同质量的输出结果。利用电子排版系统，可以减轻劳动强度，缩短出版周期。</p><p>目前世界上有许多电子排版系统。这些系统各有特点，也各有自己的适用范围。TeX 就是一种优秀的电子排版系统。</p><p>TeX 提供了一套功能强大并且十分灵活的排版语言，它多达 900 多条指令，并且 TeX 有宏功能，用户可以不断地定义自己适用的新命令来扩展 TeX 系统的功能。许多人利用 TeX 提供的宏定义功能对 TeX 进行了二次开发，其中比较著名的有美国数学学会推荐的非常适合于数学家使用的 AMS-TeX 以及适合于一般文章、报告、书籍的 LaTeX 系统。</p><p>TeX 系统是公认的数学公式排得最好的系统。<a href="http://www.ams.org/" target="_blank" rel="noopener">美国数学学会 （AMS）</a> 鼓励数学家们使用 TeX 系统向它的期刊投稿。世界上许多一流的出版社如 Kluwer、Addison-Wesley、牛津大学出版社等也利用 TeX 系统出版书籍和期刊。</p><p>大部分的 TeX 系统都是免费的。Knuth 教授还公开了他的全部源程序。TeX 系统目前已经在数百种计算机系统上得到实现。TeX 系统的排版结果 DVI（DeVice Independent）文件与输出设备无关。DVI 文件可以显示、打印、照排，几乎可以在所有的输出设备上输出。TeX 排版源文件及结果在各种计算机系统上互相兼容。</p><h2 id="TeX-的历史"><a href="#TeX-的历史" class="headerlink" title="TeX 的历史"></a>TeX 的历史</h2><p>七十年代末，<a href="http://www-cs-faculty.stanford.edu/~knuth/" target="_blank" rel="noopener">Donald E. Knuth（高德纳）</a> 在看到其多卷巨著“The Art of Computer Programming”第二卷的校样时，对由计算机排版的校样的低质量感到无法忍受。因此决定自己来开发一个高质量的计算机排版系统，这样就有了 TeX 。</p><p>TeX 的名字是由大写的希腊字母“tec”(tau, epsilon, chi)组成。在希腊语中这个词的意思是“科技”和“艺术”，这也解释了它的发音。“T”和“E”就像在“technology”中的发音一样，而“x” 的发音类似于苏格兰语单词“loch”或德语单词“ach”中的“ch”，也类似于西班牙语中的“j”或俄语中的“kh”。TeX 标志为 TEX ，这三个字母相靠得很近，而且中间的那个 E 有点儿下沉。但在无格式文件中，就写为 TeX 。</p><p>TeX 的第一版于 1978 年面世。在经过了不断的改进后，1982 年版的 TeX 是一个十分稳定的版本。从此以后，TeX 没有较大的变动，只有很少部分的改进和错误修正。现在几乎所有的操作系统平台下，都有相应的 TeX 软件，而且用它们排版同一个文件得到的输出结果是相同的。TeX 目前的版本是 3.141592，很接近圆周率π。每有一新的版本，就会加上一个π的小数点后的数。所以我们已经知道下一版本的 TeX 是 3.1415926，最终将收敛到π。这也代表了 TeX 不断追求完美的理想。</p><p>TeX 的源程序是用 Pascal 写成的，原因是 Knuth 希望 TeX 尽可能方便地移植到其它的操作系统中去。当时 Pascal 是最适合于这一要求的编程语言。这也使得 TeX 现在已经在几乎所有的计算机系统中得到实现。</p><p>TeX 的另一个重要的特征就是它的输出是与设备无关的。TeX 的输出文件称为 DVI 文件，即是“Device Independent”。一旦 TeX 处理了你的文件，你所得到的 DVI 文件就可以被送到任何输出设备如打印机，屏幕等并且总会得到相同的结果，而这与这些输出设备的限制没有任何关系。这说明 DVI 文件中所有的元素，从页面设置到文本中字符的位置都被固定，不能更改。</p><p>TeX 现在已经被它的开发者 Knuth 所“冰封”(frozen)，新版本的 TeX 只有少许改进和错误修正。这些变动必须保证不会使得即使是写于 1982 年的 TeX 文档无法编译，TeX 自带了测试文件来确保这一点。如果测试文件文件的输出结果不同于预定的结果，那么这个排版系统就不能够被称为“TeX”。所以像一些对 TeX 有很大改进的软件，如“Omega”等将不能被称为“TeX”，尽管它也是基于“TeX”的。</p><p>在设计 TeX 的同时，Knuth 还设计了一个字体生成程序 MetaFont。MetaFont 是独立于 TeX 之外的，但又与 TeX 有着非常密切的联系。MetaFont 生成的只是位图字体，当对字体进行缩放时的效果不佳。对于如何得到像 Type1 字体一样的轮廓字体，现在还在研究之中。与 TeX 一样，Knuth 也“冰封”了 MetaFont 。所以 MetaFont 的进一步的改进和发展将会由其他人来完成，而且名字也将不再是 MetaFont 。</p><h2 id="TeX-的未来"><a href="#TeX-的未来" class="headerlink" title="TeX 的未来"></a>TeX 的未来</h2><p>虽然 TeX 在过去的二十多年中没有大的变化，但这并不意味着 TeX 是一个僵化的系统。恰恰相反，TeX 开放的设计使得它能够很容易的适应新的要求。例如，在没有改动内核的情形下，TeX 很容易地实现了对 PostScript 字体和外部图形的支持。TeX 还是第一个能够自动生成 HTML 的字处理软件。最近，TeX 又开始增加了在不借助其它工具（如 Adobe Distiller）的条件下生成 PDF 的扩展功能。下面列出的几个项目都是正在进行中，对 TeX 的功能进行了扩展。</p><h3 id="PDFTeX"><a href="#PDFTeX" class="headerlink" title="PDFTeX"></a>PDFTeX</h3><p>完全兼容标准的 TeX ，但能够给出 PDF 输出。它也可以输出标准的 DVI 。</p><h3 id="e-TeX"><a href="#e-TeX" class="headerlink" title="e-TeX"></a>e-TeX</h3><p>不仅完全兼容标准的 TeX ，还支持一种“扩展模式”。在“扩展模式”中引入了许多新的特性和增强功能。这些新的特性和增强功能提供了更好的编程工具和对输出的控制。</p><h3 id="Omega"><a href="#Omega" class="headerlink" title="Omega"></a>Omega</h3><p>这是一个几乎是完全重新写过的，支持 Unicode 的 TeX 程序。Omega 有很多特征都超出了 Knuth 对 TeX 的原始设想。它采用了与 TeX 不同的方法来处理字符，使得可以处理非拉丁语系的文本。也支持从右到左，从上到下的排版方式。</p><h3 id="NTS"><a href="#NTS" class="headerlink" title="NTS"></a>NTS</h3><p>NTS 代表“New Typesetting System”。Knuth 已经停止发展 TeX，并决定任何超越 TeX 的扩展都不能被称为 TeX 。NTS 只是一些对于 TeX 的后续继承者的设想和概念的集合，还不是一个实际上的系统。该项目的第一个公布的产品就是 e-TeX。后来不知什么缘故，NTS的开发就停止了。直到 2002 年左右，一些 TeX 专家，想用 Java 开发 TeX，于是把中途夭折的 NTS 项目捡了起来，搞出了一个叫做 ExTeX 的东西，但是并没有普遍应用。</p><h3 id="MLTeX"><a href="#MLTeX" class="headerlink" title="MLTeX"></a>MLTeX</h3><p>这个 TeX 的扩展引入了命令 \charsubdef，使得可以更为简单方便的使用 8 bit 字符。不过，与 e-TeX 相比，这只是一个微小的改进。</p><h3 id="XeTeX"><a href="#XeTeX" class="headerlink" title="XeTeX"></a>XeTeX</h3><p>Jonathan Kew 在 e-TeX 基础上添加 Unicode 支持，并且连接 Mac OS X 的各种技术，比如ATT,Quartz,QuickTime，产生了一个重要的TeX分支，叫做XeTeX.XeTeX在2005/6年陆续发布了它的 Windows 和 Linux版本，最终集成在 TeXLive 2007 当中，标志着它被广泛地认可。在 XeTeX 中，使用多国语言，变得非常轻松，并且可以方便地使用系统的 TrueType 和 OpenType 字体，因此得到许多 TeX Guru 的喜爱。</p><h3 id="LuaTeX"><a href="#LuaTeX" class="headerlink" title="LuaTeX"></a>LuaTeX</h3><p>尽管 Omega 项目在开始时看上去很有希望，但是它的开发进展缓慢并且功能上也非常不稳定（基本上可以认为这个项目已经死亡）。于是，Giuseppe Bilotta 等人启动了 Aleph 项目，目的是让 Omega 稳定并且引入了 e-TeX 的扩展功能。后来 Aleph 项目现在也停止了，不过它的大部分功能都被集成到了 <a href="http://wiki.ctex.org/index.php?title=LuaTeX&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">LuaTeX</a> 中。<a href="http://wiki.ctex.org/index.php?title=LuaTeX&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">LuaTeX</a> 是一个新的 TeX 引擎项目，由科罗拉多州立大学（Idris Samawi Hamid 的东方 TeX 项目）和 NTG 资助，该项目于 2006 年启动，于 2007 年夏季发布首个 beta 版本。</p><p>LuaTeX 是 Aleph 与 pdfTeX 项目的继任者，主要由 Taco Hoekwater 开发。除了兼有 Aleph 和 pdfTeX 的功能之外，LuaTeX还具有以下特点：</p><ul><li>内部集成了轻量级的动态编程语言 Lua，可以采用该语言扩展 LuaTeX 功能或宏包；</li><li>提供了 OpenType 字体的本地支持，与 XeTeX 做法不同的是，LuaTeX 没有使用操作系统自带的字体库来访问字体，而是使用了 FontForge库；</li><li>内部集成了 MPLib（一个扩展的 MetaPost 库模块）。</li></ul><h2 id="TeX-的优点"><a href="#TeX-的优点" class="headerlink" title="TeX 的优点"></a>TeX 的优点</h2><p>在一个充斥着“所见即所得”(WYSIWSG)桌面出版软件的情况下来使用 TeX 确是有点令人奇怪。但是，在某些情形下，你会感到 TeX 是最好的，甚至是唯一适合的系统。</p><p>首先我们来看一下 TeX 的优势所在：</p><ul><li><strong>高质量的输出</strong> TeX 遵循传统的排版规则，以排版的质量为最重要的目标。如果你把 TeX 的输出结果和用其它的排版软件排版相同的文本所得到的结果加以比较，你就会发现其中的区别。</li><li><strong>超常的稳定性</strong> 自从 TeX 出现以来，只有一些微小的改动。也就是说，十几年前的 TeX 文件用现在的 TeX 系统排版得到的结果与十几年前得到的结果是一样的。稳定性还体现在 TeX 系统极少会崩溃，可以处理任意大小的文件，即使你的计算机的内存很少，TeX 也可自如的工作。</li><li></li><li><p><strong>TeX 是可编程的</strong> TeX 是一种宏命令编程语言。你可以用很少的命令来完成非常复杂的工作。如果需要的话，你也可以重新定义 TeX 的所有命令来得到特殊的效果。</p></li><li><strong>高度的灵活性</strong> TeX 自从出现以来其内核只有微小的改动。但是由于其内核的设计方式，世界上的 TeX 使用者可以让 TeX 做几乎任何工作。你可以用 TeX 来排版英文文本，也可以排版德文，俄文，中文等多种语言。你还可以用 TeX 来排版乐谱，象棋，围棋棋谱等等。</li><li><strong>简单方便</strong> TeX 文档是 ASCII 码的文本文件。因此，即使你手边没有 TeX 系统，你也可以看懂绝大部分的内容。TeX 文件的这种特点使得它占用很少的存储空间，也可以很方便的用 email 来传输。</li><li><strong>良好的通用性</strong> 目前为止，TeX 几乎在所有的计算机操作系统平台上得到实现。如：Atari，Apple，Macintosh，Unix，VMS，MS-DOS，MS-Windows 和 OS/2 等等。TeX 的源文件可在不同的平台之间自由的交换，而得到的输出是完全相同的。</li><li><strong>低廉的价格</strong> TeX 是免费软件，它的源程序也是免费的。你可能仅仅需要支付邮费，甚至于一分不花地得到适合你的 TeX 系统。世界上有很多非常好的 TeX 免费软件如：teTeX，MikTeX，fpTeX 等等。同时也有一些具有各自特点（如或多或少的所见即所得特性的）和提供专家级帮助系统的商业版本。</li><li><strong>超级技术支持</strong> 由于 TeX 并不是被某个公司所垄断开发，所以世界各地的使用者设计了统一的技术支持的方式。这通常是通过因特网以 email, WWW, Usenet 或 Ftp 的方式来提供，有时也可能通过电话或传真的方式。绝大多数情况下这些技术支持都是免费的，这也是 TeX 的精神。</li><li><strong>TeX 是一种乐趣</strong> 使用 TeX 不仅仅是一种工作手段，也是一种乐趣。它有挑战，也有荣誉。很多人在熟悉了 TeX 之后都开始把使用 TeX 作为一种爱好，而不是一件枯燥无味的劳动。</li></ul><h2 id="TeX-的不足"><a href="#TeX-的不足" class="headerlink" title="TeX 的不足"></a>TeX 的不足</h2><p>在展示了 TeX 的优秀之处后，也得承认 TeX 也有一些不足的地方：</p><ol><li>TeX 不是在一个下午就能完全学会的，除非你是一个真正的天才。当你开始学习并使用它的时候，你将会不停的去翻看 TeX 的参考手册来寻找一个 TeX 命令。你也会发现 TeX 常常不理会你键入的命令，还给出一个让你感到迷惑的错误讯息。这一切都说明了掌握 TeX 需要一个比较长而且艰难的学习过程。TeX 的一些扩展如 LaTeX、ConTeXt 则要相对简单的多，使用起来也比 TeX 方便，一个新手完全可以在一个下午或者更短的时间内学会开始使用 LaTeX 或 ConTeXt。</li><li>当发生错误的时候，TeX 会给出一些信息来提示你。但很多情况下并不足以是你迅速准确的找到错误之所在。尤其对刚刚开始学习的新手来说更是如此。</li><li>像 TeX 这种宏语言不同于其它的计算机语言，如 C，Pascal 等，大多数人并不了解。因此，当你想要写自己的宏命令时，你需要对 TeX 有比较深入的了解才能写出牢固可靠的宏命令。</li><li>TeX 不是所见即所得的。尽管市场上有些近似于所见即所得的自由/开源软件（如 <a href="http://www.lyx.org/" target="_blank" rel="noopener">LyX</a>）或商业软件，但即使与最普通的字处理软件比，也 还是有不小的差距。</li></ol>]]></content>
      
      
      <categories>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇-杂谈WebGIS</title>
      <link href="/2019/03/30/%E6%9D%82%E8%B0%88WebGIS/"/>
      <url>/2019/03/30/%E6%9D%82%E8%B0%88WebGIS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>我相信大家对百度地图，谷歌地图等相关应用已经是非常熟悉了。通过这些应用，我们可以浏览地图、定位我们自己的位置、查找我们想知道的兴趣点、搜索交通路线等等。而其实，这些功能便是WebGIS的一些最基本的功能。</p><p>那么什么是WebGIS呢，说到这里，我还是首先给大家讲讲什么是GIS。</p><h2 id="2．GIS简介"><a href="#2．GIS简介" class="headerlink" title="2．GIS简介"></a>2．GIS简介</h2><h3 id="2-1-GIS的名词解释"><a href="#2-1-GIS的名词解释" class="headerlink" title="2.1 GIS的名词解释"></a>2.1 GIS的名词解释</h3><p>GIS的全名是Geographic Information System，中文全名是地理信息系统。它是在计算机硬、软件系统支持下，对整个或部分地球表层（包括大气层）空间中的有关地理分布数据进行采集、储存、管理、运算、分析、显示和描述的技术系统。</p><h3 id="2-2-什么是GIS学科"><a href="#2-2-什么是GIS学科" class="headerlink" title="2.2 什么是GIS学科"></a>2.2 什么是GIS学科</h3><p>撇开这些晦涩的文字，我争取用更形象的方法来给大家介绍下GIS这个学科。</p><p>我们人类在很久之前就已经开始使用羊皮或者纸质的地图了，他的用途主要便是给人们的行军、航海等做向导，而这同样也是现代GIS学科里GIS最基本的功能之一。到19世纪时，现代GIS学科开始慢慢萌芽。这里有一个很有名的例子。1854年伦敦发生霍乱，10天就死了500人。居民大多怀疑瘟疫是由于地下的墓穴引起的，引起了极大的社会恐慌。当时有个有名的医生叫Snow博士，他不信这个原因，为了查出真正的霍乱源头，他首先绘出了伦敦地图，然后将所有霍乱病人的所在地标出来，然后他发现了一个有趣的现象，在伦敦的一个居民饮水井附近出现的霍乱病人最多，并且最开始出现的霍乱病人也是在那里发现的。最后Snow博士对那口井进行检查，确定了霍乱发生的源头。从这个例子中我们可以看出，地图的应用已经不再局限于导航了，而开始慢慢利用其得天独厚的时间空间优势与其他学科开始进行结合。</p><p>到了20世纪电脑的出现，人造卫星的升天等技术的突破，GIS这个学科也相应的开始走向成熟以及开始普及。20世纪60年代，加拿大科学家首先提出了GIS这个学科。到了20世纪末，一大批优秀的GIS软件已经出现，比如Esri公司的ArcGIS系列，MapInfo公司的MapInfo。国内的GIS从上世纪80年代才开始起步，不过到上世纪末时，也出现了自己的GIS公司，比较有名的有GeoStar、MapGIS等。</p><p>而此时的GIS已不再是局限纸上的地图了，它已经成为了一个计算机技术和多种学科相交叉的新型学科了。它涉及到测量学——地理信息的采集和地图的制作等，计算机科学——电子地图的制作和展现以及各种GIS功能的实现，物理学——对传感器的研究以及光谱和影像的研究，气象学——大气层等对卫星影像的影响等，生物学、医学、犯罪学等——研究地理等各时间空间因素对这些学科的影响。</p><p>GIS是什么呢，说的最通熟易懂的就是，GIS是利用测绘生成纸制地图或者航拍以及卫星等生成影像后，将这些数据存储在计算机中，以地图或图片的形式表现出来，然后根据实际生产生活以及科研中的各种需求，进而提供具体的经过处理后的数据。</p><h2 id="3-WebGIS简介"><a href="#3-WebGIS简介" class="headerlink" title="3.WebGIS简介"></a>3.WebGIS简介</h2><h3 id="3-1什么是WebGIS"><a href="#3-1什么是WebGIS" class="headerlink" title="3.1什么是WebGIS"></a>3.1什么是WebGIS</h3><p>顾名思义，WebGIS就是展现于网络上的GIS。在上世纪八十年开始，出现的大量GIS软件，基本上都是C/S架构的，也就是首先需要在本机上装有专业的GIS软件，然后用户根据需求使用这些GIS软件。当然这种桌面端的GIS软件有其天然的优势，比如开发相对简单，不需要Internet支持，以及可以做更多的复杂功能、响应相对迅速等优势。但是同时，其缺点更是不容忽视。首当其冲的便是不便于推广，而不便于推广的原因在于C/S系统其本身的天然的劣势：不便于更新，不便于跨平台，不便于用户在不安装指定客户端的情况下使用。</p><p>从本世纪开始，internet进入了爆发式增长阶段，网络的铺设以及网速的提升都有了大幅度增加，这为WebGIS的发展提供了坚实的大环境。于是，基于B/S的GIS系统越来越多的开始提供服务，并且在RIA（富客户端）技术、AJAX（动态网页）技术的涌现和成熟，WebGIS也基本能展现出与C/S一样的效果和功能。而WebGIS的大发展，更是用户的需求，google地图和百度地图等服务提供商的大规模扩张便是最好的证明。</p><p>什么是WebGIS，就是将GIS这门学科所能提供的功能，以B/S技术展现给用户，使用户只需要在浏览器上便能使用这些GIS功能的一个应用方向。</p><h3 id="3-2对国内WebGIS行业的理解"><a href="#3-2对国内WebGIS行业的理解" class="headerlink" title="3.2对国内WebGIS行业的理解"></a>3.2对国内WebGIS行业的理解</h3><p>目前使用WebGIS技术的公司可以大致分为两个方向：一个是互联网方向，一个是行业应用方向。</p><p>国内的互联网方向里基本可以说已经被百度地图，搜搜地图，高德地图，三个巨头垄断。所以对于想从事互联网方向的WebGIS开发人员，其实可以选择的大公司并不多。但是，如果你是一个技术足够好，且技术不局限于一般的关系数据库，对大数据和分布式系统感兴趣的WebGIS开发人员，强烈建议你去这些互联网公司，在那里你能接触到最新的IT技术以及感受到强大的头脑风暴。也便是，对新技术，对前沿方向有更多追求的人，去互联网公司是很好的选择。</p><p>但是我们不得不承认另外一个现实，这些互联网公司基本集中在北上广深，并且对GIS研发人员在技术上的需求是，计算机技术的比重要远大于对GIS学科本身的理论所占的比重。于是，更多的GIS学科出身的人，最后选择的是行业应用公司。而投身于这样的公司，就没有前途吗？答案是否定的。</p><p>Esri公司作为全球最成功的GIS软件公司，很好的给出了这个答案。目前Esri的AO库号称世界上第二大的库，除了微软的Framework，就是它了。它同时也是一个年盈利在8亿美元的公司。Esri公司与美国和加拿大政府的合作堪称行业公司的典范，它为这两个国家的数字化城市的建设立下了汗马功劳，做出了很多优秀的作品。说这个例子，只是为了表明，在我们的数字化城市的需求越来越深入，政府的需求越来越实际，整个国家的市场建设越来越合理以及公平公正透明，WebGIS在行业上的应用也将越来越广泛，并且越来越能够服务政府、企业和人民，并且更能做出有真实价值的产品。并且，从事行业应用的研发人员，随着对所从事行业理解的深入，这些理解给未来所带来的收获可能比技术单纯的提高所带来的收获要大得多。要知道，项目需求分析靠的基本是行业理解，当然，对技术的了解也给项目可行性分析提供了保障。两者相辅相成。</p><p>每个人追求不一样，根据自己的需求，根据自己的现状，做出选择，坚持下去，不说梦想是否能实现，起码你不会是一个自己都认为自己活该如此平庸的人。</p><h2 id="4-WebGIS的框架"><a href="#4-WebGIS的框架" class="headerlink" title="4.WebGIS的框架"></a>4.WebGIS的框架</h2><p>前面说了太多的非技术类的话，这里我们开始提一个技术类话题——WebGIS的框架。其实WebGIS的框架跟其他Web项目的框架没有很多本质上的区别。可能唯一的不同是WebGIS需要提供一些地图方面的功能服务。这里我先把这个框架给出，同时每个层面需要的技术我也在其中大致画出。</p><p>​                                    <img src="https://images0.cnblogs.com/i/656746/201408/021630108995466.png" alt="img">                    </p><p>​                                       </p><h3 id="4-1前端"><a href="#4-1前端" class="headerlink" title="4.1前端"></a>4.1前端</h3><p>如所有的Web项目一样，前端由HTML、CSS、JS、Flex等语言组成。根据需求和语言的特性，选择合适的语言进行开发是至关重要的。没有最好的语言，只有最合适的语言。</p><h3 id="4-2-后台程序"><a href="#4-2-后台程序" class="headerlink" title="4.2 后台程序"></a>4.2 后台程序</h3><h4 id="4-2-1-中间件"><a href="#4-2-1-中间件" class="headerlink" title="4.2.1 中间件"></a>4.2.1 中间件</h4><p>开发时，我们要选择适合自己的中间件。不同的中间件有其特性，如果是一般项目，tomcat等是很合适的，其使用方便，相关技术支持和资料也很好查找。但是如果是大型的集群项目，Weblogic和WebShpere可能是更好的选择，但是这两个中间件首先配置就是有难度的，同时不同的版本，可能对某些jar包的支持存在问题。如果项目必须使用国产的中间件，TongWeb和Apusics是不错的选择。</p><h4 id="4-2-2-地图服务器"><a href="#4-2-2-地图服务器" class="headerlink" title="4.2.2 地图服务器"></a>4.2.2 地图服务器</h4><p>在WebGIS中，与其他一般的Web工程有明显区别的就体现在地图服务器上面。一般的地图服务器都由已有的软件商提供了解决方案，比较流行的有AGS、Geoserver、MapServer、SuperServer等。利用这些地图服务器我们能很好的实现地图的发布以及对一些空间查询和空间操作的支持。</p><h4 id="4-2-3-业务服务器"><a href="#4-2-3-业务服务器" class="headerlink" title="4.2.3 业务服务器"></a>4.2.3 业务服务器</h4><p>业务服务器是Web项目里不可获取的一环。不管是利用哪些已有框架编写，比如Spring、Struts、Hibernate等，我们一般还是会将业务服务器的实现分为三个层次，即有名的MVC模式。而不同的框架里这三个层次的实现各有差别。</p><h3 id="4-3-数据"><a href="#4-3-数据" class="headerlink" title="4.3 数据"></a>4.3 数据</h3><p>WebGIS的数据大致可以分为三种，一种是地图、影像数据，一种是空间属性数据、一种是业务数据。地图、影像数据一般是一些png或者其他格式的数据组成。</p><p>在GIS中有个很重要的概念，即影像金字塔。这个概念主要是为了加速地图在前端的显示。而我们准备地图、影像数据时，也一般会首先对这些数据进行切图。</p><p>空间属性数据，是通过一些工具将已经整理好的数据进行入库。对于AGS，只有连接的是入库数据的mxd，才能发布成FeatureServer服务，以供数据的编辑。当然，空间数据入库后还可以支持业务逻辑的使用。</p><p>第三种数据，业务逻辑数据，是每个Web项目必须有的，它根据不同的业务需求将业务所需的数据进行采集和入库。</p><h2 id="5-从WebGIS的原理谈起"><a href="#5-从WebGIS的原理谈起" class="headerlink" title="5.从WebGIS的原理谈起"></a>5.从WebGIS的原理谈起</h2><p>目前很多公司都提供了自己的二次开发包，在前端的有OpenLayers、AGS API for JS/Flex等。在后台的也有geoTools、AO等。用这些开发包，我们可以很快的实现出图以及很多GIS功能，基本上不用写太多的编码。</p><p>但是，同样，由于封装的太好，很多WebGIS的原理我们也便忽略而不做了解了。</p><p>这里，我希望利用我薄弱的知识，能和大家一起，探讨一些WebGIS中常用的原理知识。希望大家支持。</p><h2 id="6-感想"><a href="#6-感想" class="headerlink" title="6.感想"></a>6.感想</h2><p>由于我薄弱的理论和技术基础，也谈不上对WebGIS的明天有很大的预言。我只希望我们每个人都争取做一个完美主义者，同时也是一个有圣徒情怀的人，从而作践自己实现目标。与大家一起进步。希望我也能保持自己的写作动力，积累经验和知识。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么你得学些TCP知识</title>
      <link href="/2019/03/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BE%97%E5%AD%A6%E4%BA%9BTCP%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/03/30/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BE%97%E5%AD%A6%E4%BA%9BTCP%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>这不是指要明白 TCP 的所有东西，也不是说要通读 《TCP/IP 详解》。不过懂一点 TCP 知识是很有必要的。理由如下：</p><p>当我还在 Recurse Center 的时候，我用 Python 写过 TCP 协议栈（还写过一篇文章：如果你用 Python 写 TCP 协议栈会遇到什么？）。这是一次有趣的学习经历，但是也仅此而已。</p><p>一年以后，工作中有人在 Slack 上提到：“嘿，我在向 NSQ 发布消息时，每次要耗费 40 毫秒”。我已经断断续续思考了一个星期，但是没有任何结果。</p><p>一点背景知识：NSQ 是一个消息队列，你通过本地的一个 HTTP 请求向其发布消息。发送本地的一个 HTTP 请求确实不应该花费 40 毫秒，有时候会更差。NSQ 守护进程的负载不高，也没有使用过多的内存，也看不到 GC 停顿。这究竟是为什么呢？神呐，救救我吧！</p><p>突然我记起我一周以前看过的一篇叫做“性能研究（In search of performance）”的文章——我们如何为每个 POST 请求节省 200ms。在这篇文章中，他们说到为什么每个 POST 请求会花费额外的 200 毫秒。就是这个原因。这是该文章中的关键段落：</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="延迟确认（ACK）-与-TCP-NODELAY"><a href="#延迟确认（ACK）-与-TCP-NODELAY" class="headerlink" title="延迟确认（ACK） 与 TCP_NODELAY"></a><strong>延迟确认（ACK） 与 TCP_NODELAY</strong></h3><blockquote><p>Ruby 的 Net::HTTP 会将 POST 请求切分为两个 TCP 包，一个消息头，一个消息体。相反，curl 会将这两者合并为一个包。更糟糕的是，Net::HTTP 在打开 TCP 套接字时不会设置 TCP_NODELAY，这将导致第二个包需要等到第一个包的接收确认通知之后才能发送。这是 Nagle 算法导致的。</p></blockquote><blockquote><p>转换到连接的另一端，HAProxy 需要决定如何确认这两个包。在 1.4.18 版本中（我们正在用的版本），它是通过 TCP 延迟确认通知来实现的。延迟确认对 Nagle 算法有非常糟糕的影响，会导致请求暂停直到服务器延迟确认超时。</p></blockquote><p>现在我们解释这个段落说的内容。</p><ul><li>TCP 是一个通过数据包传输数据的算法</li><li>他们的 HTTP 库将 POST 请求分割成两个小的数据包发送</li></ul><p>接下来，TCP 采用类似如下的步骤进行交互：</p><blockquote><p>application：Hi！这里有一个数据包。<br>HAProxy：（沉默），等待第二个包发送<br>HAProxy：对了，我需要返回一个确认，不过没关系，等会吧<br>application: （沉默）<br>application：好吧，我正在等待确认，可能现在网络延迟比较大<br>HAProxy：好吧，太烦人了，这是一个确认。<br>application：好极了，这是第二个数据包！！！<br>HAProxy：亲，我们已经搞定了。</p></blockquote><p>这个过程是不是应用程序和 HAProxy 都在消极等待另一方发送信息？这就是那额外的 200ms。应用程序这么做的是因为 Nagle 算法，而 HAProxy 消息等待的原因是延迟确认。</p><p>据我所知，延迟确认是所有 Linux 系统的默认行为。所以这不是一个偶然或者异常情况，如果发送 TCP 数据包多一个 1 个，你就会遇到这种情况。</p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="现在，我们成为专家了"><a href="#现在，我们成为专家了" class="headerlink" title="现在，我们成为专家了"></a><strong>现在，我们成为专家了</strong></h3><p>读过这篇文章之后我很快就忘了。不过当我被额外的 40 毫秒难住的时候，我又记起来了。</p><p>所以我认为——这不可能是我的问题，可能吗？可能吗？？然后我发了一封邮件给我团队说：“我想我快要疯了，但是这可能是 TCP 的问题”。</p><p>所以我提交了一次修订，将我的应该调整为 TCP_NODELAY，然后问题就“嘣”的一声解决了。</p><p>40 毫秒的延迟立马就消失了。所有的事情都解决了，我就是个天才。</p><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="我们是否应该完全停止使用延迟确认？"><a href="#我们是否应该完全停止使用延迟确认？" class="headerlink" title="我们是否应该完全停止使用延迟确认？"></a><strong>我们是否应该完全停止使用延迟确认？</strong></h3><p>我刚好在 Hacker News 看到 John Nagle （Nagle 算法的创始人）对 @alicemazzy 提到这个问题的评论。</p><blockquote><p>本质问题是延迟确认。200 毫秒的“延迟确认”是一个非常不好的主意，1985 年中，在伯利克（Berkeley）研究 BSD 的人实际上没有真正明白这个问题。延迟确认是应用层对 200 毫秒内是否响应的一场赌博，但是即便每次它都赌输了，TCP 仍在使用延迟确认。</p></blockquote><p>他继续说到，确认本身是很小并且消耗很低的，延迟确认引起的问题可能比它解决的问题还要多。</p><h3 id="不懂得-TCP-你就无法解决-TCP-问题"><a href="#不懂得-TCP-你就无法解决-TCP-问题" class="headerlink" title="不懂得 TCP 你就无法解决 TCP 问题"></a><strong>不懂得 TCP 你就无法解决 TCP 问题</strong></h3><p>我曾经也认为，TCP 是一个相当底层的问题，我不需要明白。大多数时候你的确不需要明白。但是有的时候，当你在实践中遇到由于 TCP 算法引起的 bug 时，懂点 TCP 知识就变得非常重要了。（正如我们经常在博客中讨论的，许多事情都是这样，比如系统调用和操作系统:) ）</p><p>延迟确认及 TCP_NODELAY 的交互非常不好——这对任何语言实现的 HTTP 请求都有影响。你不需要很深入的去了解，成为系统程序专家。但是了解一点 TCP 是如何运作的，对我的工作的确大有裨益。通过对 TCP 的学习，我才意识到这篇博客所描述的问题也许正好是我所熟悉的领域。我也一直在使用 strace，并且会一直使用下去。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度解密 HTTP 通信细节</title>
      <link href="/2019/03/29/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86HTTP%E9%80%9A%E4%BF%A1%E7%BB%86%E8%8A%82/"/>
      <url>/2019/03/29/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86HTTP%E9%80%9A%E4%BF%A1%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>在上一篇《<a href="https://llqing.github.io/2019/03/28/san-ci-wo-shou-si-ci-hui-shou-ni-zhen-de-dong-ma/">“三次握手，四次挥手”你真的懂吗？</a>》中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的 <code>锤子</code>，拿着 <code>锤子</code>，看什么都像 <code>钉子</code>！在这篇文章中，我对准了 <code>HTTP</code>这颗钉子砸下去，咳咳。</p><p>为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我则是把复杂的东西撕碎了给人看。</p><p>文章稍长，请在看本文时保持耐心。我先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！</p><p>为了更好的阅读体验，我手动贴上本文的目录：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cjHbwiaFiaXcneDwD5tV48jf8JedJ22VnrWluok7iaZyP2aHSUfTeaRW9A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id="HTTP报文截获"><a href="#HTTP报文截获" class="headerlink" title="HTTP报文截获"></a>HTTP报文截获</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我手头现在有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是 <code>Fence2Area</code>. 使用方传入一个围栏（由点的列表组成，点由&lt;经度，纬度&gt;表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。</p><p>我请求服务的“Fence2Area”接口，输入围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，输出的则是多边形的面积(area).</p><p>一次正常的请求示例url, 这个大家都不陌生（我用docker_ip代替真实的ip）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>请求发出后，服务器进行处理，之后，客户端收到返回的数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;data&quot;: &#123;        &quot;area&quot;: 48764135597.842606    &#125;,    &quot;errstr&quot;: &quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p><code>area</code>字段表示面积， <code>errstr</code>表示出错信息，空说明没有出错。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>在真正发送请求之前，需要进行抓包前的设置。在本地mac，我用wireshark; 而在远程docker上，我用tcpdump工具。</p><h3 id="mac本地"><a href="#mac本地" class="headerlink" title="mac本地"></a>mac本地</h3><p>设置wireshark包过滤器，监控本地主机和远程docker之间的通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr eq docker_ip</span><br></pre></td></tr></table></figure><p>点击开始捕获。</p><h3 id="远程docker"><a href="#远程docker" class="headerlink" title="远程docker"></a>远程docker</h3><p>该服务通过7080端口对外提供，使用如下命令捕获网络包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w /tmp/testHttp.cap port 7080 -s0</span><br></pre></td></tr></table></figure><h2 id="请求-amp-amp-分析"><a href="#请求-amp-amp-分析" class="headerlink" title="请求 &amp;&amp; 分析"></a>请求 &amp;&amp; 分析</h2><p>准备工作做完，我选了一个神圣的时刻，在本地通过浏览器访问如下url:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。</p><h3 id="关闭服务进程"><a href="#关闭服务进程" class="headerlink" title="关闭服务进程"></a>关闭服务进程</h3><p>正式请求之前，我们先看一下几种特殊的情形。</p><p>首先，关闭gcs服务进程，请求直接返回RST报文。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1ib1lViaLiaASe6wCNRxwB8Xu769ic09sS7T7GbjkibZ1PUiae36SP7D4ntg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>如上图，我在请求的时候，访问服务端的另一个端口 <code>5010</code>, 这个端口没有服务监听，和关闭gcs服务进程是同样的效果。可以看到，客户端发送SYN报文，但直接被远程docker RST掉了。因为服务端操作系统找不到监听此端口的进程。</p><h3 id="关闭docker"><a href="#关闭docker" class="headerlink" title="关闭docker"></a>关闭docker</h3><p>关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbJoZcwl0vLPpwOqVb8B6XiaveJosgAibblK0IXaicGVEPXC1poXhQEohw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。</p><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><p>先进行一次正常的访问，随后重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，访问到服务端后，因为它已经重启了，所以服务端已经没有这个连接的消息了。因此会返回一个RST报文。</p><h3 id="正常请求"><a href="#正常请求" class="headerlink" title="正常请求"></a>正常请求</h3><p>服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckxkrMtp9vRhDDluuIBFDcK8tyfSNq6Mibu1bFL83korLAUfUyxT8qKg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为 <code>HTTP</code>层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在 <code>HTTP</code>层发送的响应数据，第七个包为mac对第六个包的确认报文。</p><p>重点来关注后面几个包，先看第四个包，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0295 0000 4000 3606 623b ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d0x0020:  8018 1015 0ee7 0000 0101 080a 2e4c b2ef0x0030:  0f20 3acf 4745 5420 2f64 6174 613f 636d0x0040:  643d 4665 6e63 6532 4172 6561 266d 65740x0050:  613d 7b25 3232 6361 6c6c 6572 2532 323a0x0060:  2532 3274 6573 7425 3232 2c25 3232 54720x0070:  6163 6549 6425 3232 3a25 3232 7465 73740x0080:  2532 327d 2672 6571 7565 7374 3d7b 25320x0090:  3266 656e 6365 2532 323a 5b7b 2532 326c0x00a0:  6e67 2532 323a 3130 2e32 2c25 3232 6c610x00b0:  7425 3232 3a31 302e 327d 2c25 3230 7b250x00c0:  3232 6c6e 6725 3232 3a31 302e 322c 25320x00d0:  326c 6174 2532 323a 382e 327d 2c25 32300x00e0:  7b25 3232 6c6e 6725 3232 3a38 2e32 2c250x00f0:  3232 6c61 7425 3232 3a38 2e32 7d2c 25320x0100:  307b 2532 326c 6e67 2532 323a 382e 322c0x0110:  2532 326c 6174 2532 323a 3130 2e32 7d5d0x0120:  2c25 3232 636f 6f72 6474 7970 6525 32320x0130:  3a32 7d20 4854 5450 2f31 2e31 0d0a 486f0x0140:  7374 3a20 3130 2e39 362e 3932 2e32 31320x0150:  3a37 3038 300d 0a55 7067 7261 6465 2d490x0160:  6e73 6563 7572 652d 5265 7175 6573 74730x0170:  3a20 310d 0a41 6363 6570 743a 2074 65780x0180:  742f 6874 6d6c 2c61 7070 6c69 6361 74690x0190:  6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 70700x01a0:  6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d300x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 55730x01c0:  6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c0x01d0:  612f 352e 3020 284d 6163 696e 746f 73680x01e0:  3b20 496e 7465 6c20 4d61 6320 4f53 20580x01f0:  2031 305f 3133 5f36 2920 4170 706c 65570x0200:  6562 4b69 742f 3630 352e 312e 3135 20280x0210:  4b48 544d 4c2c 206c 696b 6520 4765 636b0x0220:  6f29 2056 6572 7369 6f6e 2f31 322e 302e0x0230:  3220 5361 6661 7269 2f36 3035 2e31 2e310x0240:  350d 0a41 6363 6570 742d 4c61 6e67 75610x0250:  6765 3a20 7a68 2d63 6e0d 0a41 6363 65700x0260:  742d 456e 636f 6469 6e67 3a20 677a 69700x0270:  2c20 6465 666c 6174 650d 0a43 6f6e 6e650x0280:  6374 696f 6e3a 206b 6565 702d 616c 69760x0290:  650d 0a0d 0a</span><br></pre></td></tr></table></figure><p>我们来逐字节分析。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cESQM7mPYK50BUdqRtB4qISMY5VjrFYEL4fEVDMgMquTHMqhekaY2AA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTZn8gROeqs1ncqfs0lrbUic92cGeHU3xrZr76pslib22mnVPmXjz3DOA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure><p>可以得到ascii码，我们直接看十六进制的结果：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c0dZYr61gHv0qYGlBIVEM3zr6RIxqxW2s7ia5lRnAkgLzQVCfeovialmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cPt3Eicksdp2tfV1hJJcRPLib1SFEGno5wwa9rtDaQJOomYhp9focEribQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>把上表的最后一列连起来，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125; HTTP/1.1 Host: 10.96.92.212:7080 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15 Accept-Language: zh-cn Accept-Encoding: gzip, deflate Connection: keep-alive</span><br></pre></td></tr></table></figure><p>其中，cr nl表示回车，换行。</p><p>docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。另外，序列号为2778351310.</p><p>再来看第5个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 d28b 4000 4006 8810 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8010 00ec e04e 0000 0101 080a 0f20 3af70x0030:  2e4c b2ef</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cAZEWxWx96R82g4YMAKmw1BAibT6xxBcL1kjJf3fGaUqDFLGNLjleFsA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbI0RpST1AwXnJm99vUPedSEW5vsjxhIMfpnnVPqUMMfpib6ibkkWEcTQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnkkiao15MgfVBSI2lAicn9OKJwwmppIic9fxfpJkH5nHOyaoKGtnP8iakQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>数据部分为空，这个包仅为确认包。</p><p>再来看第六个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 00f9 d28c 4000 4006 874a 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8018 00ec e113 0000 0101 080a 0f20 3af80x0030:  2e4c b2ef 4854 5450 2f31 2e31 2032 30300x0040:  204f 4b0d 0a41 6363 6573 732d 436f 6e740x0050:  726f 6c2d 416c 6c6f 772d 4f72 6967 696e0x0060:  3a20 2a0d 0a44 6174 653a 2054 6875 2c200x0070:  3033 204a 616e 2032 3031 3920 3132 3a320x0080:  333a 3437 2047 4d54 0d0a 436f 6e74 656e0x0090:  742d 4c65 6e67 7468 3a20 3438 0d0a 436f0x00a0:  6e74 656e 742d 5479 7065 3a20 7465 78740x00b0:  2f70 6c61 696e 3b20 6368 6172 7365 743d0x00c0:  7574 662d 380d 0a0d 0a7b 2264 6174 61220x00d0:  3a7b 2261 7265 6122 3a34 3837 3634 31330x00e0:  3535 3937 2e38 3432 3630 367d 2c22 65720x00f0:  7273 7472 223a 2222 7d</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c4iaw0WsWa7KbicwicrJbrVm82c1z3OOQuCBG8MnezL90gSGbEWv5p1wLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0chROjPEbF98pwdNNGm56BqMY5TJhQ4UCMZQibicgkxxJum4EkLSoDKyHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>剩下来的就是数据部分了。我们一行一行地看。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cf9reib3oq2gOJVfkdHdEafO0t7ZibzwACqJl9F1BVonYzlXOib1orDpiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>把上表的最后一列连起来，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK Access-Control-Allow-Origin: * Date: Thu, 03 Jan 2019 12:23:47 GMT Content-Length: 48 Content-Type: text/plain; charset=utf-8 &#123;&quot;data&quot;:&#123;&quot;area&quot;:48764135597.842606&#125;,&quot;errstr&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p>Content-Length: 48，最后一行的长度即为48个字节。</p><p>最后，第七个包，字节流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 0000 4000 3606 649c ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e9420x0020:  8010 100f 1eb9 0000 0101 080a 2e4c b3140x0030:  0f20 3af8</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0czCoePYTJlUT7ry6wUOC5sib1phKyp1odVXVHxGwmCVjZAxHfnQ6ugrA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cQcJTJtCqC5uUlc8fH3gCIvcR8FV3ayZu6LIBXVR32aUJGHDLK2Al8g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>至此，一次完整的http请求的报文就解析完了。感觉如何，是不是很亲切？</p><h1 id="HTTP协议分析"><a href="#HTTP协议分析" class="headerlink" title="HTTP协议分析"></a>HTTP协议分析</h1><p>上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步带你深入理解HTTP协议。</p><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><p><code>HTTP</code>(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。说得更形象一点： <code>HTTP</code>是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。</p><p>HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cd3E2bpHQ1JibJo1Cks0PtU75BD8UsUZQMIuutqGxuxDXqIbJicibk0NiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>HTTP在传输一段报文时，会以 <code>流</code>的形式将报文数据的内容通过 <code>一条打开</code>的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cvS3b6LIgaPLTfa4gdcLHKRMQV8A4mZF0Gux7vhwiapGLyB2tYFrrFew/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们再来回顾一下：</p><p>原始的url值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure><p>编码后的url值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125;</span><br></pre></td></tr></table></figure><p>在之前的报文拆解过程中，我们看到多了很多 <code>%22</code>，其实， <code>0x22</code>是单引号 <code>&quot;</code>的ascii值，</p><p>一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，比如空格；最后，URL还得是完整的，它需要支持所有语言的字符。</p><p>总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。</p><p>转义的方法：百分号( <code>%</code>)后跟着两个表示ASCII码的十六进制数。比如：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ca1ibSClFurjoccZUHYENZbYZrf2opPyvfdM8Ll5770Uic6YaVsZXbLVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。</p><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p>响应数据中，我们注意到有一个首部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/plain; charset=utf-8</span><br></pre></td></tr></table></figure><p>互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的 <code>Content-Type</code>. MIME本来是用在邮件协议中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，是该展示图片，还是调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表展示了一些常见的类型，其中的实体主体是指body部分：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cibw7k636Y9k3xns3JuiapnxqgZzmqxXanpLUUk8VSYiclBGy1Gx4dgiawA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>URI/URL/URN</p><p>URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator, 统一资源定位符)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。</p><p>URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！</p><p>URL通常的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议方案+服务器地址+具体的资源路径</span><br></pre></td></tr></table></figure><p>协议方案(scheme)，如 <code>http</code>, <code>ftp</code>，告知web客户端怎样访问资源)；服务器地址，如 <code>www.oreilly.com</code>; 具体的资源路径，如 <code>index.html</code>.</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。这样，客户端可以获取即将请求资源的一些情况，可以做到心中有数。</p><p>POST用于向服务器发送数据，常见的是提交表单；PUT用于向服务器上的资源存储数据。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 OK 404 Not Found500 Internal Server Error</span><br></pre></td></tr></table></figure><p>我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是 <code>404NotFound</code>会穿透重重迷雾，来到我们面前，为何？那是因为他对我们爱的深沉啊！</p><p>客户端可以据此状态码，决定下一步的行动（如重定向等）。</p><p>三位数字的第一位表示分类：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cWscDzeA52lJGamzgqvAYianNebt2zoaHENFaJqrcOqjDTrTxgia5SGmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>HTTP报文实际上是由一行行的字符串组成的，每行字符串的末尾用 <code>\r\n</code>分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说 <code>0x0001</code>表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。不可能像HTTP协议这样，直接将字符编码，人类可以直接读懂。</p><p>举个简单的请求报文和响应报文的格式的例子：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cq5mHY7JwsGkIib9iazsoJk53tRRoc03B4GNgtLhpUjrsciaS0LGwW8nzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>实际上，请求报文也是可以有body（主体）部分的。请求报文是由 <code>请求行（request line）、请求头部（header）、空行、请求数据</code>四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的 <code>回车换行</code>符也是必须要有的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cozZdAPcASb3UUqYcqiaQuUvWgugEuaMu6Y3aiaxEia0ENTzVqvX8c9hgg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>响应报文的格式和请求报文的格式类似：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。</p><p>有些首部是通用的，有些则是请求或者响应报文才会有的。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后就可以通过这个通道直接发送HTTP请求数据，获取响应数据了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cFxrl1hgDlibWeYcEAMjgowiaZYLyf6FnsEuFr96UWxwicxDLLY44xPcuQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id="HTTP协议进阶"><a href="#HTTP协议进阶" class="headerlink" title="HTTP协议进阶"></a>HTTP协议进阶</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>HTTP的代理服务器既是Web服务器，又是Web客户端。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c98UALAtAUnx5oBJIOic3d9496dZl4NiaZQ9ZvQKxQq1VzzibvE4sr97xA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为 <code>反向代理</code>；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为 <code>内容转码器</code>; <code>匿名代理</code>会主动从HTTP报文中删除身份相关的信息，如 <code>User-Agent</code>, <code>Cookie</code>等字段。</p><p>现实中，请求通过以下几种方式打到代理服务器上去：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTVYicUUUFVOFN7jMXViaKEPaYicSLxlIEBYIribWicpuChGwah8gvtFImUQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。注意图中的via字段。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1PTaibUPaCtlroPcyicwRJoQUbWTqlVAGicicg359QyvdZsQmr3H0FjK4A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。</p><p>大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是 <code>If-Modified-Since</code>, 如果在xx时间(此时间即为If-Modified-Since的值)之后内容没有变化，服务器会回应一个 <code>304NotModified</code>. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为 <code>再验证命中</code>。</p><p>再验证可能出现命中或未命中的情况。未命中时，服务器回复 <code>200OK</code>，并且返回完整的数据；命中时，服务器回复 <code>304NotModified</code>; 还有一种情况，缓存被删除了，那么根据响应状态码，缓存服务器也会删除自己缓存的副本。</p><p>顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。</p><p>缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，再对一些首部字段做一些微调。比如向其中插入新鲜度信息（如 <code>Age</code>, <code>Expires</code>首部等），而且通常会包含一个 <code>via</code>首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改 <code>Date</code>字段，它表示原始服务器最初构建这条响应的日期。</p><p>HTTP通过 <code>文档过期机制</code>和 <code>服务器再验证机制</code>保持已缓存数据和服务器间的数据充分一致。</p><p>文档过期通过如下首部字段来表示缓存的有效期：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。如上表中提到的 <code>Expires</code>字段等。</p><p>为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个 <code>条件GET</code>请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。 <code>条件GET</code>请求会用到如下的字段：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cLIw08X75umvOGDoeZDlYcb74GDpKdsOAzRMnYt5p8KeptjE5ejaw6Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。</p><p>有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。</p><p>服务器在给客户端的响应字段首部加上 <code>Set-cookie</code>或 <code>Set-cookie2</code>, 值为 <code>名字=值</code>的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过 <code>Cookie</code>带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。</p><p>浏览器只会向产生这条cookie的站点发生cookie. <code>Set-cookie</code>字段的值会包含 <code>domain</code>这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。 <code>path</code>字段也是相似的功能。如i浏览器收到如下的cookie:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: user=&quot;mary&quot;; domain=&quot;stefno.com&quot;</span><br></pre></td></tr></table></figure><p>那么浏览器在访问任意以 <code>stefno.com</code>结尾的站点都会发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot;mary&quot;</span><br></pre></td></tr></table></figure><h2 id="实体和编码"><a href="#实体和编码" class="headerlink" title="实体和编码"></a>实体和编码</h2><p>响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果 <code>Content-Type</code>定义是 <code>text/plain</code>, 那说明body内容就是文本，我们直接按文本编码来解释；如果 <code>Content-Type</code>定义是 <code>image/png</code>, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。</p><p><code>Content-Length</code>标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外， <code>Content-Length</code>在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上 <code>Content-Length</code>字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的 <code>Content-Length</code>首部。</p><p>HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。</p><p>HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到 <code>Content-MD5</code>这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改 <code>Content-MD5</code>首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与 <code>Content-MD5</code>首部进行比较。这主要是防止代理对报文进行了无意的改动。</p><p>HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c3QiaTbXgX0sJtJicDibxDtN6wlniaHbgLSCwNiba2dXX12Z9jL5v12Gjshw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在 <code>Accept-Encoding</code>首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。</p><p>上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码： <code>传输编码</code>。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。</p><p>通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到 <code>Content-Length</code>中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到 <code>传输编码</code>来标注数据的结束的。</p><p>HTTP协议中通过如下两个首部来描述和控制传输编码：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>分块编码的报文形式是这样的：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckXIxrtbOKfscDcACkqLe3oOFeUOS25BxE4xBZ3zC0cvCibLMb3OicS2Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>每个分块包含一个长度值（十六进制，字节数）和该分块的数据。 <code>&lt;CR&gt;&lt;LF&gt;</code>用于区隔长度值和数据。长度值不包含分块中的任何 <code>&lt;CR&gt;&lt;LF&gt;</code>序列。最后一个分块，用长度值0来表示结束。注意报文首部包含一个 <code>Trailer:Content-MD5</code>, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如， <code>Content-Length</code>, <code>Trailer</code>, <code>Transfer-Encoding</code>也可以作为拖挂。</p><p>内容编码和传输编码是可以结合起来使用的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqvJ6263Sa8Ay3zGoGFqml8SWpzWtHL631ZTVqpRauJzoaNDltGeHibg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="国际化支持"><a href="#国际化支持" class="headerlink" title="国际化支持"></a>国际化支持</h2><p>HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，以及浏览器上安装了何种字母表编码算法。这通过 <code>Accept-Charset</code>和 <code>Accept-Language</code>首部实现。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: fr, en;q=0.8Accept-Charset: iso-8859-1, utf-8</span><br></pre></td></tr></table></figure><p>表示：客户端接受法语(fr, 优先级默认为1.0）、英语（en, 优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在 <code>Content-Type</code>首部里放上 <code>charset</code>.</p><p>本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码去字符集中找到对应的元素。</p><p>比较常见的字符集是 <code>US-ASCII</code>: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。可以再看下上文报文分析部分的acsii码集。</p><p><code>US-ASCII</code>是把每个字符编码成固定的7位二进制值。 <code>UTF-8</code>则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值，前两个bit位是用 <code>10</code>标识。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cJHSxBWJroo9TNWxXdoY9KiaPiaUYHLHaf77bqicIoQvYDKKDYPwtKqLIw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>举个例子，汉字“严”的Unicode编码为 <code>4E25</code>( <code>100111000100101</code>), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将 <code>100111000100101</code>填入上表中的 <code>c</code>位即可。因此，严的 <code>UTF-8</code>编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com.hk/search?q=%E4%B8%A5&amp;oq=%E4%B8%A5&amp;aqs=chrome..69i57j0l5.3802j0j4&amp;sourceid=chrome&amp;ie=UTF-8&amp;gws_rd=cr</span><br></pre></td></tr></table></figure><p><code>q=%E4%B8%A5</code>这个就是搜索的词了。</p><h2 id="重定向与负载均衡"><a href="#重定向与负载均衡" class="headerlink" title="重定向与负载均衡"></a>重定向与负载均衡</h2><p>Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。一般都会有所谓的“双活”，“多活”，所谓 <code>狡兔三窟</code>嘛。</p><p>这样，用户的请求会根据 <code>负载均衡</code>的原则，被 <code>重定向</code>到它应该去的地方。</p><h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>服务器收到客户端请求后，向客户端返回一条带有状态码 <code>302</code>重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用， <code>重定向</code>服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。</p><p>当然，缺点也是显而易见的，由于客户端要发送两次请求，因此会增加耗时。</p><h3 id="DNS重定向"><a href="#DNS重定向" class="headerlink" title="DNS重定向"></a>DNS重定向</h3><p>DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的 <code>轮转</code>；也可以是更高级的算法，如返回负载最轻的服务器的IP地址，称为 <code>负载均衡算法</code>；如果考虑地理位置，返回给客户端最近位置的地址，称为 <code>邻接路由算法</code>；还有一种是绕过出现故障的地址，称为 <code>故障屏蔽算法</code>。</p><p>DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。</p><h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>HTTP连接是HTTP报文传输的关键通道。</p><h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，速度会快起来。</p><p>如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqsP47SichhaMHESR59XzoJ1V635S2pk6AMQXMaBT4tqIDBIH3fhiccDA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>采用并行连接之后：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cyPg8tia0Y7V1b7CumlkvGcuicicNBEFZeatkJKbkf7gTWrfiaibKLcRMU5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。</p><p>另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP keep-alive机制</p><p>我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。</p><p>HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。</p><p>HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnp6MPI6YLshmc8PgDUv1jq8LUcbwBOiczicxiaMTqNOticYL70ONWSCnXQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>HTTP有keep-alive机制，目的是可以在一个TCP 连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcpsetkeepalive，来激活连接的keep-alive属性。</p><p>当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过 <code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcpkeepaliveprobes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试 <code>tcp_keepalive_probes</code>次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><h3 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h3><p>在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求按序放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。而且就算是服务端按序处理的，也不一定是按序返回给客户端，所以最好是在响应中附带一些可以标识请求的参数。</p><p>为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上，就是所有HTTP的通信细节了，足够在日常开发 作中使用了。更多没有涉及的细节可以在用到的时候再去仔细研究。</p><p>文章看完了，不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。</p><blockquote><p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p><p>如有冒犯，联系删除</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“三次握手，四次挥手”你真的懂吗？</title>
      <link href="/2019/03/28/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
      <url>/2019/03/28/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！</p><p>作为程序员，要有“刨根问底”的精神。知其然，更要知其所以然。这篇文章希望能抽丝剥茧，还原背后的原理。</p><h1 id="什么是“3次握手，4次挥手”"><a href="#什么是“3次握手，4次挥手”" class="headerlink" title="什么是“3次握手，4次挥手”"></a><strong>什么是“3次握手，4次挥手”</strong></h1><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h2 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a><strong>TCP服务模型</strong></h2><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a><strong>TCP头部</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF9sL0PPjOs0LotFFbWklFVlMPuGIp1ltEkbK0hIibHtzZsZRvn9Liaz4Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。<br>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。<br>SYN —— 用于初如化一个连接的序列号。<br>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a><strong>状态转换</strong></h2><p>三次握手和四次挥手的状态转换如下图。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFian001KXuKUicvYT7Pozrf2g50NrMtS2mPRuNYIWdgsSmplf8ic1KuV6g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h1 id><a href="#" class="headerlink" title=" "></a> </h1><h1 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a><strong>为什么要“三次握手，四次挥手”</strong></h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。</p><p>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。</p><p>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th>视角</th><th>客收</th><th>客发</th><th>服收</th><th>服发</th></tr></thead><tbody><tr><td>客视角</td><td>二</td><td>一 + 二</td><td>一 + 二</td><td>二</td></tr><tr><td>服视角</td><td>二 + 三</td><td>一</td><td>一</td><td>二 + 三</td></tr></tbody></table><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><h1 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a><strong>“三次握手，四次挥手”怎么完成？</strong></h1><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFYpRyHjvicckYBlR5ShkUOy9kXicV904eC9yjU8j0JvAowEWGW4KIT1kA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h2 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmo1F4q8mQmxymUCGFAiaIu26E7mw2mj8cYu1qicdE4PVOsVtFJFrJMrw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong></h2><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h1 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a><strong>“三次握手，四次挥手”进阶</strong></h1><h2 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a><strong>ISN</strong></h2><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><blockquote><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p></blockquote><p>M是一个计时器，每隔4毫秒加1。</p><p>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><p><strong>序列号回绕</strong></p><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><blockquote><p>*/**</p><p>*<em> The next routines deal with comparing 32 bit unsigned ints</em></p><p>*<em> and worry about wraparound (automatic with unsigned arithmetic).</em></p><p>*<em>/</em></p><p>static inline <strong>int</strong> before(<strong>u32 seq1, </strong>u32 seq2)</p><p>{</p><p>​    <strong>return</strong> (__s32)(seq1-seq2) &lt; 0;</p><p>}</p><p>#define after(seq2, seq1) before(seq1, seq2)</p></blockquote><p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><blockquote><p>假设seq1=255， seq2=1（发生了回绕）。</p><p>seq1 = 1111 1111 seq2 = 0000 0001</p><p>我们希望比较结果是</p><p>seq1 - seq2=</p><p>1111 1111</p><p>-0000 0001</p><p>-———-</p><p>1111 1110</p><p>由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为</p><p>0000 0001 + 1 = 0000 0010 = 2</p><p>因此seq1 - seq2 &lt; 0</p></blockquote><h2 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a><strong>syn flood攻击</strong></h2><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h3 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h3><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h3 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h3><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h4 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h4 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h3 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h3><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h2 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a><strong>连接队列</strong></h2><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmakH75iacmvjKuByYibR6kVbsichiaV2aEYYhTicKdPJXAlJTMCmMCibUmKw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><blockquote><p>查看是否有连接溢出</p><p>netstat -s | grep LISTEN</p></blockquote><h3 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a><strong>半连接队列满了</strong></h3><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFNI7SPfVDd7oQRIrGy3ribyxr8S6W46SJ58ZT5BAeibiahonct8nbIQcsQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>全连接队列满了</strong></p><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>命令</strong></p><p>netstat -s命令</p><blockquote><p>[root@server ~]#  netstat -s | egrep “listen|LISTEN”</p><p>667399 times the listen queue of a socket overflowed</p><p>667399 SYNs <strong>to</strong> LISTEN sockets ignored</p></blockquote><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><blockquote><p>[root@server ~]#  netstat -s | grep TCPBacklogDrop</p></blockquote><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><blockquote><p>[root@server ~]#  ss -lnt</p><p>State Recv-Q Send-Q Local Address:Port Peer Address:Port</p><p>LISTEN     0      128 <em>:6379 </em>:*</p><p>LISTEN     0      128 <em>:22 </em>:*</p></blockquote><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。</p><p>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h1 id="“三次握手，四次挥手”redis实例分析"><a href="#“三次握手，四次挥手”redis实例分析" class="headerlink" title="“三次握手，四次挥手”redis实例分析"></a><strong>“三次握手，四次挥手”redis实例分析</strong></h1><ol><li>我在dev机器上部署redis服务，端口号为6379,</li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><blockquote><p>tcpdump -w /tmp/a.cap port 6379 -s0</p><p>-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S0则会抓到完整数据包</p></blockquote><ol><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><blockquote><p>tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</p><p>（-x 以16进制形式展示，便于后面分析）</p></blockquote><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFuia4XyKt3j44V4px2Fic7zjGvfOLTyohocqo1YhWamm3OdibRchUZaADg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>它由固定长度20B+可变长度构成。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF1ock0p3DyjYPgkVc3icNcTmSQYwEmKJFPuibnGjxItx5IXnK9uOjc6jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>对着IP头部格式，来拆解数据包的具体含义。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFLUSiaJdMOtSxZMAPSUH2J0cMLFqiaVzA83WrqWBhXWCIfjCeOnu54cUg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>可变长度部分，协议如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFFiaC1F0oOwQX4mDye7HnszaFEdNO3vJRrZMw07dmywApRckbhK3jxJg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>这样第一个包分析完了。dev2向dev发送SYN请求。也就是三次握手中的第一次了。</p><p>SYN seq(c)=4133153791</p><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.</p><p>SYN ack=seq(c)+1 seq(s)=4264776963</p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.</p><p>ack=seq(s)+1, seq=seq(c)+1</p><p>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFiaYrAMKnowJDk3ntjD7GeyOX5myHgZ0wBRciaMOFonkwNZJXRSJjlOicQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792</p><p>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><blockquote><p>0x2a31         -&gt; *1</p><p>0x0d0a         -&gt; \r\n</p><p>0x2434         -&gt; $4</p><p>0x0d0a         -&gt; \r\n</p><p>0x7069 0x6e67  -&gt; ping</p><p>0x0d0a         -&gt; \r\n</p></blockquote><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。</p><p>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.</p><p>数据部分2b50 4f4e 470d 0a, 翻译过来就是+PONG\r\n.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><p><strong>总结</strong></p><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><p>所以，“三次握手，四次挥手”你真的懂了吗？</p><blockquote><p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p><p>如有冒犯，联系删除</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是HTTPS协议</title>
      <link href="/2019/03/27/%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/03/27/%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者 | 小   灰</p><p>责编 | 胡巍巍</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QibiajkGYjaNxI6pTvG3ehic6EktzRvZ4GD9PPsKuwaQLH4jVFbf92Kfdg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QnIBhBKXbcKDoX44n2YMvdqdHicJQNpyWReyib2PnhMTxSicSDumbWKRpw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QVq4x8hoGTrGwe7dfBCkhwgV9gD81KGQBsl9yPa7ic0uQIibcGxicsAxLw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmRdRTQTIs9muXtgY77wialvjWV8StsrkOa4hxqjrkia8ngZ2UKwTLkiaQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QiaicqJked2A0l9hYpwJVGtGhlV2KwGPUMqt1O1m6jr7FlRfbfC8ib95Jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Q6pFlukc21dcoEdfEJvRoyBYA5WJmQW32drgyv0Uw02icmsrKgY5TuOw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSPn6JHA3Zyickib2fUa1dUwEfpjrcmZnYDXtrD207nibjkHEjVWiaPSwGQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSln0sXSXHqrz7U1P5PQ05HwkBv5hPicWib2ic7qQpfVkhFiaqIf1559JaA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QImf2zKCHx6OTJZnV2pYARgwUMF53UicibRdgCJNrAowibo3X0cMPeJXFw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>什么是HTTP协议？</strong></p><p>HTTP协议全称Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于TCP/IP四层模型当中的应用层。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>HTTP协议通过请求/响应的方式，在客户端和服务端之间进行通信。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这一切看起来很美好，但是HTTP协议有一个致命的缺点：不够安全。</p><p>HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢？让我们打一个比方：</p><p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做中间人攻击。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>如何进行加密呢？</strong></p><p>小灰和小红可以事先约定一种对称加密方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这样做是不是就绝对安全了呢？并不是。</p><p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这可怎么办呢？别担心，我们可以使用非对称加密，为密钥的传输做一层额外的保护。</p><p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p><p>在小灰和小红建立通信的时候，小红首先把自己的公钥Key1发给小灰：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥Key2，并且用刚才接收的公钥Key1对Key2进行加密（这里有点绕），发送给小红：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>小红利用自己非对称加密的私钥，解开了公钥Key1的加密，获得了Key2的内容。从此以后，两人就可以利用Key2进行对称加密的通信了。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>是什么坏主意呢？中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。</p><p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>是什么解决方案呢？难道再把公钥进行一次加密吗？这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p><p>这时候，我们有必要引入第三方，一个权威的证书颁发机构（CA）来解决。到底什么是证书呢？证书包含如下信息：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p><p>流程如下：</p><p>1.作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmrhYBUv6aQ6RPpbEEWV4jnWURYvnB7QKKkCeLzwMZeicp8lytYms0yg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>3.当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QjQldYuHCKOcibkUMf7nhX0DD4EasCGcQS0os6suCO7fSxia7FjOYiaOzA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>4.小灰收到证书以后，要做的第一件事情是验证证书的真伪。</p><p>需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。</p><p>所以小灰只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p><p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p><p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥Key1。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QENwxMWjnWv6iaCM0JjG1faFyrEmPC6c1n2tZDIGo3icONyV91INJicAJA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>5.像之前一样，小灰生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给小红。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QKLTGwWJXwaHibic78VTbibpEIO5UBGCj1D0cVSFp1W32MKLQRGiaibYcTHg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>6.最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是两人开始用Key2进行对称加密的通信。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QxwRCiac136C5VLuNyVjFDG3teRNtwh1GmPvolrtpRcLxc8XeM2ibibyeQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢？</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QXVOiaHUuKTsf5Iqy360ukSZoM3jwPa9KiaMbmiakquh2MvF1Eg52wAbCQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QwOLtEPPhJToUf4EaQ6XvtNoJsoc9ibUWBYXJ8VPIl4Xo7ppnuc4icsxA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qy676yjvxP11icXgFDZER6iahoXLggnt84XUlg2nDSRgJdsbWNuRENBfg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qc73BXAGJgwvq8HwbU4IzorxmNNUujleX4buaugp3a2X1hUt3cLNSYA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QOThp6PEtNpia48W7vLtb5viauwJZW2rxfIRVOoNAT4UMXJa2Mo2QkNDQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QFibuV1f5f5lCG2ryskiaickbbW88icxFjibZKv7uQglyWcVicgVnicN96R0wQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QplvDw2aicOOm3R55rqB8mzO8Gia2l54JIInWnUFhTylD3C9mevf7DqYg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>注：最新推出的TLS协议，是SSL 3.0协议的升级版，和SSL协议的大体原理是相同的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QDg1EJYjK2vZfPbrZfHNy3gibl4vqJGIFsgqD3OK2iaLqFNq3IlTrkH3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>声明：本文为作者投稿，首发于个人公众号程序员小灰，版权归其所有。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arcpy开发&amp;关于arcgis中的api arcpy.Describe</title>
      <link href="/2019/03/18/arcpy%E5%BC%80%E5%8F%91&amp;%E5%85%B3%E4%BA%8Earcgis%E4%B8%AD%E7%9A%84api%20arcpy.Describe/"/>
      <url>/2019/03/18/arcpy%E5%BC%80%E5%8F%91&amp;%E5%85%B3%E4%BA%8Earcgis%E4%B8%AD%E7%9A%84api%20arcpy.Describe/</url>
      
        <content type="html"><![CDATA[<p>今天在学习关于工作空间相关知识，用于了下面的函数来实现判断当前输入的要素参数在哪个工作空间。其中主要运用到了arcpy.Describe函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_workspace</span><span class="params">(featureClass)</span>:</span></span><br><span class="line"> catalogPath = os.path.dirname(featureClass.catalogPath)</span><br><span class="line">    <span class="keyword">if</span> arcpy.Describe(catalogPath).dataType == <span class="string">'FeatureDataset'</span>:</span><br><span class="line">        arcpy.env.workspace = arcpy.Describe(catalogPath).path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        arcpy.env.workspace = featureClass.path</span><br><span class="line">    <span class="keyword">return</span> arcpy.env.workspace</span><br></pre></td></tr></table></figure><p>研究罢了，调试时查阅了Describe相关的参数，于是来看一下esri官方的参考文档，如下所说关于describe的种种：</p><p>Describe 函数返回的 Describe 对象包含多个属性，如数据类型、字段、索引以及许多其他属性。该对象的属性是动态的，这意味着根据所描述的数据类型，会有不同的描述属性可供使用。</p><p>Describe 属性被组织成一系列属性组。任何特定数据集都将至少获取其中一个组的属性。例如，如果要描述一个地理数据库要素类，您可访问 GDB 要素类、要素类、表和数据集属性组中的属性。所有数据，不管是哪种数据类型，总会获取通用 Describe 对象属性。</p><p>好了，说了这么多。我其实想说的是，可以使用describe查看数据的相关信息。比如shapeType、dataType、catalogPath、spatialReference等等相关信息。我们来看一下下面这一段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input_fc = <span class="string">'D:/Data/中国国界和省界的SHP格式数据/省界/bou2_4p.shp'</span></span><br><span class="line">desc = arcpy.Describe(input_fc)</span><br><span class="line">catalogPath = os.path.dirname(desc.catalogPath)</span><br><span class="line">dataType=arcpy.Describe(catalogPath).dataType</span><br><span class="line">dataType2=desc.dataType</span><br></pre></td></tr></table></figure><p>现在我们把pycharm断点打开，一一窥探该函数会给我们带来什么样的信息。具体如下图所示。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1552917456413.png" alt="1552917456413"></p><p>好了，关于describe的学习就到处为此了。</p>]]></content>
      
      
      <categories>
          
          <category> GIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIS; arcpy; python; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myFirstBlog</title>
      <link href="/2019/03/13/myFirstBlog/"/>
      <url>/2019/03/13/myFirstBlog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一则列表去重的思考</title>
      <link href="/2018/09/05/%E4%B8%80%E5%88%99%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/09/05/%E4%B8%80%E5%88%99%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>今天偶得休息,闲来无事悄悄代码,收到了一个这样的问题:</p><p>用两种或更多的方法实现对列表list1 = [1,1,2,3,3,5]进行去重。<br>时间紧任务急,博主现只写出了如下四种实现方式供大家参考,后续想到<br>更好的算法了再给大家分享,话不多说上代码,:</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>list1 = [1,1,2,3,3,5]</p><p>set1 = list(set(list1))</p><p>print(set1)</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>list2 = []</p><p>for i in range(len(list1)):<br>    if list1.index(list1[i]) == i:<br>        list2.append(list1[i])</p><p>print(list2)</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>list3 = [1,1,2,3,3,5]<br>for i in list3:<br>    if list3.count(i) 1:<br>        list3.pop(list3.index(i))</p><p>print(list3)</p><h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>list4 = []</p><p>for i in list1:<br>    if i not in list4:<br>        list4.append(i)</p><p>print(list4)</p><p>乍一看不觉这题难,对于接触过python的朋友来说,随手写出一两个不成问题,<br>但通过此事也意识到了,前面学过的知识还是要勤加复习避免遗忘,不说了博主要去复习了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 命令操作总结</title>
      <link href="/2018/08/17/git%20%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/17/git%20%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><ul><li><p>sudo apt-get intall git</p><blockquote><p>终端输入git 如果有提示证明安装成功</p></blockquote></li></ul><h3 id="2-git单人操作"><a href="#2-git单人操作" class="headerlink" title="2.git单人操作"></a>2.git单人操作</h3><ul><li><p>2.1 创建空的git仓库: git init</p><blockquote><p>提示: git仓库和项目的根路径在一起,用来管理项目</p></blockquote></li><li><p>2.2 配置git提交的用户名,邮箱</p><p>例如: git config user.name ‘zhangsan’</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; git config user.email <a href="mailto:&#39;111@qq.com" target="_blank" rel="noopener">&#39;111@qq.com</a>‘</p><blockquote><p>如果没有配置,默认使用的: home/.gitconfig  根目录下的用户信息</p></blockquote></li><li><p>2.3 查看文件状态: git status</p><blockquote><p>红色: 表示新建文件, 或者新修改了文件,目前位于工作区中</p><p>绿色: 表示文件在暂存区</p></blockquote></li><li><p>2.4将工作区代码, 添加到暂存区(工作区–&gt;暂存区)</p></li><li><p>例如: git add .  </p><p> &nbsp; &nbsp; &nbsp; git add xxx.py</p><blockquote><p>点表示添加所有变动,  xxx.py表示指定文件</p></blockquote></li><li><p>2.5将工作区代码,添加到仓库区(工作区—&gt;仓库区)</p></li><li><p>例如: git commit -m ‘注释’</p></li><li><p>2.6将工作区,直接添加到仓库区(工作区–&gt;暂存区—&gt;仓库区)</p></li><li><p>例如: git commit -am ‘注释信息’</p></li><li><p>2.7查看版本历史</p><p>例如: git log</p><p> &nbsp; &nbsp; &nbsp;  git reflog</p><blockquote><p>log查看详细信息, reflog查看简要信息</p></blockquote></li><li><p>2.8回退版本</p><p>例如: git reset –hard HEAD</p><p>或者: git reset –hard 版本号</p><blockquote><p>HEAD表示当前最新版本</p><p>HEAD^表示当前最新版本的,  上一个版本</p><p>HEAD^^表示当前最新版本的, 前两个版本, 依次类推</p><p>HEAD~1 表示当前最新版本的,  上一个版本</p><p>HEAD~2 表示当前最新版本的, 前两个版本, 依次类推</p></blockquote></li><li><p>2.9撤销工作区,暂存区修改</p><p>撤销工作区:  git checkout 文件名</p><p>撤销暂存区: </p><p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout HEAD 文件名 (暂存区-工作区)</p><p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout 文件名</p><blockquote><p>仓库区代码不能撤销</p></blockquote></li><li><p>2.10 版本对比</p><p>例如: git diff HEAD HEAD^ – xxx.py</p><blockquote><p>HEAD表示当前版本,   HEAD^表示上个版本, xxx.py对比的文件</p></blockquote></li><li><p>2.11误删除文件,恢复</p><p>格式1: rm 文件名</p><p>恢复1: git checkout – 文件名</p><p>格式2: git rm 文件名</p><p>恢复2: git reset –hard HEAD^</p></li></ul><h3 id="3-git多人操作"><a href="#3-git多人操作" class="headerlink" title="3.git多人操作"></a>3.git多人操作</h3><ul><li><p>3.1 clone项目到本地</p><p>例如: git clone 项目地址</p></li><li><p>3.2 推送项目到远程仓库</p><p>例如: git push</p><blockquote><p>第一次推送会提示输入账号, 密码</p></blockquote></li><li><p>3.3 配置是否输入登陆密码信息</p><blockquote><p>git config –global  credential.helper cache 十五分钟有效期</p><p>git config  credential.helper ‘cache –timeout==3600’ 一个小时有效期</p><p>git config –global credential.helper store 长期有效</p></blockquote></li><li><p>3.4 拉取远程最新代码到本地</p><p>例如: git pull</p></li></ul><h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4.标签"></a>4.标签</h3><ul><li><p>4.1 设置本地标签</p><p>例如: git tag -a  标签名 -m ‘标签描述’</p></li><li><p>4.2 推送本地标签到远程</p><p>例如: git push origin 标签名</p></li><li><p>4.3 删除本地标签</p><p>例如: git tag -d 标签名</p></li><li><p>4.4 删除远程标签</p><p>例如: git push origin –delete tag 标签名</p></li></ul><h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h3><ul><li><p>5.1查看当前分支</p><p>例如: git branch</p></li><li><p>5.2创建本地分支,并切换到指定分支</p><p>例如: git checkout -b 分支名</p></li><li><p>5.3推送本地分支,到远程</p><p>例如: git push -u origin 分支名</p></li><li><p>5.4切换分支</p><p>例如: git checkout master / dev</p><blockquote><p>切换到主分支,或者是其他分支</p><p>其他用户第一次pull代码后,切换切换后才能使用git branch查看</p></blockquote></li><li><p>5.5合并子分支到主分支</p><p>例如: git merge 分支</p><blockquote><p>需要在master分支下操作改命令</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git; 版本库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LivePreview无法正常工作</title>
      <link href="/2018/07/26/LivePreview%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/"/>
      <url>/2018/07/26/LivePreview%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>2018/7/26 22:28:25</p><p>自从搭建了个人博客,一直以来都是使用 MarkdownPad 2 来写Blog。近日由于重新安装了系统,想着把MarkdownPad 2再重新安装下,安装后却发现提示无法开启渲染预览,这能难道程序员吗?于是开始了bug查找,发现了如下提示:</p><pre><code>LivePreview is not working - it displays an error message stating This view has crashed!This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.To fix this issue, please try installing the Awesomium 1.6.6 SDK.If you continue to experience issues, please install Microsoft&apos;s DirectX End-User Runtimes.</code></pre><p>读后发现大概意思是需要下载安装Awesomium 1.6.6 SDK，OK,那就先试试 Awesomium 1.6.6 SDK.点击提示页面的下载链接地址，然后安装之后，重新启动MarkdownPad 2就可以正常使用了。</p><p>附带软件下载地址：</p><blockquote><p>MarkdownPad2破解版本地址：链接: <a href="https://pan.baidu.com/s/1dF6C1MT" target="_blank" rel="noopener">https://pan.baidu.com/s/1dF6C1MT</a> 密码: j3cy</p></blockquote><blockquote><p>awesomium软件下载地址：链接: <a href="https://pan.baidu.com/s/1nvRuNaT" target="_blank" rel="noopener">https://pan.baidu.com/s/1nvRuNaT</a> 密码: e7t2 </p></blockquote><p>很多人不太喜欢试用版,试用版功能不全,下面附带注册码激活使用:</p><p>打开markdownpad2 –&gt; 帮助 –&gt;升级为专业版<br>按照如下输入：<br>​</p><blockquote><p>邮箱地址：<a href="mailto:Soar360@live.com" target="_blank" rel="noopener">Soar360@live.com</a></p></blockquote><blockquote><p>授权秘钥：<br>    GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客出现command not found解决方案</title>
      <link href="/2018/07/26/hexo%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0command-not-found%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/07/26/hexo%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0command-not-found%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>2018/7/26 22:14:17</p><p>自从上次更新了博客后,后来就开始了正式的学习,由于电脑升级的原因考虑到今后需要用到的软件会比较多,现在用的电脑配置有点低了,所以对电脑进行了一次小升级购买了固态后重装了系统,以致于之前的博客文件和配置的环境出现了问题,导致不能正常上传博客文件,后来课程太紧,一拖再拖没有来及解决这个问题.</p><p>今天去网上看了下,发现有很多这样的问题,重装系统后会出现command not found提示,接下来就是一波百度,寻找解决办法,发现个办法都有瑕疵并不能一次完美解决.</p><p>最后决定还是使用最粗暴的办法吧,也避免出现一些环境,插件缺少的问题,于是按照我之前写的教程开始了重新配置,安装完毕之后,首先查看各种工具是否都安装好了，在命令行中输入<code>node -v</code><br>然后再检查<code>npm -v</code>,<br>这些都没有问题的话,接下来检查下环境变量有没有配置,如果发现没有配置的话,可以先去找到这个路径，<code>C:\Users\feng\node_modules\hexo\bin</code>，然后把它添加到环境变量PATH路径的后面。这样基本就配置完成了.</p><p>提示:如果发现安装过程存在,使用淘宝NPM镜像，输入以下命令安装  cnpm, <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>,时出错的情况,可以检查下你的git和node的版本,笔者此前出现过因为版本过高而不能正常安装的问题.希望能给大家提供帮助.</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中if __name__ == &quot;__main__&quot;是什么作用</title>
      <link href="/2018/04/15/Python%E4%B8%ADif-name-name-main/"/>
      <url>/2018/04/15/Python%E4%B8%ADif-name-name-main/</url>
      
        <content type="html"><![CDATA[<p>2018/4/15 22:19:35 </p><hr><ul><li>最近在写毕业论文使用到Python，在查找文献资源中看到了一行代码<br><code>Python中if __name__ == &quot;__main__:&quot;</code>之前练习Python并没有注意这个，也可能太就给忘了，为了搞清这个语句于是开始疯狂百度，各种论坛博客搜索，最终找到了这个语句的作用个人感觉最易懂的解释，分享给大家</li><li>python文件的后缀名是.py，python文件既可以用来直接执行，也可以作为模块被导入。<br>我们在使用python时经常会看到<code>Python中if __name__ == &quot;__main__:&quot;</code>这样一个句子,这是什么呢？<br>其中name是模块的内置属性，而这个内置属性的值取决于这个.py文件的使用方式，即你是作为模块导入还是直接执行。<br>如果你是直接执行，那么这个name的值就是’main’，如果你作为一个模块导入，那么这个内置属性值就取决于这个文件名(不包含路径和文件扩展名)。<br>所以我们在看到一个这样的句子<code>Python中if __name__ == &quot;__main__&quot;:</code>时，就是文件在执行时要执行这个main()函数</li></ul><hr><p>附上一张号称一篇程序覆盖Python基础的代码，基本的结构都涉及到了，看不清的话保存本地放大看吧。<br><img src="https://img-blog.csdn.net/20160511222649275" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用MarkdownX编写博文</title>
      <link href="/2018/04/09/%E7%94%A8MarkdownX%E7%BC%96%E5%86%99%E5%8D%9A%E6%96%87/"/>
      <url>/2018/04/09/%E7%94%A8MarkdownX%E7%BC%96%E5%86%99%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>2018/4/9 22:19:02    </p><hr><ul><li><p>　博客搭建好后，尽管下午没事用手机查询Markdown教程，可是搜了一圈发现网上的教程参差不齐，还不如直接用html编写博文，可是想到Markdown的初衷就是方便编写博文，于是想会不会有些工具使Markdown的编写自动化了，果然搜到了一篇用MarkdownX的于是下载下来试用一番，发现挺容易入手的。</p></li><li><p>　一个优秀的产品就应该这样让人尽量容易上手，不必拘于太多的条条框框，但Markdown毕竟还是有些功能不易实现，所以下一步准备尝试使用html+css制作一些漂亮的静态页面。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
