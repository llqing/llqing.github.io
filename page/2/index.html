<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>GIS小站</title>
  
  <meta name="keywords" content="GIS,Code">
  
  

  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  
  <meta name="theme-color" content="#FFFFFF">
  <meta name="msapplication-TileColor" content="#1BC3FB">
  <meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/browserconfig.xml">
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  
  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  <link rel="icon" type="image/x-icon" sizes="32x32" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/favicon-32x32.png">
  <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/apple-touch-icon.png">
  <link rel="mask-icon" color="#1BC3FB" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/safari-pinned-tab.svg">
  <link rel="manifest" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicons/site.webmanifest">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  
  <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>


<body>
    <div id="loading-bar-wrapper">
  <div id="loading-bar" class="material"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header material">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          GIS小站
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:llqing.github.io" class="nav flat-box" href="https://llqing.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="home" class="nav flat-box" href="/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;博客
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="friends" class="nav flat-box" href="/friends/">
									<i class="fas fa-users fa-fw"></i>&nbsp;朋友
								</a>
							</li>
      			
  						<li>
								<a id="about" class="nav flat-box" href="/about/">
									<i class="fas fa-archive fa-fw fa-fw"></i>&nbsp;about
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:llqing.github.io" class="nav flat-box" href="https://llqing.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="home" class="nav flat-box" href="/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;博客
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="friends" class="nav flat-box" href="/friends/">
											<i class="fas fa-users fa-fw"></i>&nbsp;朋友
										</a>
                  </li>
              
                  <li>
										<a id="about" class="nav flat-box" href="/about/">
											<i class="fas fa-archive fa-fw fa-fw"></i>&nbsp;about
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            



  <section class="post-list">
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2019/03/30/为什么你得学些TCP知识/">
              
                  为什么你得学些TCP知识
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-03-30
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/web基础/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              web基础
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>这不是指要明白 TCP 的所有东西，也不是说要通读 《TCP/IP 详解》。不过懂一点 TCP 知识是很有必要的。理由如下：</p>
<p>当我还在 Recurse Center 的时候，我用 Python 写过 TCP 协议栈（还写过一篇文章：如果你用 Python 写 TCP 协议栈会遇到什么？）。这是一次有趣的学习经历，但是也仅此而已。</p>
<p>一年以后，工作中有人在 Slack 上提到：“嘿，我在向 NSQ 发布消息时，每次要耗费 40 毫秒”。我已经断断续续思考了一个星期，但是没有任何结果。</p>
<p>一点背景知识：NSQ 是一个消息队列，你通过本地的一个 HTTP 请求向其发布消息。发送本地的一个 HTTP 请求确实不应该花费 40 毫秒，有时候会更差。NSQ 守护进程的负载不高，也没有使用过多的内存，也看不到 GC 停顿。这究竟是为什么呢？神呐，救救我吧！</p>
<p>突然我记起我一周以前看过的一篇叫做“性能研究（In search of performance）”的文章——我们如何为每个 POST 请求节省 200ms。在这篇文章中，他们说到为什么每个 POST 请求会花费额外的 200 毫秒。就是这个原因。这是该文章中的关键段落：</p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="延迟确认（ACK）-与-TCP-NODELAY"><a href="#延迟确认（ACK）-与-TCP-NODELAY" class="headerlink" title="延迟确认（ACK） 与 TCP_NODELAY"></a><strong>延迟确认（ACK） 与 TCP_NODELAY</strong></h3><blockquote>
<p>Ruby 的 Net::HTTP 会将 POST 请求切分为两个 TCP 包，一个消息头，一个消息体。相反，curl 会将这两者合并为一个包。更糟糕的是，Net::HTTP 在打开 TCP 套接字时不会设置 TCP_NODELAY，这将导致第二个包需要等到第一个包的接收确认通知之后才能发送。这是 Nagle 算法导致的。</p>
</blockquote>
<blockquote>
<p>转换到连接的另一端，HAProxy 需要决定如何确认这两个包。在 1.4.18 版本中（我们正在用的版本），它是通过 TCP 延迟确认通知来实现的。延迟确认对 Nagle 算法有非常糟糕的影响，会导致请求暂停直到服务器延迟确认超时。</p>
</blockquote>
<p>现在我们解释这个段落说的内容。</p>
<ul>
<li>TCP 是一个通过数据包传输数据的算法</li>
<li>他们的 HTTP 库将 POST 请求分割成两个小的数据包发送</li>
</ul>
<p>接下来，TCP 采用类似如下的步骤进行交互：</p>
<blockquote>
<p>application：Hi！这里有一个数据包。<br>HAProxy：（沉默），等待第二个包发送<br>HAProxy：对了，我需要返回一个确认，不过没关系，等会吧<br>application: （沉默）<br>application：好吧，我正在等待确认，可能现在网络延迟比较大<br>HAProxy：好吧，太烦人了，这是一个确认。<br>application：好极了，这是第二个数据包！！！<br>HAProxy：亲，我们已经搞定了。</p>
</blockquote>
<p>这个过程是不是应用程序和 HAProxy 都在消极等待另一方发送信息？这就是那额外的 200ms。应用程序这么做的是因为 Nagle 算法，而 HAProxy 消息等待的原因是延迟确认。</p>
<p>据我所知，延迟确认是所有 Linux 系统的默认行为。所以这不是一个偶然或者异常情况，如果发送 TCP 数据包多一个 1 个，你就会遇到这种情况。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="现在，我们成为专家了"><a href="#现在，我们成为专家了" class="headerlink" title="现在，我们成为专家了"></a><strong>现在，我们成为专家了</strong></h3><p>读过这篇文章之后我很快就忘了。不过当我被额外的 40 毫秒难住的时候，我又记起来了。</p>
<p>所以我认为——这不可能是我的问题，可能吗？可能吗？？然后我发了一封邮件给我团队说：“我想我快要疯了，但是这可能是 TCP 的问题”。</p>
<p>所以我提交了一次修订，将我的应该调整为 TCP_NODELAY，然后问题就“嘣”的一声解决了。</p>
<p>40 毫秒的延迟立马就消失了。所有的事情都解决了，我就是个天才。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="我们是否应该完全停止使用延迟确认？"><a href="#我们是否应该完全停止使用延迟确认？" class="headerlink" title="我们是否应该完全停止使用延迟确认？"></a><strong>我们是否应该完全停止使用延迟确认？</strong></h3><p>我刚好在 Hacker News 看到 John Nagle （Nagle 算法的创始人）对 @alicemazzy 提到这个问题的评论。</p>
<blockquote>
<p>本质问题是延迟确认。200 毫秒的“延迟确认”是一个非常不好的主意，1985 年中，在伯利克（Berkeley）研究 BSD 的人实际上没有真正明白这个问题。延迟确认是应用层对 200 毫秒内是否响应的一场赌博，但是即便每次它都赌输了，TCP 仍在使用延迟确认。</p>
</blockquote>
<p>他继续说到，确认本身是很小并且消耗很低的，延迟确认引起的问题可能比它解决的问题还要多。</p>
<h3 id="不懂得-TCP-你就无法解决-TCP-问题"><a href="#不懂得-TCP-你就无法解决-TCP-问题" class="headerlink" title="不懂得 TCP 你就无法解决 TCP 问题"></a><strong>不懂得 TCP 你就无法解决 TCP 问题</strong></h3><p>我曾经也认为，TCP 是一个相当底层的问题，我不需要明白。大多数时候你的确不需要明白。但是有的时候，当你在实践中遇到由于 TCP 算法引起的 bug 时，懂点 TCP 知识就变得非常重要了。（正如我们经常在博客中讨论的，许多事情都是这样，比如系统调用和操作系统:) ）</p>
<p>延迟确认及 TCP_NODELAY 的交互非常不好——这对任何语言实现的 HTTP 请求都有影响。你不需要很深入的去了解，成为系统程序专家。但是了解一点 TCP 是如何运作的，对我的工作的确大有裨益。通过对 TCP 的学习，我才意识到这篇博客所描述的问题也许正好是我所熟悉的领域。我也一直在使用 strace，并且会一直使用下去。</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/TCP/"><i class="fas fa-hashtag fa-fw"></i>TCP</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2019/03/29/深度解密HTTP通信细节/">
              
                  深度解密 HTTP 通信细节
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-03-29
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/web基础/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              web基础
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>在上一篇《<a href="https://llqing.github.io/2019/03/28/san-ci-wo-shou-si-ci-hui-shou-ni-zhen-de-dong-ma/" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a>》中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的 <code>锤子</code>，拿着 <code>锤子</code>，看什么都像 <code>钉子</code>！在这篇文章中，我对准了 <code>HTTP</code>这颗钉子砸下去，咳咳。</p>
<p>为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我则是把复杂的东西撕碎了给人看。</p>
<p>文章稍长，请在看本文时保持耐心。我先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！</p>
<p>为了更好的阅读体验，我手动贴上本文的目录：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cjHbwiaFiaXcneDwD5tV48jf8JedJ22VnrWluok7iaZyP2aHSUfTeaRW9A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h1 id="HTTP报文截获"><a href="#HTTP报文截获" class="headerlink" title="HTTP报文截获"></a>HTTP报文截获</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我手头现在有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是 <code>Fence2Area</code>. 使用方传入一个围栏（由点的列表组成，点由&lt;经度，纬度&gt;表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。</p>
<p>我请求服务的“Fence2Area”接口，输入围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，输出的则是多边形的面积(area).</p>
<p>一次正常的请求示例url, 这个大家都不陌生（我用docker_ip代替真实的ip）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure>
<p>请求发出后，服务器进行处理，之后，客户端收到返回的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;data&quot;: &#123;        &quot;area&quot;: 48764135597.842606    &#125;,    &quot;errstr&quot;: &quot;&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><code>area</code>字段表示面积， <code>errstr</code>表示出错信息，空说明没有出错。</p>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>在真正发送请求之前，需要进行抓包前的设置。在本地mac，我用wireshark; 而在远程docker上，我用tcpdump工具。</p>
<h3 id="mac本地"><a href="#mac本地" class="headerlink" title="mac本地"></a>mac本地</h3><p>设置wireshark包过滤器，监控本地主机和远程docker之间的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr eq docker_ip</span><br></pre></td></tr></table></figure>
<p>点击开始捕获。</p>
<h3 id="远程docker"><a href="#远程docker" class="headerlink" title="远程docker"></a>远程docker</h3><p>该服务通过7080端口对外提供，使用如下命令捕获网络包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w /tmp/testHttp.cap port 7080 -s0</span><br></pre></td></tr></table></figure>
<h2 id="请求-amp-amp-分析"><a href="#请求-amp-amp-分析" class="headerlink" title="请求 &amp;&amp; 分析"></a>请求 &amp;&amp; 分析</h2><p>准备工作做完，我选了一个神圣的时刻，在本地通过浏览器访问如下url:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://docker_ip:7080/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure>
<p>这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。</p>
<h3 id="关闭服务进程"><a href="#关闭服务进程" class="headerlink" title="关闭服务进程"></a>关闭服务进程</h3><p>正式请求之前，我们先看一下几种特殊的情形。</p>
<p>首先，关闭gcs服务进程，请求直接返回RST报文。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1ib1lViaLiaASe6wCNRxwB8Xu769ic09sS7T7GbjkibZ1PUiae36SP7D4ntg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>如上图，我在请求的时候，访问服务端的另一个端口 <code>5010</code>, 这个端口没有服务监听，和关闭gcs服务进程是同样的效果。可以看到，客户端发送SYN报文，但直接被远程docker RST掉了。因为服务端操作系统找不到监听此端口的进程。</p>
<h3 id="关闭docker"><a href="#关闭docker" class="headerlink" title="关闭docker"></a>关闭docker</h3><p>关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbJoZcwl0vLPpwOqVb8B6XiaveJosgAibblK0IXaicGVEPXC1poXhQEohw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。</p>
<h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><p>先进行一次正常的访问，随后重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，访问到服务端后，因为它已经重启了，所以服务端已经没有这个连接的消息了。因此会返回一个RST报文。</p>
<h3 id="正常请求"><a href="#正常请求" class="headerlink" title="正常请求"></a>正常请求</h3><p>服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckxkrMtp9vRhDDluuIBFDcK8tyfSNq6Mibu1bFL83korLAUfUyxT8qKg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为 <code>HTTP</code>层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在 <code>HTTP</code>层发送的响应数据，第七个包为mac对第六个包的确认报文。</p>
<p>重点来关注后面几个包，先看第四个包，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0295 0000 4000 3606 623b ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d0x0020:  8018 1015 0ee7 0000 0101 080a 2e4c b2ef0x0030:  0f20 3acf 4745 5420 2f64 6174 613f 636d0x0040:  643d 4665 6e63 6532 4172 6561 266d 65740x0050:  613d 7b25 3232 6361 6c6c 6572 2532 323a0x0060:  2532 3274 6573 7425 3232 2c25 3232 54720x0070:  6163 6549 6425 3232 3a25 3232 7465 73740x0080:  2532 327d 2672 6571 7565 7374 3d7b 25320x0090:  3266 656e 6365 2532 323a 5b7b 2532 326c0x00a0:  6e67 2532 323a 3130 2e32 2c25 3232 6c610x00b0:  7425 3232 3a31 302e 327d 2c25 3230 7b250x00c0:  3232 6c6e 6725 3232 3a31 302e 322c 25320x00d0:  326c 6174 2532 323a 382e 327d 2c25 32300x00e0:  7b25 3232 6c6e 6725 3232 3a38 2e32 2c250x00f0:  3232 6c61 7425 3232 3a38 2e32 7d2c 25320x0100:  307b 2532 326c 6e67 2532 323a 382e 322c0x0110:  2532 326c 6174 2532 323a 3130 2e32 7d5d0x0120:  2c25 3232 636f 6f72 6474 7970 6525 32320x0130:  3a32 7d20 4854 5450 2f31 2e31 0d0a 486f0x0140:  7374 3a20 3130 2e39 362e 3932 2e32 31320x0150:  3a37 3038 300d 0a55 7067 7261 6465 2d490x0160:  6e73 6563 7572 652d 5265 7175 6573 74730x0170:  3a20 310d 0a41 6363 6570 743a 2074 65780x0180:  742f 6874 6d6c 2c61 7070 6c69 6361 74690x0190:  6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 70700x01a0:  6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d300x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 55730x01c0:  6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c0x01d0:  612f 352e 3020 284d 6163 696e 746f 73680x01e0:  3b20 496e 7465 6c20 4d61 6320 4f53 20580x01f0:  2031 305f 3133 5f36 2920 4170 706c 65570x0200:  6562 4b69 742f 3630 352e 312e 3135 20280x0210:  4b48 544d 4c2c 206c 696b 6520 4765 636b0x0220:  6f29 2056 6572 7369 6f6e 2f31 322e 302e0x0230:  3220 5361 6661 7269 2f36 3035 2e31 2e310x0240:  350d 0a41 6363 6570 742d 4c61 6e67 75610x0250:  6765 3a20 7a68 2d63 6e0d 0a41 6363 65700x0260:  742d 456e 636f 6469 6e67 3a20 677a 69700x0270:  2c20 6465 666c 6174 650d 0a43 6f6e 6e650x0280:  6374 696f 6e3a 206b 6565 702d 616c 69760x0290:  650d 0a0d 0a</span><br></pre></td></tr></table></figure>
<p>我们来逐字节分析。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cESQM7mPYK50BUdqRtB4qISMY5VjrFYEL4fEVDMgMquTHMqhekaY2AA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTZn8gROeqs1ncqfs0lrbUic92cGeHU3xrZr76pslib22mnVPmXjz3DOA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>可变长度部分，协议如下：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure>
<p>可以得到ascii码，我们直接看十六进制的结果：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c0dZYr61gHv0qYGlBIVEM3zr6RIxqxW2s7ia5lRnAkgLzQVCfeovialmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cPt3Eicksdp2tfV1hJJcRPLib1SFEGno5wwa9rtDaQJOomYhp9focEribQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>把上表的最后一列连起来，就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125; HTTP/1.1 Host: 10.96.92.212:7080 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15 Accept-Language: zh-cn Accept-Encoding: gzip, deflate Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>其中，cr nl表示回车，换行。</p>
<p>docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。另外，序列号为2778351310.</p>
<p>再来看第5个包，字节流如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 d28b 4000 4006 8810 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8010 00ec e04e 0000 0101 080a 0f20 3af70x0030:  2e4c b2ef</span><br></pre></td></tr></table></figure>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cAZEWxWx96R82g4YMAKmw1BAibT6xxBcL1kjJf3fGaUqDFLGNLjleFsA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cbI0RpST1AwXnJm99vUPedSEW5vsjxhIMfpnnVPqUMMfpib6ibkkWEcTQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>可变长度部分，协议如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnkkiao15MgfVBSI2lAicn9OKJwwmppIic9fxfpJkH5nHOyaoKGtnP8iakQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>数据部分为空，这个包仅为确认包。</p>
<p>再来看第六个包，字节流如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 00f9 d28c 4000 4006 874a 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8018 00ec e113 0000 0101 080a 0f20 3af80x0030:  2e4c b2ef 4854 5450 2f31 2e31 2032 30300x0040:  204f 4b0d 0a41 6363 6573 732d 436f 6e740x0050:  726f 6c2d 416c 6c6f 772d 4f72 6967 696e0x0060:  3a20 2a0d 0a44 6174 653a 2054 6875 2c200x0070:  3033 204a 616e 2032 3031 3920 3132 3a320x0080:  333a 3437 2047 4d54 0d0a 436f 6e74 656e0x0090:  742d 4c65 6e67 7468 3a20 3438 0d0a 436f0x00a0:  6e74 656e 742d 5479 7065 3a20 7465 78740x00b0:  2f70 6c61 696e 3b20 6368 6172 7365 743d0x00c0:  7574 662d 380d 0a0d 0a7b 2264 6174 61220x00d0:  3a7b 2261 7265 6122 3a34 3837 3634 31330x00e0:  3535 3937 2e38 3432 3630 367d 2c22 65720x00f0:  7273 7472 223a 2222 7d</span><br></pre></td></tr></table></figure>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c4iaw0WsWa7KbicwicrJbrVm82c1z3OOQuCBG8MnezL90gSGbEWv5p1wLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>可变长度部分，协议如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0chROjPEbF98pwdNNGm56BqMY5TJhQ4UCMZQibicgkxxJum4EkLSoDKyHA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>剩下来的就是数据部分了。我们一行一行地看。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cf9reib3oq2gOJVfkdHdEafO0t7ZibzwACqJl9F1BVonYzlXOib1orDpiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>把上表的最后一列连起来，就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK Access-Control-Allow-Origin: * Date: Thu, 03 Jan 2019 12:23:47 GMT Content-Length: 48 Content-Type: text/plain; charset=utf-8 &#123;&quot;data&quot;:&#123;&quot;area&quot;:48764135597.842606&#125;,&quot;errstr&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>Content-Length: 48，最后一行的长度即为48个字节。</p>
<p>最后，第七个包，字节流如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000:  4500 0034 0000 4000 3606 649c ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e9420x0020:  8010 100f 1eb9 0000 0101 080a 2e4c b3140x0030:  0f20 3af8</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0czCoePYTJlUT7ry6wUOC5sib1phKyp1odVXVHxGwmCVjZAxHfnQ6ugrA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>可变长度部分，协议如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cQcJTJtCqC5uUlc8fH3gCIvcR8FV3ayZu6LIBXVR32aUJGHDLK2Al8g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>至此，一次完整的http请求的报文就解析完了。感觉如何，是不是很亲切？</p>
<h1 id="HTTP协议分析"><a href="#HTTP协议分析" class="headerlink" title="HTTP协议分析"></a>HTTP协议分析</h1><p>上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步带你深入理解HTTP协议。</p>
<h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><p><code>HTTP</code>(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。说得更形象一点： <code>HTTP</code>是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。</p>
<p>HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cd3E2bpHQ1JibJo1Cks0PtU75BD8UsUZQMIuutqGxuxDXqIbJicibk0NiaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>HTTP在传输一段报文时，会以 <code>流</code>的形式将报文数据的内容通过 <code>一条打开</code>的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cvS3b6LIgaPLTfa4gdcLHKRMQV8A4mZF0Gux7vhwiapGLyB2tYFrrFew/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们再来回顾一下：</p>
<p>原始的url值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;&#125;&amp;request=&#123;&quot;fence&quot;:[&#123;&quot;lng&quot;:10.2,&quot;lat&quot;:10.2&#125;, &#123;&quot;lng&quot;:10.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:8.2&#125;, &#123;&quot;lng&quot;:8.2,&quot;lat&quot;:10.2&#125;],&quot;coordtype&quot;:2&#125;</span><br></pre></td></tr></table></figure>
<p>编码后的url值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data?cmd=Fence2Area&amp;meta=&#123;%22caller%22:%22test%22,%22TraceId%22:%22test%22&#125;&amp;request=&#123;%22fence%22:[&#123;%22lng%22:10.2,%22lat%22:10.2&#125;,%20&#123;%22lng%22:10.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:8.2&#125;,%20&#123;%22lng%22:8.2,%22lat%22:10.2&#125;],%22coordtype%22:2&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的报文拆解过程中，我们看到多了很多 <code>%22</code>，其实， <code>0x22</code>是单引号 <code>&quot;</code>的ascii值，</p>
<p>一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，比如空格；最后，URL还得是完整的，它需要支持所有语言的字符。</p>
<p>总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。</p>
<p>转义的方法：百分号( <code>%</code>)后跟着两个表示ASCII码的十六进制数。比如：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ca1ibSClFurjoccZUHYENZbYZrf2opPyvfdM8Ll5770Uic6YaVsZXbLVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。</p>
<h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p>响应数据中，我们注意到有一个首部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/plain; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的 <code>Content-Type</code>. MIME本来是用在邮件协议中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，是该展示图片，还是调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表展示了一些常见的类型，其中的实体主体是指body部分：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cibw7k636Y9k3xns3JuiapnxqgZzmqxXanpLUUk8VSYiclBGy1Gx4dgiawA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>URI/URL/URN</p>
<p>URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator, 统一资源定位符)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。</p>
<p>URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！</p>
<p>URL通常的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议方案+服务器地址+具体的资源路径</span><br></pre></td></tr></table></figure>
<p>协议方案(scheme)，如 <code>http</code>, <code>ftp</code>，告知web客户端怎样访问资源)；服务器地址，如 <code>www.oreilly.com</code>; 具体的资源路径，如 <code>index.html</code>.</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。这样，客户端可以获取即将请求资源的一些情况，可以做到心中有数。</p>
<p>POST用于向服务器发送数据，常见的是提交表单；PUT用于向服务器上的资源存储数据。</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 OK 404 Not Found500 Internal Server Error</span><br></pre></td></tr></table></figure>
<p>我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是 <code>404NotFound</code>会穿透重重迷雾，来到我们面前，为何？那是因为他对我们爱的深沉啊！</p>
<p>客户端可以据此状态码，决定下一步的行动（如重定向等）。</p>
<p>三位数字的第一位表示分类：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cWscDzeA52lJGamzgqvAYianNebt2zoaHENFaJqrcOqjDTrTxgia5SGmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>HTTP报文实际上是由一行行的字符串组成的，每行字符串的末尾用 <code>\r\n</code>分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说 <code>0x0001</code>表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。不可能像HTTP协议这样，直接将字符编码，人类可以直接读懂。</p>
<p>举个简单的请求报文和响应报文的格式的例子：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cq5mHY7JwsGkIib9iazsoJk53tRRoc03B4GNgtLhpUjrsciaS0LGwW8nzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>实际上，请求报文也是可以有body（主体）部分的。请求报文是由 <code>请求行（request line）、请求头部（header）、空行、请求数据</code>四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的 <code>回车换行</code>符也是必须要有的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cozZdAPcASb3UUqYcqiaQuUvWgugEuaMu6Y3aiaxEia0ENTzVqvX8c9hgg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>响应报文的格式和请求报文的格式类似：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。</p>
<p>有些首部是通用的，有些则是请求或者响应报文才会有的。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后就可以通过这个通道直接发送HTTP请求数据，获取响应数据了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cFxrl1hgDlibWeYcEAMjgowiaZYLyf6FnsEuFr96UWxwicxDLLY44xPcuQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h1 id="HTTP协议进阶"><a href="#HTTP协议进阶" class="headerlink" title="HTTP协议进阶"></a>HTTP协议进阶</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>HTTP的代理服务器既是Web服务器，又是Web客户端。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c98UALAtAUnx5oBJIOic3d9496dZl4NiaZQ9ZvQKxQq1VzzibvE4sr97xA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为 <code>反向代理</code>；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为 <code>内容转码器</code>; <code>匿名代理</code>会主动从HTTP报文中删除身份相关的信息，如 <code>User-Agent</code>, <code>Cookie</code>等字段。</p>
<p>现实中，请求通过以下几种方式打到代理服务器上去：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cTVYicUUUFVOFN7jMXViaKEPaYicSLxlIEBYIribWicpuChGwah8gvtFImUQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。注意图中的via字段。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c1PTaibUPaCtlroPcyicwRJoQUbWTqlVAGicicg359QyvdZsQmr3H0FjK4A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。</p>
<p>大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是 <code>If-Modified-Since</code>, 如果在xx时间(此时间即为If-Modified-Since的值)之后内容没有变化，服务器会回应一个 <code>304NotModified</code>. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为 <code>再验证命中</code>。</p>
<p>再验证可能出现命中或未命中的情况。未命中时，服务器回复 <code>200OK</code>，并且返回完整的数据；命中时，服务器回复 <code>304NotModified</code>; 还有一种情况，缓存被删除了，那么根据响应状态码，缓存服务器也会删除自己缓存的副本。</p>
<p>顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。</p>
<p>缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，再对一些首部字段做一些微调。比如向其中插入新鲜度信息（如 <code>Age</code>, <code>Expires</code>首部等），而且通常会包含一个 <code>via</code>首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改 <code>Date</code>字段，它表示原始服务器最初构建这条响应的日期。</p>
<p>HTTP通过 <code>文档过期机制</code>和 <code>服务器再验证机制</code>保持已缓存数据和服务器间的数据充分一致。</p>
<p>文档过期通过如下首部字段来表示缓存的有效期：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。如上表中提到的 <code>Expires</code>字段等。</p>
<p>为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个 <code>条件GET</code>请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。 <code>条件GET</code>请求会用到如下的字段：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cLIw08X75umvOGDoeZDlYcb74GDpKdsOAzRMnYt5p8KeptjE5ejaw6Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。</p>
<p>有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。</p>
<p>服务器在给客户端的响应字段首部加上 <code>Set-cookie</code>或 <code>Set-cookie2</code>, 值为 <code>名字=值</code>的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过 <code>Cookie</code>带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。</p>
<p>浏览器只会向产生这条cookie的站点发生cookie. <code>Set-cookie</code>字段的值会包含 <code>domain</code>这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。 <code>path</code>字段也是相似的功能。如i浏览器收到如下的cookie:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: user=&quot;mary&quot;; domain=&quot;stefno.com&quot;</span><br></pre></td></tr></table></figure>
<p>那么浏览器在访问任意以 <code>stefno.com</code>结尾的站点都会发送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot;mary&quot;</span><br></pre></td></tr></table></figure>
<h2 id="实体和编码"><a href="#实体和编码" class="headerlink" title="实体和编码"></a>实体和编码</h2><p>响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果 <code>Content-Type</code>定义是 <code>text/plain</code>, 那说明body内容就是文本，我们直接按文本编码来解释；如果 <code>Content-Type</code>定义是 <code>image/png</code>, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。</p>
<p><code>Content-Length</code>标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外， <code>Content-Length</code>在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上 <code>Content-Length</code>字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的 <code>Content-Length</code>首部。</p>
<p>HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。</p>
<p>HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到 <code>Content-MD5</code>这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改 <code>Content-MD5</code>首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与 <code>Content-MD5</code>首部进行比较。这主要是防止代理对报文进行了无意的改动。</p>
<p>HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0c3QiaTbXgX0sJtJicDibxDtN6wlniaHbgLSCwNiba2dXX12Z9jL5v12Gjshw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在 <code>Accept-Encoding</code>首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。</p>
<p>上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码： <code>传输编码</code>。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。</p>
<p>通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到 <code>Content-Length</code>中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到 <code>传输编码</code>来标注数据的结束的。</p>
<p>HTTP协议中通过如下两个首部来描述和控制传输编码：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>分块编码的报文形式是这样的：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0ckXIxrtbOKfscDcACkqLe3oOFeUOS25BxE4xBZ3zC0cvCibLMb3OicS2Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>每个分块包含一个长度值（十六进制，字节数）和该分块的数据。 <code>&lt;CR&gt;&lt;LF&gt;</code>用于区隔长度值和数据。长度值不包含分块中的任何 <code>&lt;CR&gt;&lt;LF&gt;</code>序列。最后一个分块，用长度值0来表示结束。注意报文首部包含一个 <code>Trailer:Content-MD5</code>, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如， <code>Content-Length</code>, <code>Trailer</code>, <code>Transfer-Encoding</code>也可以作为拖挂。</p>
<p>内容编码和传输编码是可以结合起来使用的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqvJ6263Sa8Ay3zGoGFqml8SWpzWtHL631ZTVqpRauJzoaNDltGeHibg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h2 id="国际化支持"><a href="#国际化支持" class="headerlink" title="国际化支持"></a>国际化支持</h2><p>HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，以及浏览器上安装了何种字母表编码算法。这通过 <code>Accept-Charset</code>和 <code>Accept-Language</code>首部实现。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: fr, en;q=0.8Accept-Charset: iso-8859-1, utf-8</span><br></pre></td></tr></table></figure>
<p>表示：客户端接受法语(fr, 优先级默认为1.0）、英语（en, 优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在 <code>Content-Type</code>首部里放上 <code>charset</code>.</p>
<p>本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码去字符集中找到对应的元素。</p>
<p>比较常见的字符集是 <code>US-ASCII</code>: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。可以再看下上文报文分析部分的acsii码集。</p>
<p><code>US-ASCII</code>是把每个字符编码成固定的7位二进制值。 <code>UTF-8</code>则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值，前两个bit位是用 <code>10</code>标识。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cJHSxBWJroo9TNWxXdoY9KiaPiaUYHLHaf77bqicIoQvYDKKDYPwtKqLIw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>举个例子，汉字“严”的Unicode编码为 <code>4E25</code>( <code>100111000100101</code>), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将 <code>100111000100101</code>填入上表中的 <code>c</code>位即可。因此，严的 <code>UTF-8</code>编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com.hk/search?q=%E4%B8%A5&amp;oq=%E4%B8%A5&amp;aqs=chrome..69i57j0l5.3802j0j4&amp;sourceid=chrome&amp;ie=UTF-8&amp;gws_rd=cr</span><br></pre></td></tr></table></figure>
<p><code>q=%E4%B8%A5</code>这个就是搜索的词了。</p>
<h2 id="重定向与负载均衡"><a href="#重定向与负载均衡" class="headerlink" title="重定向与负载均衡"></a>重定向与负载均衡</h2><p>Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。一般都会有所谓的“双活”，“多活”，所谓 <code>狡兔三窟</code>嘛。</p>
<p>这样，用户的请求会根据 <code>负载均衡</code>的原则，被 <code>重定向</code>到它应该去的地方。</p>
<h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>服务器收到客户端请求后，向客户端返回一条带有状态码 <code>302</code>重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用， <code>重定向</code>服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。</p>
<p>当然，缺点也是显而易见的，由于客户端要发送两次请求，因此会增加耗时。</p>
<h3 id="DNS重定向"><a href="#DNS重定向" class="headerlink" title="DNS重定向"></a>DNS重定向</h3><p>DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的 <code>轮转</code>；也可以是更高级的算法，如返回负载最轻的服务器的IP地址，称为 <code>负载均衡算法</code>；如果考虑地理位置，返回给客户端最近位置的地址，称为 <code>邻接路由算法</code>；还有一种是绕过出现故障的地址，称为 <code>故障屏蔽算法</code>。</p>
<p>DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。</p>
<h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>HTTP连接是HTTP报文传输的关键通道。</p>
<h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，速度会快起来。</p>
<p>如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cqsP47SichhaMHESR59XzoJ1V635S2pk6AMQXMaBT4tqIDBIH3fhiccDA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>采用并行连接之后：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cyPg8tia0Y7V1b7CumlkvGcuicicNBEFZeatkJKbkf7gTWrfiaibKLcRMU5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。</p>
<p>另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP keep-alive机制</p>
<p>我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。</p>
<p>HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。</p>
<p>HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61YicqQYO5ibtPVtamEicqmy0cnp6MPI6YLshmc8PgDUv1jq8LUcbwBOiczicxiaMTqNOticYL70ONWSCnXQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>HTTP有keep-alive机制，目的是可以在一个TCP 连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcpsetkeepalive，来激活连接的keep-alive属性。</p>
<p>当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过 <code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcpkeepaliveprobes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试 <code>tcp_keepalive_probes</code>次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p>
<h3 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h3><p>在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求按序放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。而且就算是服务端按序处理的，也不一定是按序返回给客户端，所以最好是在响应中附带一些可以标识请求的参数。</p>
<p>为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上，就是所有HTTP的通信细节了，足够在日常开发 作中使用了。更多没有涉及的细节可以在用到的时候再去仔细研究。</p>
<p>文章看完了，不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。</p>
<blockquote>
<p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p>
<p>如有冒犯，联系删除</p>
</blockquote>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/HTTP/"><i class="fas fa-hashtag fa-fw"></i>HTTP</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2019/03/28/三次握手，四次挥手-你真的懂吗？/">
              
                  “三次握手，四次挥手”你真的懂吗？
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-03-28
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/web基础/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              web基础
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！</p>
<p>作为程序员，要有“刨根问底”的精神。知其然，更要知其所以然。这篇文章希望能抽丝剥茧，还原背后的原理。</p>
<h1 id="什么是“3次握手，4次挥手”"><a href="#什么是“3次握手，4次挥手”" class="headerlink" title="什么是“3次握手，4次挥手”"></a><strong>什么是“3次握手，4次挥手”</strong></h1><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p>
<h2 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a><strong>TCP服务模型</strong></h2><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p>
<p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p>
<p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p>
<p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p>
<p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p>
<h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a><strong>TCP头部</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF9sL0PPjOs0LotFFbWklFVlMPuGIp1ltEkbK0hIibHtzZsZRvn9Liaz4Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p>
<p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p>
<p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p>
<p>ACK —— 确认，使得确认号有效。<br>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。<br>SYN —— 用于初如化一个连接的序列号。<br>FIN —— 该报文段的发送方已经结束向对方发送数据。</p>
<p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a><strong>状态转换</strong></h2><p>三次握手和四次挥手的状态转换如下图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFian001KXuKUicvYT7Pozrf2g50NrMtS2mPRuNYIWdgsSmplf8ic1KuV6g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h1 id><a href="#" class="headerlink" title=" "></a> </h1><h1 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a><strong>为什么要“三次握手，四次挥手”</strong></h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><p>换个易于理解的视角来看为什么要3次握手。</p>
<p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p>
<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。</p>
<p>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。</p>
<p>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>
<p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p>
<p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p>
<p>用表格总结一下：</p>
<table>
<thead>
<tr>
<th>视角</th>
<th>客收</th>
<th>客发</th>
<th>服收</th>
<th>服发</th>
</tr>
</thead>
<tbody>
<tr>
<td>客视角</td>
<td>二</td>
<td>一 + 二</td>
<td>一 + 二</td>
<td>二</td>
</tr>
<tr>
<td>服视角</td>
<td>二 + 三</td>
<td>一</td>
<td>一</td>
<td>二 + 三</td>
</tr>
</tbody>
</table>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p>
<h1 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a><strong>“三次握手，四次挥手”怎么完成？</strong></h1><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p>
<p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFYpRyHjvicckYBlR5ShkUOy9kXicV904eC9yjU8j0JvAowEWGW4KIT1kA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h2><ol>
<li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li>
<li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li>
<li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li>
</ol>
<h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h2 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmo1F4q8mQmxymUCGFAiaIu26E7mw2mj8cYu1qicdE4PVOsVtFJFrJMrw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<ol>
<li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li>
<li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li>
<li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li>
<li>客户端确认。ACK=L+1</li>
</ol>
<h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong></h2><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p>
<h1 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a><strong>“三次握手，四次挥手”进阶</strong></h1><h2 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a><strong>ISN</strong></h2><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p>
<blockquote>
<p>ISN = M + F(localhost, localport, remotehost, remoteport)</p>
</blockquote>
<p>M是一个计时器，每隔4毫秒加1。</p>
<p>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p>
<p><strong>序列号回绕</strong></p>
<p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p>
<blockquote>
<p>*/**</p>
<p>*<em> The next routines deal with comparing 32 bit unsigned ints</em></p>
<p>*<em> and worry about wraparound (automatic with unsigned arithmetic).</em></p>
<p>*<em>/</em></p>
<p>static inline <strong>int</strong> before(<strong>u32 seq1, </strong>u32 seq2)</p>
<p>{</p>
<p>​    <strong>return</strong> (__s32)(seq1-seq2) &lt; 0;</p>
<p>}</p>
<p>#define after(seq2, seq1) before(seq1, seq2)</p>
</blockquote>
<p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p>
<blockquote>
<p>假设seq1=255， seq2=1（发生了回绕）。</p>
<p>seq1 = 1111 1111 seq2 = 0000 0001</p>
<p>我们希望比较结果是</p>
<p>seq1 - seq2=</p>
<p>1111 1111</p>
<p>-0000 0001</p>
<p>-———-</p>
<p>1111 1110</p>
<p>由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为</p>
<p>0000 0001 + 1 = 0000 0010 = 2</p>
<p>因此seq1 - seq2 &lt; 0</p>
</blockquote>
<h2 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a><strong>syn flood攻击</strong></h2><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p>
<p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p>
<p>常见的防攻击方法有：</p>
<h3 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h3><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p>
<h3 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h3><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p>
<h4 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p>
<h4 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p>
<h3 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h3><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p>
<h2 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a><strong>连接队列</strong></h2><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFmakH75iacmvjKuByYibR6kVbsichiaV2aEYYhTicKdPJXAlJTMCmMCibUmKw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p>
<blockquote>
<p>查看是否有连接溢出</p>
<p>netstat -s | grep LISTEN</p>
</blockquote>
<h3 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a><strong>半连接队列满了</strong></h3><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p>
<p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFNI7SPfVDd7oQRIrGy3ribyxr8S6W46SJ58ZT5BAeibiahonct8nbIQcsQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><strong>全连接队列满了</strong></p>
<p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p>
<p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p>
<p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>命令</strong></p>
<p>netstat -s命令</p>
<blockquote>
<p>[root@server ~]#  netstat -s | egrep “listen|LISTEN”</p>
<p>667399 times the listen queue of a socket overflowed</p>
<p>667399 SYNs <strong>to</strong> LISTEN sockets ignored</p>
</blockquote>
<p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p>
<blockquote>
<p>[root@server ~]#  netstat -s | grep TCPBacklogDrop</p>
</blockquote>
<p>查看 Accept queue 是否有溢出</p>
<p>ss命令</p>
<blockquote>
<p>[root@server ~]#  ss -lnt</p>
<p>State Recv-Q Send-Q Local Address:Port Peer Address:Port</p>
<p>LISTEN     0      128 <em>:6379 </em>:*</p>
<p>LISTEN     0      128 <em>:22 </em>:*</p>
</blockquote>
<p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。</p>
<p>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p>
<p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p>
<p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p>
<h1 id="“三次握手，四次挥手”redis实例分析"><a href="#“三次握手，四次挥手”redis实例分析" class="headerlink" title="“三次握手，四次挥手”redis实例分析"></a><strong>“三次握手，四次挥手”redis实例分析</strong></h1><ol>
<li>我在dev机器上部署redis服务，端口号为6379,</li>
<li>通过tcpdump工具获取数据包，使用如下命令</li>
</ol>
<blockquote>
<p>tcpdump -w /tmp/a.cap port 6379 -s0</p>
<p>-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S0则会抓到完整数据包</p>
</blockquote>
<ol>
<li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li>
<li>停止抓包，用tcpdump读取捕获到的数据包</li>
</ol>
<blockquote>
<p>tcpdump -r /tmp/a.cap -n -nn -A -x| vim -</p>
<p>（-x 以16进制形式展示，便于后面分析）</p>
</blockquote>
<p>共收到了7个包。</p>
<p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p>
<p>IP的数据格式为：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFuia4XyKt3j44V4px2Fic7zjGvfOLTyohocqo1YhWamm3OdibRchUZaADg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>它由固定长度20B+可变长度构成。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYF1ock0p3DyjYPgkVc3icNcTmSQYwEmKJFPuibnGjxItx5IXnK9uOjc6jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>对着IP头部格式，来拆解数据包的具体含义。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFLUSiaJdMOtSxZMAPSUH2J0cMLFqiaVzA83WrqWBhXWCIfjCeOnu54cUg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>可变长度部分，协议如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFFiaC1F0oOwQX4mDye7HnszaFEdNO3vJRrZMw07dmywApRckbhK3jxJg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>这样第一个包分析完了。dev2向dev发送SYN请求。也就是三次握手中的第一次了。</p>
<p>SYN seq(c)=4133153791</p>
<p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.</p>
<p>SYN ack=seq(c)+1 seq(s)=4264776963</p>
<p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.</p>
<p>ack=seq(s)+1, seq=seq(c)+1</p>
<p>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p>
<p>接着第四个包。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFiaYrAMKnowJDk3ntjD7GeyOX5myHgZ0wBRciaMOFonkwNZJXRSJjlOicQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792</p>
<p>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p>
<blockquote>
<p>0x2a31         -&gt; *1</p>
<p>0x0d0a         -&gt; \r\n</p>
<p>0x2434         -&gt; $4</p>
<p>0x0d0a         -&gt; \r\n</p>
<p>0x7069 0x6e67  -&gt; ping</p>
<p>0x0d0a         -&gt; \r\n</p>
</blockquote>
<p>dev2向dev发送了ping数据，第四个包完毕。</p>
<p>第五个包，dev2向dev发送ack响应。</p>
<p>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p>
<p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.</p>
<p>数据部分2b50 4f4e 470d 0a, 翻译过来就是+PONG\r\n.</p>
<p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p>
<p><strong>总结</strong></p>
<p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p>
<p>所以，“三次握手，四次挥手”你真的懂了吗？</p>
<blockquote>
<p>本文转载自：<a href="https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YTtvp6gEXesM0WiuTGDW2Q</a></p>
<p>如有冒犯，联系删除</p>
</blockquote>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/TCP/"><i class="fas fa-hashtag fa-fw"></i>TCP</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2019/03/27/什么是HTTPS协议/">
              
                  什么是HTTPS协议
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-03-27
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/web基础/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              web基础
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <blockquote>
<p>作者 | 小   灰</p>
<p>责编 | 胡巍巍</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QibiajkGYjaNxI6pTvG3ehic6EktzRvZ4GD9PPsKuwaQLH4jVFbf92Kfdg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QnIBhBKXbcKDoX44n2YMvdqdHicJQNpyWReyib2PnhMTxSicSDumbWKRpw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QVq4x8hoGTrGwe7dfBCkhwgV9gD81KGQBsl9yPa7ic0uQIibcGxicsAxLw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmRdRTQTIs9muXtgY77wialvjWV8StsrkOa4hxqjrkia8ngZ2UKwTLkiaQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QiaicqJked2A0l9hYpwJVGtGhlV2KwGPUMqt1O1m6jr7FlRfbfC8ib95Jg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Q6pFlukc21dcoEdfEJvRoyBYA5WJmQW32drgyv0Uw02icmsrKgY5TuOw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSPn6JHA3Zyickib2fUa1dUwEfpjrcmZnYDXtrD207nibjkHEjVWiaPSwGQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QSln0sXSXHqrz7U1P5PQ05HwkBv5hPicWib2ic7qQpfVkhFiaqIf1559JaA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QImf2zKCHx6OTJZnV2pYARgwUMF53UicibRdgCJNrAowibo3X0cMPeJXFw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>什么是HTTP协议？</strong></p>
<p>HTTP协议全称Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于TCP/IP四层模型当中的应用层。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>HTTP协议通过请求/响应的方式，在客户端和服务端之间进行通信。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>这一切看起来很美好，但是HTTP协议有一个致命的缺点：不够安全。</p>
<p>HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢？让我们打一个比方：</p>
<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做中间人攻击。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>如何进行加密呢？</strong></p>
<p>小灰和小红可以事先约定一种对称加密方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>这样做是不是就绝对安全了呢？并不是。</p>
<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>这可怎么办呢？别担心，我们可以使用非对称加密，为密钥的传输做一层额外的保护。</p>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>
<p>在小灰和小红建立通信的时候，小红首先把自己的公钥Key1发给小灰：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥Key2，并且用刚才接收的公钥Key1对Key2进行加密（这里有点绕），发送给小红：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>小红利用自己非对称加密的私钥，解开了公钥Key1的加密，获得了Key2的内容。从此以后，两人就可以利用Key2进行对称加密的通信了。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>是什么坏主意呢？中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。</p>
<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>是什么解决方案呢？难道再把公钥进行一次加密吗？这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>
<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构（CA）来解决。到底什么是证书呢？证书包含如下信息：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>
<p>流程如下：</p>
<p>1.作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QmrhYBUv6aQ6RPpbEEWV4jnWURYvnB7QKKkCeLzwMZeicp8lytYms0yg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>3.当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QjQldYuHCKOcibkUMf7nhX0DD4EasCGcQS0os6suCO7fSxia7FjOYiaOzA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>4.小灰收到证书以后，要做的第一件事情是验证证书的真伪。</p>
<p>需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。</p>
<p>所以小灰只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>
<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥Key1。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QENwxMWjnWv6iaCM0JjG1faFyrEmPC6c1n2tZDIGo3icONyV91INJicAJA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>5.像之前一样，小灰生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给小红。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QKLTGwWJXwaHibic78VTbibpEIO5UBGCj1D0cVSFp1W32MKLQRGiaibYcTHg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>6.最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是两人开始用Key2进行对称加密的通信。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QxwRCiac136C5VLuNyVjFDG3teRNtwh1GmPvolrtpRcLxc8XeM2ibibyeQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢？</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QXVOiaHUuKTsf5Iqy360ukSZoM3jwPa9KiaMbmiakquh2MvF1Eg52wAbCQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QwOLtEPPhJToUf4EaQ6XvtNoJsoc9ibUWBYXJ8VPIl4Xo7ppnuc4icsxA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qy676yjvxP11icXgFDZER6iahoXLggnt84XUlg2nDSRgJdsbWNuRENBfg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9Qc73BXAGJgwvq8HwbU4IzorxmNNUujleX4buaugp3a2X1hUt3cLNSYA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QOThp6PEtNpia48W7vLtb5viauwJZW2rxfIRVOoNAT4UMXJa2Mo2QkNDQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QFibuV1f5f5lCG2ryskiaickbbW88icxFjibZKv7uQglyWcVicgVnicN96R0wQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QplvDw2aicOOm3R55rqB8mzO8Gia2l54JIInWnUFhTylD3C9mevf7DqYg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>注：最新推出的TLS协议，是SSL 3.0协议的升级版，和SSL协议的大体原理是相同的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqYxeicPqnxC3yHlG4zxga9QDg1EJYjK2vZfPbrZfHNy3gibl4vqJGIFsgqD3OK2iaLqFNq3IlTrkH3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<blockquote>
<p>声明：本文为作者投稿，首发于个人公众号程序员小灰，版权归其所有。</p>
</blockquote>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/HTTPS/"><i class="fas fa-hashtag fa-fw"></i>HTTPS</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2019/03/18/arcpy开发&关于arcgis中的api arcpy.Describe/">
              
                  arcpy开发&关于arcgis中的api arcpy.Describe
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-03-18
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/GIS/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              GIS
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>今天在学习关于工作空间相关知识，用于了下面的函数来实现判断当前输入的要素参数在哪个工作空间。其中主要运用到了arcpy.Describe函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_workspace</span><span class="params">(featureClass)</span>:</span></span><br><span class="line"> 	catalogPath = os.path.dirname(featureClass.catalogPath)</span><br><span class="line">    <span class="keyword">if</span> arcpy.Describe(catalogPath).dataType == <span class="string">'FeatureDataset'</span>:</span><br><span class="line">        arcpy.env.workspace = arcpy.Describe(catalogPath).path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        arcpy.env.workspace = featureClass.path</span><br><span class="line">    <span class="keyword">return</span> arcpy.env.workspace</span><br></pre></td></tr></table></figure>
<p>研究罢了，调试时查阅了Describe相关的参数，于是来看一下esri官方的参考文档，如下所说关于describe的种种：</p>
<p>Describe 函数返回的 Describe 对象包含多个属性，如数据类型、字段、索引以及许多其他属性。该对象的属性是动态的，这意味着根据所描述的数据类型，会有不同的描述属性可供使用。</p>
<p>Describe 属性被组织成一系列属性组。任何特定数据集都将至少获取其中一个组的属性。例如，如果要描述一个地理数据库要素类，您可访问 GDB 要素类、要素类、表和数据集属性组中的属性。所有数据，不管是哪种数据类型，总会获取通用 Describe 对象属性。</p>
<p>好了，说了这么多。我其实想说的是，可以使用describe查看数据的相关信息。比如shapeType、dataType、catalogPath、spatialReference等等相关信息。我们来看一下下面这一段代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input_fc = <span class="string">'D:/Data/中国国界和省界的SHP格式数据/省界/bou2_4p.shp'</span></span><br><span class="line">desc = arcpy.Describe(input_fc)</span><br><span class="line">catalogPath = os.path.dirname(desc.catalogPath)</span><br><span class="line">dataType=arcpy.Describe(catalogPath).dataType</span><br><span class="line">dataType2=desc.dataType</span><br></pre></td></tr></table></figure>
<p>现在我们把pycharm断点打开，一一窥探该函数会给我们带来什么样的信息。具体如下图所示。</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1552917456413.png" alt="1552917456413"></p>
<p>好了，关于describe的学习就到处为此了。</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/GIS-arcpy-python/"><i class="fas fa-hashtag fa-fw"></i>GIS; arcpy; python;</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2019/03/13/myFirstBlog/">
              
                  myFirstBlog
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-03-13
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
      
    </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/09/05/一则列表去重的思考/">
              
                  一则列表去重的思考
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-09-05
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/Python/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Python
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <pre><code>今天偶得休息,闲来无事悄悄代码,收到了一个这样的问题:
</code></pre><p>用两种或更多的方法实现对列表list1 = [1,1,2,3,3,5]进行去重。<br>时间紧任务急,博主现只写出了如下四种实现方式供大家参考,后续想到<br>更好的算法了再给大家分享,话不多说上代码,:</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>list1 = [1,1,2,3,3,5]</p>
<p>set1 = list(set(list1))</p>
<p>print(set1)</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>list2 = []</p>
<p>for i in range(len(list1)):<br>    if list1.index(list1[i]) == i:<br>        list2.append(list1[i])</p>
<p>print(list2)</p>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>list3 = [1,1,2,3,3,5]<br>for i in list3:<br>    if list3.count(i) 1:<br>        list3.pop(list3.index(i))</p>
<p>print(list3)</p>
<h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>list4 = []</p>
<p>for i in list1:<br>    if i not in list4:<br>        list4.append(i)</p>
<p>print(list4)</p>
<p>乍一看不觉这题难,对于接触过python的朋友来说,随手写出一两个不成问题,<br>但通过此事也意识到了,前面学过的知识还是要勤加复习避免遗忘,不说了博主要去复习了</p>

      
    </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/08/17/git 命令操作总结/">
              
                  git 命令操作总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-08-17
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/Git/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Git
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><ul>
<li><p>sudo apt-get intall git</p>
<blockquote>
<p>终端输入git 如果有提示证明安装成功</p>
</blockquote>
</li>
</ul>
<h3 id="2-git单人操作"><a href="#2-git单人操作" class="headerlink" title="2.git单人操作"></a>2.git单人操作</h3><ul>
<li><p>2.1 创建空的git仓库: git init</p>
<blockquote>
<p>提示: git仓库和项目的根路径在一起,用来管理项目</p>
</blockquote>
</li>
<li><p>2.2 配置git提交的用户名,邮箱</p>
<p>例如: git config user.name ‘zhangsan’</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; git config user.email <a href="mailto:&#39;111@qq.com" target="_blank" rel="noopener">&#39;111@qq.com</a>‘</p>
<blockquote>
<p>如果没有配置,默认使用的: home/.gitconfig  根目录下的用户信息</p>
</blockquote>
</li>
<li><p>2.3 查看文件状态: git status</p>
<blockquote>
<p>红色: 表示新建文件, 或者新修改了文件,目前位于工作区中</p>
<p>绿色: 表示文件在暂存区</p>
</blockquote>
</li>
<li><p>2.4将工作区代码, 添加到暂存区(工作区–&gt;暂存区)</p>
</li>
<li><p>例如: git add .  </p>
<p> &nbsp; &nbsp; &nbsp; git add xxx.py</p>
<blockquote>
<p>点表示添加所有变动,  xxx.py表示指定文件</p>
</blockquote>
</li>
<li><p>2.5将工作区代码,添加到仓库区(工作区—&gt;仓库区)</p>
</li>
<li><p>例如: git commit -m ‘注释’</p>
</li>
<li><p>2.6将工作区,直接添加到仓库区(工作区–&gt;暂存区—&gt;仓库区)</p>
</li>
<li><p>例如: git commit -am ‘注释信息’</p>
</li>
<li><p>2.7查看版本历史</p>
<p>例如: git log</p>
<p> &nbsp; &nbsp; &nbsp;  git reflog</p>
<blockquote>
<p>log查看详细信息, reflog查看简要信息</p>
</blockquote>
</li>
<li><p>2.8回退版本</p>
<p>例如: git reset –hard HEAD</p>
<p>或者: git reset –hard 版本号</p>
<blockquote>
<p>HEAD表示当前最新版本</p>
<p>HEAD^表示当前最新版本的,  上一个版本</p>
<p>HEAD^^表示当前最新版本的, 前两个版本, 依次类推</p>
<p>HEAD~1 表示当前最新版本的,  上一个版本</p>
<p>HEAD~2 表示当前最新版本的, 前两个版本, 依次类推</p>
</blockquote>
</li>
<li><p>2.9撤销工作区,暂存区修改</p>
<p>撤销工作区:  git checkout 文件名</p>
<p>撤销暂存区: </p>
<p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout HEAD 文件名 (暂存区-工作区)</p>
<p> &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; git checkout 文件名</p>
<blockquote>
<p>仓库区代码不能撤销</p>
</blockquote>
</li>
<li><p>2.10 版本对比</p>
<p>例如: git diff HEAD HEAD^ – xxx.py</p>
<blockquote>
<p>HEAD表示当前版本,   HEAD^表示上个版本, xxx.py对比的文件</p>
</blockquote>
</li>
<li><p>2.11误删除文件,恢复</p>
<p>格式1: rm 文件名</p>
<p>恢复1: git checkout – 文件名</p>
<p>格式2: git rm 文件名</p>
<p>恢复2: git reset –hard HEAD^</p>
</li>
</ul>
<h3 id="3-git多人操作"><a href="#3-git多人操作" class="headerlink" title="3.git多人操作"></a>3.git多人操作</h3><ul>
<li><p>3.1 clone项目到本地</p>
<p>例如: git clone 项目地址</p>
</li>
<li><p>3.2 推送项目到远程仓库</p>
<p>例如: git push</p>
<blockquote>
<p>第一次推送会提示输入账号, 密码</p>
</blockquote>
</li>
<li><p>3.3 配置是否输入登陆密码信息</p>
<blockquote>
<p>git config –global  credential.helper cache 十五分钟有效期</p>
<p>git config  credential.helper ‘cache –timeout==3600’ 一个小时有效期</p>
<p>git config –global credential.helper store 长期有效</p>
</blockquote>
</li>
<li><p>3.4 拉取远程最新代码到本地</p>
<p>例如: git pull</p>
</li>
</ul>
<h3 id="4-标签"><a href="#4-标签" class="headerlink" title="4.标签"></a>4.标签</h3><ul>
<li><p>4.1 设置本地标签</p>
<p>例如: git tag -a  标签名 -m ‘标签描述’</p>
</li>
<li><p>4.2 推送本地标签到远程</p>
<p>例如: git push origin 标签名</p>
</li>
<li><p>4.3 删除本地标签</p>
<p>例如: git tag -d 标签名</p>
</li>
<li><p>4.4 删除远程标签</p>
<p>例如: git push origin –delete tag 标签名</p>
</li>
</ul>
<h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h3><ul>
<li><p>5.1查看当前分支</p>
<p>例如: git branch</p>
</li>
<li><p>5.2创建本地分支,并切换到指定分支</p>
<p>例如: git checkout -b 分支名</p>
</li>
<li><p>5.3推送本地分支,到远程</p>
<p>例如: git push -u origin 分支名</p>
</li>
<li><p>5.4切换分支</p>
<p>例如: git checkout master / dev</p>
<blockquote>
<p>切换到主分支,或者是其他分支</p>
<p>其他用户第一次pull代码后,切换切换后才能使用git branch查看</p>
</blockquote>
</li>
<li><p>5.5合并子分支到主分支</p>
<p>例如: git merge 分支</p>
<blockquote>
<p>需要在master分支下操作改命令</p>
</blockquote>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/git-版本库/"><i class="fas fa-hashtag fa-fw"></i>git; 版本库</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/07/26/LivePreview无法正常工作/">
              
                  LivePreview无法正常工作
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-26
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/Blog/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Blog
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>2018/7/26 22:28:25</p>
<p>自从搭建了个人博客,一直以来都是使用 MarkdownPad 2 来写Blog。近日由于重新安装了系统,想着把MarkdownPad 2再重新安装下,安装后却发现提示无法开启渲染预览,这能难道程序员吗?于是开始了bug查找,发现了如下提示:</p>
<pre><code>LivePreview is not working - it displays an error message stating This view has crashed!

This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.

To fix this issue, please try installing the Awesomium 1.6.6 SDK.

If you continue to experience issues, please install Microsoft&apos;s DirectX End-User Runtimes.
</code></pre><p>读后发现大概意思是需要下载安装Awesomium 1.6.6 SDK，OK,那就先试试 Awesomium 1.6.6 SDK.点击提示页面的下载链接地址，然后安装之后，重新启动MarkdownPad 2就可以正常使用了。</p>
<p>附带软件下载地址：</p>
<blockquote>
<p>MarkdownPad2破解版本地址：链接: <a href="https://pan.baidu.com/s/1dF6C1MT" target="_blank" rel="noopener">https://pan.baidu.com/s/1dF6C1MT</a> 密码: j3cy</p>
</blockquote>
<blockquote>
<p>awesomium软件下载地址：链接: <a href="https://pan.baidu.com/s/1nvRuNaT" target="_blank" rel="noopener">https://pan.baidu.com/s/1nvRuNaT</a> 密码: e7t2 </p>
</blockquote>
<p>很多人不太喜欢试用版,试用版功能不全,下面附带注册码激活使用:</p>
<p>打开markdownpad2 –&gt; 帮助 –&gt;升级为专业版<br>按照如下输入：<br>​</p>
<blockquote>
<p>邮箱地址：<a href="mailto:Soar360@live.com" target="_blank" rel="noopener">Soar360@live.com</a></p>
</blockquote>
<blockquote>
<p>授权秘钥：<br>    GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</p>
</blockquote>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Markdown/"><i class="fas fa-hashtag fa-fw"></i>Markdown</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
  
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/2018/07/26/hexo博客出现command-not-found解决方案/">
              
                  hexo博客出现command not found解决方案
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="http://yoursite.com">
            <i class="fas fa-user" aria-hidden="true"></i>
            LLQ
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-26
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/Blog/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Blog
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>2018/7/26 22:14:17</p>
<p>自从上次更新了博客后,后来就开始了正式的学习,由于电脑升级的原因考虑到今后需要用到的软件会比较多,现在用的电脑配置有点低了,所以对电脑进行了一次小升级购买了固态后重装了系统,以致于之前的博客文件和配置的环境出现了问题,导致不能正常上传博客文件,后来课程太紧,一拖再拖没有来及解决这个问题.</p>
<p>今天去网上看了下,发现有很多这样的问题,重装系统后会出现command not found提示,接下来就是一波百度,寻找解决办法,发现个办法都有瑕疵并不能一次完美解决.</p>
<p>最后决定还是使用最粗暴的办法吧,也避免出现一些环境,插件缺少的问题,于是按照我之前写的教程开始了重新配置,安装完毕之后,首先查看各种工具是否都安装好了，在命令行中输入<code>node -v</code><br>然后再检查<code>npm -v</code>,<br>这些都没有问题的话,接下来检查下环境变量有没有配置,如果发现没有配置的话,可以先去找到这个路径，<code>C:\Users\feng\node_modules\hexo\bin</code>，然后把它添加到环境变量PATH路径的后面。这样基本就配置完成了.</p>
<p>提示:如果发现安装过程存在,使用淘宝NPM镜像，输入以下命令安装  cnpm, <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>,时出错的情况,可以检查下你的git和node的版本,笔者此前出现过因为版本过高而不能正常安装的问题.希望能给大家提供帮助.</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/hexo/"><i class="fas fa-hashtag fa-fw"></i>hexo</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
                  <a class="prev" rel="prev" href="/">
                      <section class="post prev">
                          <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
                      </section>
                  </a>
              
              <p class="current">
                  2 / 3
              </p>
              
                  <a class="next" rel="next" href="/page/3/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  




        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content material">
    
      <div class="avatar">
        <img class="avatar" src="/medias/avatar.jpg">
      </div>
    
    
      <div class="text">
        
        
        
          <p><span id="jinrishici-sentence">柳暗花明又一村</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zailushanga@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/llqing" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=1409711765" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        <section class="plain">
  
<header class="material">
  <div><i class="fas fa-bullhorn fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;注意啦～</div>
  
</header>

  <div class="content material">
    <p>小站栏目还在完善中，将不定期分享GIS、Code等内容(看博主心情)，如有特殊需要可以联系博主，超喜欢的话还可以安利给身边的朋友哦～</p>

  </div>
</section>

      
    
  
    
      
      
        
  <section class="category">
    
<header class="material">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content material">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/AI/" href="/categories/AI/"><div class="name">AI</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Blog/" href="/categories/Blog/"><div class="name">Blog</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/GIS/" href="/categories/GIS/"><div class="name">GIS</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Git/" href="/categories/Git/"><div class="name">Git</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/LaTeX/" href="/categories/LaTeX/"><div class="name">LaTeX</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Linux/" href="/categories/Linux/"><div class="name">Linux</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Python/" href="/categories/Python/"><div class="name">Python</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/web基础/" href="/categories/web基础/"><div class="name">web基础</div><div class="badge">(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/常用工具/" href="/categories/常用工具/"><div class="name">常用工具</div><div class="badge">(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/脚本/" href="/categories/脚本/"><div class="name">脚本</div><div class="badge">(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/高数/" href="/categories/高数/"><div class="name">高数</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="material">
  <div><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content material">
      <a href="/tags/AI/" style="font-size: 14px; color: #999">AI</a> <a href="/tags/GIS-arcpy-python/" style="font-size: 14px; color: #999">GIS; arcpy; python;</a> <a href="/tags/HTTP/" style="font-size: 14px; color: #999">HTTP</a> <a href="/tags/HTTPS/" style="font-size: 14px; color: #999">HTTPS</a> <a href="/tags/LaTeX/" style="font-size: 14px; color: #999">LaTeX</a> <a href="/tags/Markdown/" style="font-size: 24px; color: #555">Markdown</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/TCP/" style="font-size: 24px; color: #555">TCP</a> <a href="/tags/WebGIS/" style="font-size: 14px; color: #999">WebGIS</a> <a href="/tags/git-版本库/" style="font-size: 14px; color: #999">git; 版本库</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/linux/" style="font-size: 14px; color: #999">linux</a> <a href="/tags/music/" style="font-size: 14px; color: #999">music</a> <a href="/tags/如何开发用户脚本/" style="font-size: 14px; color: #999">如何开发用户脚本</a> <a href="/tags/导数/" style="font-size: 14px; color: #999">导数</a> <a href="/tags/极限/" style="font-size: 14px; color: #999">极限</a> <a href="/tags/激活/" style="font-size: 14px; color: #999">激活</a> <a href="/tags/网易/" style="font-size: 14px; color: #999">网易</a> <a href="/tags/重装系统/" style="font-size: 14px; color: #999">重装系统</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="material">
  <div><i class="fas fa-medal fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;精选项目</div>
  
</header>

  <div class="content material">
    <ul class="entry">
      
    </ul>
  </div>
</section>

      
    
  
    
      
      
        <section class="list">
  
<header class="material">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content material">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://llqing.github.io/about/" href="https://llqing.github.io/about/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;关于我 / 留言板
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  
    
      
      
        


  <section class="music">
    
<header class="material">
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn" target="_blank" rel="external nofollow noopener noreferrer" href="https://music.163.com/#/user/home?id=1409711765" title="https://music.163.com/#/user/home?id=1409711765">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class="content material">
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer" data-theme="#1BCDFC" data-mode="circulation" data-server="netease" data-type="playlist" data-id="1409711765" data-volume="0.7">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
    <div class="footer">
      <p>这里是页脚，谢谢支持。</p>

    </div>
    <br>
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zailushanga@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/llqing" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=1409711765" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>


  <!-- fastclick -->
  <script src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
  </script>










  <script src="/js/app.js"></script>
<script src="/js/search.js"></script>





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





    <script>setLoadingBarProgress(100);</script>
</body>
</html>
